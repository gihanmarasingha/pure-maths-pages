{"name": "Pure Mathematics with Lean", "version": "1.0.0", "languages": ["en"], "translated_name": "0", "devmode": false, "library_zip_fn": "Pure Mathematics with Lean-1.0.0-library.zip", "introData": {"name": "", "problemIndex": -1, "objects": [{"type": "text", "content": "1"}]}, "worlds": [{"name": "2", "levels": [{"name": "", "problemIndex": 8, "objects": [{"type": "lean", "content": "3", "hidden": true}, {"type": "text", "content": "4"}, {"type": "tactic", "content": "5", "name": "refl", "sideBar": true}, {"type": "text", "content": "6"}, {"type": "lean", "content": "7", "hidden": true}, {"type": "lean", "content": "8", "hidden": true}, {"type": "lean", "content": "9", "hidden": true}, {"type": "lean", "content": "10", "hidden": false}, {"type": "theorem", "text": "11", "lean": "theorem x_plus_y_eq_x_plus_y : x + y = x + y :=\n", "sideBar": false, "firstProofLineNumber": 65, "lastProofLineNumber": 65, "textBefore": "import myint.basic -- hide\n\n/-\n# Equations\n\n## Level 1: Proving equations through reflexivity\n\nIn the introduction, you read that tactics are used modify the goal, eventually proving \na theorem.\n\nThe `refl` tactic (short for `reflexivity`) can be used to prove any statement of the form\n`?X = ?X`. Here, I use `?X` to stand in for any expression of any type.\nIt could be `8 + 9` or `a * b` or `\"adele\"` or whatever.\n\nHere, you are asked to prove `x + y = x + y`, where `x` and `y` are integers.\nThe word `sorry` between the `begin` and `end` lines below asks Lean not to give an error message if a\nproof isn't complete. You'll see a warning message in the bottom-right hand pane. This indicates\nyou shouldn't trust the proof just yet, as it uses `sorry`!\n\nDelete `sorry` (using the backspace key on your keyboard). In the right-hand pane you'll see:\n```\nx y : \u2124\n\u22a2 x + y = x + y\n```\n\nHere, `x y : \u2124` is the *context*, the set of things you know. In this case, you know `x` and `y`\nare integers.\n\nThe *target* is `\u22a2 x + y = x + y`. The `\u22a2` symbol can be read 'to prove'. So your target is\nto prove `x + y = x + y`.\n\nThe bottom part of the right-hand pane shows an *error message*. Don't panic! It's just telling you\nthat you haven't yet proved the result.\n\nYour task is to replace `sorry` with `refl,`. Note the comma at the end of the line!\nIf you're successful, Lean will respond with the message `Proof complete!` or `no goals`.\n-/\n\n/- Tactic : refl\nThe `refl` tactic closes any goal of the form `?X = ?X`. That is, it proves any equation where the\nleft and right sides are *definitionally equal*.\n-/\n\n/-\n## Translation to a hand-written proof\n\nIn words, the `refl` says, \"The result holds by reflexivity\". A one-line written proof of\nthe theorem below would be, \"The result hold by reflexivity\".\n\n-/\n\nnamespace exlean -- hide\n\nopen myint -- hide\n\nopen_locale mynum -- hide\n\nvariables (x y : \u2124) -- Declare `x` and `y` to be integers.\n\n/- Theorem : no-side-bar\n`x + y = x + y`, for all integers `x` and `y`.\n-/\ntheorem x_plus_y_eq_x_plus_y : x + y = x + y :=\nbegin\n", "proof": "  refl,", "textAfter": "\nend\n\nend exlean -- hide\n", "height": 1, "editorText": "sorry", "lineOffset": 64, "name": "x_plus_y_eq_x_plus_y", "statement": "x + y = x + y"}, {"type": "lean", "content": "12", "hidden": true}]}, {"name": "", "problemIndex": 8, "objects": [{"type": "lean", "content": "13", "hidden": true}, {"type": "text", "content": "14"}, {"type": "lean", "content": "15", "hidden": true}, {"type": "lean", "content": "16", "hidden": true}, {"type": "lean", "content": "17", "hidden": true}, {"type": "axiom", "content": "18", "name": "add_comm (a b : \u2124) :", "sideBar": true}, {"type": "lean", "content": "19", "hidden": true}, {"type": "hint", "content": "20", "title": "21"}, {"type": "theorem", "text": "22", "lean": "theorem x_plus_y_eq_y_plus_x : x + y = y + x :=\n", "sideBar": false, "firstProofLineNumber": 69, "lastProofLineNumber": 70, "textBefore": "import myint.basic -- hide\n\n/-\n# Equations\n\n## Level 2: Commutativity of addition via `rw`\n\nNow we'll prove something (slighlty) more interesting, that `x + y = y + x` for all integers `x`\nand `y`. Try the `refl` tactic below (remember to put a comma after `refl`) and see what happens.\n\nYou'll get an error message:\n```\ninvalid apply tactic, failed to unify\n  x + y = y + x\nwith\n  ?m_2 = ?m_2\n```\n\nLean tells you that you're trying to use `refl` to prove `x + y = y + x`, but it expects a target\nof the form `?m_2 = ?m_2`. There's no special meaning to the underscores here. It's the same as\nwriting `?X = ?X` as in the previous level.\n\nThe problem: even though we 'know' the left and right sides are equal, they are not\n*identically equal*.\nFortunately, Lean comes with a *theorem* of just the right kind. It's called `add_comm`, which is\nshort for additive commutativity.\nThe result `add_comm a b` states that `a + b = b + a`, where `a` and `b` are integers.\n\nTo apply this theorem, we'll use the `rw` (short for `rewrite`) tactic.\n\nReplace the `sorry` below with `rw add_comm` (followed by a comma\u2014I won't mention this from now\non).\n\nLean will look for the first expression in the target that matches the pattern `a + b` and\nreplace every instance of that expression with `b + a`. Here, Lean finds `x + y` and replaces\nit with `y + x`.\n\nEqually, if `h` is an equation of the form `p = q` (where `p` and `q` are expressions),\n`rw h` will cause Lean to look for `p` in the target and replace it with `q`.\n\nHaving issued `rw add_comm`, the goal is to prove `y + x = y + x`.\nYou know how to prove a goal of this kind from the previous level.\nWrite the proof on the line after the `rw add_comm`.\n-/\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\nvariables (x y : \u2124) -- hide\n\n/- Axiom : add_comm (a b : \u2124) :\na + b = b + a\n-/\ntheorem add_comm (a b : \u2124) : a + b = b + a := myint.add_comm' a b -- hide\n\n/- Hint : Moving through a proof\n\nYour proof of the theorem below will use two lines of code. If you move your cursor to a previous\nline, Lean will show you the tactic state at any point in the proof. If you click on the name of\na theorem, you'll get some brief documentation.\n-/\n\n/- Theorem : no-side-bar\n`x + y = y + x`, for all integers `x` and `y`.\n-/\ntheorem x_plus_y_eq_y_plus_x : x + y = y + x :=\nbegin [pure_maths]\n", "proof": "  rw add_comm,\n  refl,", "textAfter": "\nend\n\nend exlean -- hide\n\n/-\n## Translation to a hand-written proof\n\nIn words, the `rw add_comm` says, \"Rewrite using commuativity of addition\".\nAs hand-written proofs aren't interactive, it's helpful to mention explicitly any changes to the\ncontext. Here's a hand-written proof of the above result.\n\n> Rewriting using commutativity of addition, the goal is to prove `y + x = y + x`.\n> This follows by reflexivity.\n-/\n\n/- Tactic : rw\nIf `h` is an equation of the form `p = q`, `rw h` rewrites replaces `p` in the target with `q`.\n\nIf `k` is in the context, `rw h at k` performs the rewrite at `k` instead of at the target.\n\n`rw \u2190h` will rewrite backward: every occurrence of `q` is replaced with `p`. Type `\\l` to produce `\u2190`.\n\n`rw [h1, h2, h3]` rewrites with multiple hypotheses (you aren't limited to three)!\n-/\n\n/-\n## Anatomy of a level\n\nEach level contains three vertial panes. The left-hand pane contains a list of the tactics and\ntheorem statements you've seen so far. Click on the arrows to dig deeper.\n\nThe middle pane is the one you're reading now! It contains text and interactive exercises.\nThe right-hand pane contains the Lean Infoview window, showing the 'tactic state' and error messages.\n\nYou can navigate through the book using the buttons in the top horizonal pane. The circular arrow\nresets your progress.\n-/\n\n/-\n## How `rw` here differs from that in standard Lean\n\nThe `rw` tactic used in this book is slightly different the standard `rw`. In particular, if\nthe result of a rewrite is an equation of the form `X = X`, then the standard `rw` tactic will\nautomatically close the goal via reflexivity.\n\nThis automation has been disabled here to help you think more carefully about proof construction.\n-/\n\n", "height": 2, "editorText": "sorry", "lineOffset": 68, "name": "x_plus_y_eq_y_plus_x", "statement": "x + y = y + x"}, {"type": "lean", "content": "23", "hidden": true}, {"type": "text", "content": "24"}, {"type": "tactic", "content": "25", "name": "rw", "sideBar": true}, {"type": "text", "content": "26"}, {"type": "text", "content": "27"}]}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "28", "hidden": true}, {"type": "text", "content": "29"}, {"type": "lean", "content": "30", "hidden": true}, {"type": "lean", "content": "31", "hidden": true}, {"type": "lean", "content": "32", "hidden": true}, {"type": "theorem", "text": "33", "lean": "theorem add_eq_add_two_mul_self_of_eq_two_mul (h : y = 2 * x) : x + y = x + 2 * x :=\n", "sideBar": false, "firstProofLineNumber": 37, "lastProofLineNumber": 38, "textBefore": "import myint.basic equations.commutativity_rw -- hide\n\n/-\n# Equations\n\n## Level 3: Rewriting with hypotheses\n\nLook at the theorem below. It seems that you're being asked to prove `x + y = x + 2 * x`.\nSurely that isn't true in general! What's\ngoing on? If you look carefully, you'll see an additional hypothesis, `h : y = 2 * x`.\n\nThe `:` is just notation for naming a hypothesis (also called an assumption).\nSo the statement of the theorem can be read:\n\n> Let `x` and `y` be integers. Let `h` be the hypothesis `y = 2 * x`. Then `x + y = x + 2 * x`.\n\nWhen you start the proof, you'll note in the top-right pane that `h : y = 2 * x` has been\nadded to the context.\n\nYou can use the hypothesis to rewrite the goal by typing `rw h` much as you used `rw add_comm`\nto rewrite via the theorem `add_comm`.\n\n**Before doing the problem below**, think about what effect `rw h` will have on the goal.\n-/\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\nvariables (x y : \u2124) -- hide\n\n/- Theorem : no-side-bar\nLet `x` and `y` be integers. Let `h` be the hypothesis `y = 2 * x`. Then `x + y = x + 2 * x`.\n-/\ntheorem add_eq_add_two_mul_self_of_eq_two_mul (h : y = 2 * x) : x + y = x + 2 * x :=\nbegin [pure_maths]\n", "proof": "  rw h,\n  refl,", "textAfter": "\nend\n\nend exlean -- hide\n\n/-\n## Translation to a hand-written proof\n\n> Rewriting using `h`, the goal is to prove `x + 2 * x = x + 2 * x`.\n> This follows by reflexivity.\n-/\n\n", "height": 2, "editorText": "sorry", "lineOffset": 36, "name": "add_eq_add_two_mul_self_of_eq_two_mul", "statement": "(h : y = 2 * x) : x + y = x + 2 * x"}, {"type": "lean", "content": "34", "hidden": true}, {"type": "text", "content": "35"}]}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "36", "hidden": true}, {"type": "text", "content": "37"}, {"type": "lean", "content": "38", "hidden": true}, {"type": "lean", "content": "39", "hidden": true}, {"type": "lean", "content": "40", "hidden": false}, {"type": "hint", "content": "41", "title": "42"}, {"type": "theorem", "text": "43", "lean": "theorem add_comm_left_right : (x + y) + z = z + (y + x) :=\n", "sideBar": false, "firstProofLineNumber": 59, "lastProofLineNumber": 61, "textBefore": "import myint.basic equations.commutativity_rw-- hide\n\n/-\n# Equations\n\n## Level 4: Focussed rewriting\n\nHere, you're asked to prove `(x + y) + z = z + (y + x)`. Clearly a case for rewriting with the\n`add_comm` theorem.\n\nThink about what `rw add_comm` will do. What will happen if you do `rw add_comm` twice? Try this\nbelow and test your conjecture.\n\nWhat happens is that `rw add_comm` looks for an expression of the form `a + b`. It finds one in\n`(x + y) + z`, matching `a` with `x + y` and `b` with `z`. It replaces this with `b + a`. That is,\nwith `z + (x + y)`.\n\nYou might wonder why this is the first match. Why doesn't Lean work on `x + y` first, matching\n`a` with `x` and `b` with `y`? It's because Lean works outside-in, then left-to-right. The second\n`+` operator in `(x + y) + z` is the outermost operator, so is read first by Lean.\n\nThe problem: applying `rw add_comm` to the new goal `\u22a2 z + (x + y) = z + (y + x)` will match `a`\nwith `z` and `b` with `x + y`, rewriting the goal to `\u22a2 (x + y) + z = z + (y + x)`, taking us back\nto where we started!\n\n### Focussing a rewrite with arguments\n\nRecall that `add_comm a b` is the theorem that `a + b = b + a`. The quantities `a` and `b` are\n*arguments* to the theorem `add_comm`.\nEqually, `add_comm x (y + z)` is the theorem that `x + (y + z) = (y + z) + x`. This theorem has\narguments `x` and `y + x`. Note than arguments can be expressions, not just variables.\n\nApplying `rw add_comm x (y + z)` transforms `\u22a2 z + (x + (y + z)) = z` to\n`\u22a2 z + ((y + z) + x) = z`.\n\nUse arguments, where necessary, to prove the theorem below.\n\n-/\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\nvariables (x y z : \u2124) -- Declare `x`, `y`, and `z` to be integers.\n\n/- Hint : Missing parentheses?\n\nWhen you start the proof below, Lean displays the target as `\u22a2 x + y + z = z + (y + x)`.\nWhat happened to the parentheses on the left-hand side? Lean treats addition as\n'left associative'. This is a fancy way of saying that `x + y + z` should always be\ninterpreted as `(x + y) + z`.\n-/\n\n/- Theorem : no-side-bar\nLet `x`, `y`, and `z` be integers. Then `(x + y) + z = z + (y + x)`.\n-/\ntheorem add_comm_left_right : (x + y) + z = z + (y + x) :=\nbegin [pure_maths]\n", "proof": "  rw add_comm,\n  rw add_comm x y,\n  refl,", "textAfter": "\nend\n\nend exlean -- hide\n\n/-\n## Translation to a hand-written proof\n\nHere's a suggestion. When writing a proof by hand, you need not (and should not) aim at a direct\ntranslation of a Lean proof. Here, I've kept the main idea of each line of my Lean proof while\ntranslating for ease of human understanding.\n\n> Rewriting by additive commutativity, the goal is to prove `z + (x + y) = z + (y + x)`.\n> Rewriting with additive commutativity on `x + y`, the goal is to prove `z + (y + x) = z + (y + x)`.\n> This follows by reflexivity.\n-/\n\n", "height": 3, "editorText": "sorry", "lineOffset": 58, "name": "add_comm_left_right", "statement": "(x + y) + z = z + (y + x)"}, {"type": "lean", "content": "44", "hidden": true}, {"type": "text", "content": "45"}]}, {"name": "", "problemIndex": 8, "objects": [{"type": "lean", "content": "46", "hidden": true}, {"type": "text", "content": "47"}, {"type": "lean", "content": "48", "hidden": true}, {"type": "lean", "content": "49", "hidden": true}, {"type": "axiom", "content": "50", "name": "add_assoc (a b c : \u2124) :", "sideBar": true}, {"type": "lean", "content": "51", "hidden": true}, {"type": "lean", "content": "52", "hidden": false}, {"type": "hint", "content": "53", "title": "54"}, {"type": "theorem", "text": "55", "lean": "theorem add_right_comm (x y z : \u2124) : (x + y) + z = (x + z) + y :=\n", "sideBar": true, "firstProofLineNumber": 43, "lastProofLineNumber": 46, "textBefore": "import myint.basic equations.commutativity_rw -- hide\n\n/-\n# Equations\n\n## Level 5: Associativity\n\nTime for a new theorem. This one is called `add_assoc`, which is short for additive associativity.\n\nThe result `add_assoc a b c` states that `(a + b) + c = a + (b + c)`, for all integers `a`, `b`,\nand `c`. You can see the statement in the sidebar on the left by unfolding 'Theorem statements'.\n\nAs with `add_comm`, you can use `add_assoc` to rewrite the goal using `rw add_assoc`.\n\nBelow, your task is to prove `(x + y) + z = x + (z + y)`. In future levels, this theorem will\nbe available as `add_right_comm`.\n\n**Before writing a Lean proof**, construct a hand-written proof.\n-/\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\n/- Axiom : add_assoc (a b c : \u2124) :\n(a + b) + c = a + (b + c)\n-/\ntheorem myint.add_assoc (a b c : \u2124) : a + b + c = a + (b + c) := myint.add_assoc' a b c -- hide\n\nopen myint\n\n/- Hint : Hint\n\nYou'll need to rewrite with both `add_comm` and `add_assoc`. You may need to give arguments to one\nof your rewrites, as described in the previous level.\n-/\n\n/- Theorem : \nLet `x`, `y`, and `z` be integers. Then `(x + y) + z = x + (z + y)`.\n-/\ntheorem add_right_comm (x y z : \u2124) : (x + y) + z = (x + z) + y :=\nbegin [pure_maths]\n", "proof": "  rw add_assoc,\n  rw add_comm y z,\n  rw add_assoc,\n  refl,", "textAfter": "\nend\n\n/-\n## Translation to a hand-written proof\n\nIn the following hand-written proof, I omit the word 'rewriting'.\n\n> By associativity, the goal is to prove `x + (y + z) = x + (z + y)`.\n> By commutativity, the goal is to prove `x + (z + y) = x + (z + y)`.\n> This follows by reflexivity.\n-/\n\nend exlean -- hide", "height": 4, "editorText": "sorry", "lineOffset": 42, "name": "add_right_comm", "statement": "(x y z : \u2124) : (x + y) + z = (x + z) + y"}, {"type": "text", "content": "56"}, {"type": "lean", "content": "57", "hidden": true}]}, {"name": "", "problemIndex": 8, "objects": [{"type": "lean", "content": "58", "hidden": true}, {"type": "text", "content": "59"}, {"type": "hint", "content": "60", "title": "61"}, {"type": "tactic", "content": "62", "name": "have", "sideBar": true}, {"type": "lean", "content": "63", "hidden": true}, {"type": "lean", "content": "64", "hidden": true}, {"type": "lean", "content": "65", "hidden": true}, {"type": "lean", "content": "66", "hidden": true}, {"type": "theorem", "text": "67", "lean": "theorem add_left_comm_comm : x + ((x + y) + z) = x + (z + (x + y)) :=\n", "sideBar": false, "firstProofLineNumber": 58, "lastProofLineNumber": 60, "textBefore": "import myint.basic equations.associativity -- hide\n\n/-\n# Equations\n\n## Level 6: Structuring proofs with `have`\n\nThe `have` tactic introduces a hypothesis into the context. It's a way to add structure to your\nproofs, stating and proving intermediate results before using them.\n\nConsider the goal `\u22a2 x + ((x + y) + z) = x + (z + (x + y))`.\n\nOne way to close this goal is to rewrite, giving specific arguments to `add_comm`.\nAnother option is to introduce an intermediate goal of proving `(x + y) + z = z + (x + y)`.\n\nThis is accomplished using `have h : (x + y) + z = z + (x + y)` (followed by a comma). \nThere's nothing special about `h` as the name of the hypothesis. Change it to whatever you wish.\n\nThis opens up a new goal: you'll see 2 goals in right-hand pane. The top goal is the new goal,\nnamely `\u22a2 (x + y) + z = z + (x + y)`. The bottom goal is the old goal, only with a new hypothesis,\n`h : (x + y) + z = z + (x + y)`.\n\nYou first work on closing the new goal, then close the original goal using hypothesis `h`.\n-/\n\n/- Hint : Focussing on one goal at a time\n\nIf you want to work only on goal, put braces after the `have`. When you're cursor is in the\ninner brace, you'll only be working on the first goal.\n```\nhave h : (x + y) + z = z + (x + y),\n{ sorry },\nsorry\n``` \n-/\n\n/- Tactic : have\n`have` is used to introduce a new hypothesis into the context. It opens a new goal for the proof\nof the hypothesis.\n\nFor example, `have h2 : x + y = y + x` introduces a new goal, to prove\n`x + y = y + x` while adding the hypothesis `h2 : x + y = y + x` to the context of the old goal.\n-/\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\nopen myint -- hide\n\nvariables (x y z : \u2124) -- hide\n\n/- Theorem : no-side-bar\nLet `x`, `y`, and `z` be integers. Then `x + ((x + y) + z) = x + (z + (x + y)))`.\n-/\ntheorem add_left_comm_comm : x + ((x + y) + z) = x + (z + (x + y)) :=\nbegin [pure_maths]\n", "proof": "  have h : (x + y) + z = z + (x + y),\n  rw add_comm, refl,\n  rw h, refl,", "textAfter": "\nend\n\n/-\n## Translation to a hand-written proof\n\nIn my hand-written proof below, I omit references to reflexivity.\n\n> I claim `h : (x + y) + z = z + (x + y)`.\n> To prove this, use commutativity of addition.\n> Rewrite the original goal using `h`.\n-/\n\nend exlean -- hide", "height": 3, "editorText": "sorry", "lineOffset": 57, "name": "add_left_comm_comm", "statement": "x + ((x + y) + z) = x + (z + (x + y))"}, {"type": "text", "content": "68"}, {"type": "lean", "content": "69", "hidden": true}]}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "70", "hidden": true}, {"type": "text", "content": "71"}, {"type": "lean", "content": "72", "hidden": true}, {"type": "lean", "content": "73", "hidden": true}, {"type": "lean", "content": "74", "hidden": true}, {"type": "lean", "content": "75", "hidden": true}, {"type": "theorem", "text": "76", "lean": "theorem add_comm_adele : x + (y + (x + z)) = (z + (x + y)) + x :=\n", "sideBar": false, "firstProofLineNumber": 28, "lastProofLineNumber": 30, "textBefore": "import myint.basic equations.associativity -- hide\n\n/-\n# Equations\n\n## Level 7: Multiple rewrites\n\nRather than writing, for example `rw add_assoc x y z, rw add_comm`, you can write\n`rw [add_assoc x y z, add_comm]`. Use this technique, together with `have`, to write a structured\nproof below.\n\nNow write a proof using a long chain of rewrites followed by `refl`. Which proof do you prefer? Why?\n-/\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\nopen myint -- hide\n\nvariables (x y z : \u2124) -- hide\n\n/- Theorem : no-side-bar\nLet `x`, `y`, and `z` be integers. Then `x + (y + (x + z)) = (z + (x + y)) + x`.\n-/\ntheorem add_comm_adele : x + (y + (x + z)) = (z + (x + y)) + x :=\nbegin [pure_maths]\n", "proof": "  have h : y + (x + z) = z + (x + y),\n    rw add_comm, rw add_comm x, rw add_assoc, refl,\n  rw h, rw add_comm, refl,", "textAfter": "\nend\n\nend exlean -- hide", "height": 3, "editorText": "sorry", "lineOffset": 27, "name": "add_comm_adele", "statement": "x + (y + (x + z)) = (z + (x + y)) + x"}, {"type": "lean", "content": "77", "hidden": true}]}, {"name": "", "problemIndex": 14, "objects": [{"type": "lean", "content": "78", "hidden": true}, {"type": "text", "content": "79"}, {"type": "lean", "content": "80", "hidden": true}, {"type": "lean", "content": "81", "hidden": true}, {"type": "lean", "content": "82", "hidden": true}, {"type": "lean", "content": "83", "hidden": true}, {"type": "text", "content": "84"}, {"type": "lean", "content": "85", "hidden": false}, {"type": "lean", "content": "86", "hidden": true}, {"type": "lean", "content": "87", "hidden": false}, {"type": "lean", "content": "88", "hidden": true}, {"type": "lean", "content": "89", "hidden": false}, {"type": "text", "content": "90"}, {"type": "hint", "content": "91", "title": "92"}, {"type": "theorem", "text": "93", "lean": "theorem funky_town\n(h : (z + x) + y = y + z * x) : y + z * x = y + (z + x) :=\n", "sideBar": false, "firstProofLineNumber": 58, "lastProofLineNumber": 64, "textBefore": "import myint.basic equations.multiple_rewrites -- hide\n\n/-\n# Equations\n\n## Level 8: Backward rewrites\n\nSuppose you wanted to prove `y + x = 0` on the assumptions `h1 : x + 0 = 0` and `h2 : y = 0`.\nOne option would be to rewrite with `h2` to give `\u22a2 0 + x = 0`. You could then finish by\nrewriting with `add_comm` and `h1`.\n\nAnother option is to start by rewriting with `h1` *backward*. This would replace `0`\nin the target with `x + 0`. To do this in Lean, type `rw \u2190h1`.\n\nTo get the left arrow, type `\\l` followed by space or tab. Alternatively, just type `<-`\n-/\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\nopen myint -- hide\n\nvariables (x y z : \u2124) -- hide\n\n/-\nHere is a proof of this result, using three rewrites, one backward.\n-/\n\nexample (h1 : x + 0 = 0) (h2 : y = 0) : y + x = 0 :=\nbegin\n  [pure_maths] -- hide\n  rw [\u2190h1, add_comm, h2],\n  refl,\n\n-- hide  \nend\n\n/-\nYour turn! Prove the following using two rewrites, one backward.\n\nOnce you've done that, write a structured proof of the same result.\n-/\n\n/- Hint: Hint for structured proof\n\nIntroduce and prove the hypotheses `h2 : y + z * x = (z + x) + y` and\n`h3 : (z + x) + y = y + (z + x)` using the `have` tactic. Finish by rewriting with these\nhypotheses.\n-/\n\n/- Theorem : no-side-bar\nLet `x`, `y`, and `z` be integers. If `(z + x) + y = y + z * x`, then `y + z * x = y + (z + x)`\n-/\ntheorem funky_town\n(h : (z + x) + y = y + z * x) : y + z * x = y + (z + x) :=\nbegin [pure_maths]\n", "proof": "  rw [\u2190h, add_comm],\n  refl,\n/-   have h2 : y + z * x = (z + x) + y,\n  { rw h, refl },\n  have h3 : (z + x) + y = y + (z + x),\n  { rw add_comm, refl },\n  rw [h2, h3], refl,  -/", "textAfter": "\nend\n\nend exlean -- hide", "height": 7, "editorText": "sorry", "lineOffset": 57, "name": "funky_town", "statement": "(h : (z + x) + y = y + z * x) : y + z * x = y + (z + x)"}, {"type": "lean", "content": "94", "hidden": true}]}, {"name": "", "problemIndex": 8, "objects": [{"type": "lean", "content": "95", "hidden": true}, {"type": "text", "content": "96"}, {"type": "lean", "content": "97", "hidden": true}, {"type": "lean", "content": "98", "hidden": true}, {"type": "lean", "content": "99", "hidden": true}, {"type": "axiom", "content": "100", "name": "add_zero (a : \u2124) :", "sideBar": true}, {"type": "lean", "content": "101", "hidden": true}, {"type": "text", "content": "102"}, {"type": "theorem", "text": "103", "lean": "theorem zero_add (a : \u2124) : 0 + a = a :=\n", "sideBar": true, "firstProofLineNumber": 36, "lastProofLineNumber": 36, "textBefore": "import myint.basic equations.backward_rewrite -- hide\n\n/-\n# Equations\n\n## Level 9: Additive identity\n\nThe Lean theorem `add_zero` states that `x + 0 = x` for every integer `x`. In mathematics, this\nproperty is called (right) additive identity. Note `add_zero` should appear as a 'Theorem statement'\nin the left-hand pane. \n-/\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\nopen myint -- hide\n\n/- Axiom : add_zero (a : \u2124) :\na + 0 = a\n-/\ntheorem add_zero (a : \u2124) : a + 0 = a := myint.add_zero' a -- hide\n\n/- \nYour goal is to prove `zero_add`, the right additive identity property, using `add_zero`.\nOnce you've done this, `zero_add` will be available to you in future levels.\n\nAs always, construct a hand-written proof **before** writing your Lean proof.\n-/\n\n/- Theorem :\n`0 + a = a` for every integer `a`.\n-/\ntheorem zero_add (a : \u2124) : 0 + a = a :=\nbegin [pure_maths]\n", "proof": "  rw add_comm, rw add_zero, refl,", "textAfter": "\nend\n\nend exlean -- hide", "height": 1, "editorText": "sorry", "lineOffset": 35, "name": "zero_add", "statement": "(a : \u2124) : 0 + a = a"}, {"type": "lean", "content": "104", "hidden": true}]}, {"name": "", "problemIndex": 8, "objects": [{"type": "lean", "content": "105", "hidden": true}, {"type": "text", "content": "106"}, {"type": "lean", "content": "107", "hidden": true}, {"type": "lean", "content": "108", "hidden": true}, {"type": "lean", "content": "109", "hidden": true}, {"type": "lean", "content": "110", "hidden": true}, {"type": "text", "content": "111"}, {"type": "tactic", "content": "112", "name": "specialize", "sideBar": true}, {"type": "theorem", "text": "113", "lean": "theorem two_add_five_eq_eight_add_five_of (h : \u2200 x, x + 5 = 10) : 2 + 5 = 8 + 5 :=\n", "sideBar": false, "firstProofLineNumber": 65, "lastProofLineNumber": 65, "textBefore": "import myint.basic equations.additive_identity -- hide\n\n/-\n# Equations\n\n## Level 10: Universal statements\n\nSo far, our hypotheses have made reference to specific variables. The hypothesis `h : x + 3 = 5`\nstates `x + 3 = 5` for the particular variable `x`.\n\nIf we want a statement that holds *for every* value of a variable, we use the *universal quantifier*\n`\u2200`. This is read, \"for all\" or \"for every\" and is typed `\\all`.\n\nFor example, `\u2200 (x : \u2124), x + 5 = 10` states that `x + 5 = 10` *for every* integer `x`. Of course,\nthis is a false statement! A statement that begins with `\u2200` is called a\n*universally quantified statement*.\n\nHere's how to *use* a universally quantified statement. Given the hypothesis\n`h : \u2200 (x : \u2124), x + 5 = 10`, the expression `h 3` corresponds to `3 + 5 = 10`.\nIt's what we get by replacing `x` with `3` in the body of the statement.\n\nIf `3 + 5` appears in the target, then `rw h 3` replaces `3 + 5` with `10`.\n\n### The specialize tactic\n\nThe `specialize` tactic specializes a universally quantified statement. For example if\n`h : \u2200 (x : \u2124), x + 5 = 10`, then `specialize h 20` *replaces* `h` with\n`h : 20 + 5 = 10`. However, after using `specialize`, you can't go back to the more general\nversion of `h`.\n-/\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\nopen myint -- hide\n\nvariable (x : \u2124) -- hide\n\n/-\nHere, you'll prove the unusual result `2 + 5 = 8 + 5` on the assumption `\u2200 x, x + 5 = 10`.\n\nWrite a proof using `rw`.\n\nWrite another proof where you use one `rw` and one application of `specialize`.\n\nThink about how you'd write this proof by hand. Compare with my suggested translation at the bottom\nof the page.\n-/\n\n/- Tactic : specialize\nLet the hypothesis `h` be a universally-quantified statement. For example,\n`h : \u2200 (x : \u2124), x + 5 = 10`.\nThen `specialize h 8` replaces `x` with `8` in the body of `h`. Thus `h` becomes `8 + 5 = 10`.\n\nYou can specialize on more than one variable at a time. If `k : \u2200 (x y : \u2124), x + y = y * x`, then\n`specialize k 2 3` replaces `h` with `h : 2 + 3 = 3 * 2`.\n-/\n\n/- Theorem : no-side-bar\n`2 + 5 = 8 + 5` on the assumption `\u2200 x, x + 5 = 10`.\n-/\ntheorem two_add_five_eq_eight_add_five_of (h : \u2200 x, x + 5 = 10) : 2 + 5 = 8 + 5 :=\nbegin [pure_maths]\n", "proof": "  rw [h 2, h 8], refl,", "textAfter": "\nend\n\n/-\n## Translation to a hand-written proof\n\n> Using `h` with `2` in space of `x`, we must show `10 = 8 + 5`.\n> But this follows on taking `x` to be `8` in `h`.\n-/\n\nend exlean -- hide", "height": 1, "editorText": "sorry", "lineOffset": 64, "name": "two_add_five_eq_eight_add_five_of", "statement": "(h : \u2200 x, x + 5 = 10) : 2 + 5 = 8 + 5"}, {"type": "text", "content": "114"}, {"type": "lean", "content": "115", "hidden": true}]}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "116", "hidden": true}, {"type": "text", "content": "117"}, {"type": "lean", "content": "118", "hidden": true}, {"type": "lean", "content": "119", "hidden": true}, {"type": "lean", "content": "120", "hidden": true}, {"type": "hint", "content": "121", "title": "122"}, {"type": "theorem", "text": "123", "lean": "theorem right_additive_identity_unique (e : \u2124) (h : \u2200 (x : \u2124), x + e = x) : e = 0 :=\n", "sideBar": false, "firstProofLineNumber": 29, "lastProofLineNumber": 31, "textBefore": "import myint.basic equations.additive_identity -- hide\n\n/-\n# Equations\n\n## Level 11: Uniqueness of additive identity\n\nIn a previous level, we saw that there's an integer `0` with the properties that\n`x + 0 = x` for every `x`.\n\nIn this level, you'll show that `0` is the *only* integer that satisfies this property.\n-/\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\nopen myint -- hide\n\n/- Hint : Hint\nUse the `specialize` tactic.\n-/\n\n/- Theorem : no-side-bar\nLet `e` be an integer satsifying the property `\u2200 (x : \u2124), x + e = x`. Then `e` must be `0`.\n-/\ntheorem right_additive_identity_unique (e : \u2124) (h : \u2200 (x : \u2124), x + e = x) : e = 0 :=\nbegin [pure_maths]\n", "proof": "  specialize h 0,\n  rw [\u2190h, zero_add],\n  refl,", "textAfter": "\nend\n\nend exlean -- hide", "height": 3, "editorText": "sorry", "lineOffset": 28, "name": "right_additive_identity_unique", "statement": "(e : \u2124) (h : \u2200 (x : \u2124), x + e = x) : e = 0"}, {"type": "lean", "content": "124", "hidden": true}]}, {"name": "", "problemIndex": 10, "objects": [{"type": "lean", "content": "125", "hidden": true}, {"type": "text", "content": "126"}, {"type": "lean", "content": "127", "hidden": true}, {"type": "lean", "content": "128", "hidden": true}, {"type": "lean", "content": "129", "hidden": true}, {"type": "axiom", "content": "130", "name": "add_left_neg (a : \u2124) :", "sideBar": true}, {"type": "lean", "content": "131", "hidden": true}, {"type": "axiom", "content": "132", "name": "add_right_neg (a : \u2124) :", "sideBar": true}, {"type": "lean", "content": "133", "hidden": true}, {"type": "hint", "content": "134", "title": "135"}, {"type": "theorem", "text": "136", "lean": "theorem add_add_neg (x y : \u2124) : (x + y) + (-x) = y :=\n", "sideBar": true, "firstProofLineNumber": 41, "lastProofLineNumber": 44, "textBefore": "import myint.basic equations.unique_additive_identity -- hide\n\n/-\n# Equations\n\n## Level 12: Additive inverse\n\nThe Lean theorem `add_left_neg` states that `(-a) + a = 0` for every integer `a`. In mathematics,\nthis property is called (left) additive inverse.\n\nLikewise `add_right_neg (a : \u2124) : a + (-a) = 0`.\n\nYou'll use one of these properties in proving the next result.\n-/\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\nopen myint -- hide\n\n/- Axiom : add_left_neg (a : \u2124) :\n(-a) + a = 0\n-/\ntheorem add_left_neg (a : \u2124) : (-a) + a = 0  := myint.add_left_neg a -- hide\n\n/- Axiom : add_right_neg (a : \u2124) :\n(-a) + a = 0\n-/\ntheorem add_right_neg (a : \u2124) : a + (-a) = 0  := myint.add_right_neg a -- hide\n\n/- Hint : Hint\nYou might find it useful to use the previously-proved theorem `add_right_comm`.\n-/\n\n/- Theorem :\nFor all integers `x` and `y`, we have `(x + y) + -x = y`.\n-/\ntheorem add_add_neg (x y : \u2124) : (x + y) + (-x) = y :=\nbegin [pure_maths]\n", "proof": "  rw add_right_comm,\n  rw add_right_neg,\n  rw zero_add,\n  refl,", "textAfter": "\nend\n\nend exlean -- hide", "height": 4, "editorText": "sorry", "lineOffset": 40, "name": "add_add_neg", "statement": "(x y : \u2124) : (x + y) + (-x) = y"}, {"type": "lean", "content": "137", "hidden": true}]}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "138", "hidden": true}, {"type": "text", "content": "139"}, {"type": "lean", "content": "140", "hidden": true}, {"type": "lean", "content": "141", "hidden": true}, {"type": "lean", "content": "142", "hidden": true}, {"type": "hint", "content": "143", "title": "144"}, {"type": "theorem", "text": "145", "lean": "theorem eq_zero_of_add_right_eq_self (a b : \u2124) (h : a + b = a) : b = 0 :=\n", "sideBar": false, "firstProofLineNumber": 37, "lastProofLineNumber": 42, "textBefore": "import myint.basic equations.additive_inverse -- hide\n\n/-\n# Equations\n\n## Level 13: Cancellation I\n\nRecall the (right) uniqueness of additive identity. Let `y` be an integer. If for every integer `x`,\nwe have `x + y = x`, then `y = 0`.\n\nIn this level, we'll prove a theorem that is subtly different. Let `y` and `x` be integers. If\n`x + y = x`, then `y = 0`.\n\n**Question**: how does this new statement differ from from the uniqueness of additive identity?\n\nThe new result cannot be proved using only additive identity. You'll need to use the\nadditive inverse property.\n\nThis may be the most challenging level so far.\n-/\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\nopen myint -- hide\n\n/- Hint : Hint\nUse `add_add_neg`.\n-/\n\n/- Theorem : no-side-bar\nIf `a + b = a`, then `b = 0`.\n-/\ntheorem eq_zero_of_add_right_eq_self (a b : \u2124) (h : a + b = a) : b = 0 :=\nbegin [pure_maths]\n", "proof": "  have h2 : (a + b) + (-a) = b,\n  { rw add_add_neg, refl,  },\n  rw \u2190 h2,\n  rw h,\n  rw add_right_neg,\n  refl,", "textAfter": "\nend\n\nend exlean -- hide", "height": 6, "editorText": "sorry", "lineOffset": 36, "name": "eq_zero_of_add_right_eq_self", "statement": "(a b : \u2124) (h : a + b = a) : b = 0"}, {"type": "lean", "content": "146", "hidden": true}]}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "147", "hidden": true}, {"type": "text", "content": "148"}, {"type": "lean", "content": "149", "hidden": true}, {"type": "lean", "content": "150", "hidden": true}, {"type": "lean", "content": "151", "hidden": true}, {"type": "hint", "content": "152", "title": "153"}, {"type": "theorem", "text": "154", "lean": "theorem right_additive_inverse_unique (x y : \u2124) (h : x + y = 0) : y = -x :=\n", "sideBar": false, "firstProofLineNumber": 27, "lastProofLineNumber": 30, "textBefore": "import myint.basic equations.cancellation_i -- hide\n\n/-\n# Equations\n\n## Level 14: Uniqueness of additive inverse\n\nWe've seen the uniqueness of (right) additive identity. Now we'll show the uniqueness of (right)\nadditive inverse.\n-/\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\nopen myint -- hide\n\n/- Hint : Hint\nUse `add_add_neg`.\n-/\n\n/- Theorem : no-side-bar\nLet `x` and `y` be integers. If `x + y = 0`, then `y = -x`. \n-/\ntheorem right_additive_inverse_unique (x y : \u2124) (h : x + y = 0) : y = -x :=\nbegin [pure_maths]\n", "proof": "  rw \u2190add_add_neg x y,\n  rw h,\n  rw zero_add,\n  refl,", "textAfter": "\nend\n\nend exlean -- hide", "height": 4, "editorText": "sorry", "lineOffset": 26, "name": "right_additive_inverse_unique", "statement": "(x y : \u2124) (h : x + y = 0) : y = -x"}, {"type": "lean", "content": "155", "hidden": true}]}, {"name": "", "problemIndex": 7, "objects": [{"type": "lean", "content": "156", "hidden": true}, {"type": "text", "content": "157"}, {"type": "lean", "content": "158", "hidden": true}, {"type": "lean", "content": "159", "hidden": true}, {"type": "lean", "content": "160", "hidden": true}, {"type": "lean", "content": "161", "hidden": false}, {"type": "text", "content": "162"}, {"type": "theorem", "text": "163", "lean": "theorem ymca (x y z : \u2124) : (y + x) + (0 + z + 0) + (0 + x + 0) = y + (z + (x + x)) :=\n", "sideBar": false, "firstProofLineNumber": 40, "lastProofLineNumber": 40, "textBefore": "import myint.basic equations.unique_additive_inverse -- hide\n\n/-\n# Equations\n\n## Level 15: The simplifier\n\nThis level introduces a powerful new tactic, `simp`, Lean's simplifier. It rewrites \nrepeatedly using either supplied theorems & hypotheses or theorems that it 'knows'.\n\nTo suggest theorems and hypotheses for use with `simp`, provide them as a comma-separated list.\nIn the example below, we supply `simp` with `add_assoc` and `add_comm y x`.\n\nWithout `simp`, you'd need several applications of `rw add_assoc`. \n-/\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\nopen myint -- hide\n\nexample (x y z : \u2124) : x + ((y + z) + x) = (y + x) + (z + x) :=\nbegin\n  simp [add_assoc, add_comm y x],\nend\n\n/-\nProve the result below using only `simp` with supplied theorems, as in the example above. You should\nonly need to supply four theorems.\n\nFor fun (!) try proving this result using `rw`. Which proof do you prefer?\n-/\n\n/- Theorem : no-side-bar\nLet `x`, `y`, and `z` be integers. Then `(y + x) + (0 + z + 0) + (0 + x + 0) = y + (z + (x + x))`\n-/\ntheorem ymca (x y z : \u2124) : (y + x) + (0 + z + 0) + (0 + x + 0) = y + (z + (x + x)) :=\nbegin\n", "proof": "  simp [add_assoc, add_comm x z, add_zero, zero_add],", "textAfter": "\nend\n\nend exlean -- hide", "height": 1, "editorText": "sorry", "lineOffset": 39, "name": "ymca", "statement": "(x y z : \u2124) : (y + x) + (0 + z + 0) + (0 + x + 0) = y + (z + (x + x))"}, {"type": "lean", "content": "164", "hidden": true}]}]}, {"name": "165", "levels": [{"name": "", "problemIndex": 7, "objects": [{"type": "lean", "content": "166", "hidden": true}, {"type": "text", "content": "167"}, {"type": "lean", "content": "168", "hidden": true}, {"type": "lean", "content": "169", "hidden": true}, {"type": "axiom", "content": "170", "name": "`my_f`", "sideBar": true}, {"type": "lean", "content": "171", "hidden": false}, {"type": "text", "content": "172"}, {"type": "theorem", "text": "173", "lean": "theorem my_fun : my_f 10 = 35 :=\n", "sideBar": false, "firstProofLineNumber": 51, "lastProofLineNumber": 51, "textBefore": "import mynat.basic -- hide\n\n/-\n# Functions\n\n## Level 1: Defining functions\n\nA function is a map from one set, called the domain, to another set, called the codomain.\n\nThe notation `f : S \u2192 T` is read, \"`f` is a function with domain `S` and codomain `T`\" or \"`f` is a\nfunction from `S` to `T`\".\n\nTo specify that `f` maps each `x` to some expression `y`, we write `f : x \u21a6 y` or\n`f(x) = y`, when doing mathematics by hand.\n\nIn Lean, we combine all the above information into:\n```\ndef f : S \u2192 T := \u03bb x, y\n```\nwhere `y` is an expression that depends on `x`. Here `\u03bb` is a Greek letter called lambda.\nIts only significance is to indicate that the following quantity `x` is a variable.\n\nBelow is the definition of a function `my_f` from the set `\u2115` of natural numbers (the non-negative)\nintegers to itself. It takes each `x` to `3 * x + 5`.\n-/\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\n/- Axiom : `my_f`\nThe function `my_f` is defined so that `my_f (x) = 3 * x + 5` for every \nnatural number `x`.\n-/\ndef my_f : \u2115 \u2192 \u2115 := \u03bb x, 3 * x + 5\n\n/-\nYour task is to prove `my_f 10 = 35`. By definition of `my_f`, you must prove `3 * 10 + 5 = 35`.\nIt may come as a surprise to learn that Lean can prove this using `refl`.\nThe reason is that when Lean uses `refl`, it applies definitions until no further simplification is\npossible. For reasons that will become apparent later, the definitions of addition and\nmultiplication can be applied to reduce any 'sum' into a natural number.\n-/\n\n\n/- Theorem : no-side-bar\nThe function `my_f` takes `10` to `35`.\n-/\ntheorem my_fun : my_f 10 = 35 :=\nbegin\n", "proof": "  refl,", "textAfter": "\nend\n\nend exlean -- hide\n", "height": 1, "editorText": "sorry", "lineOffset": 50, "name": "my_fun", "statement": "my_f 10 = 35"}, {"type": "lean", "content": "174", "hidden": true}]}], "parents": [0]}], "texts": [["Pure Mathematics with Lean", "# Pure mathematics with Lean, version 1.0.0\n\n## By Gihan Marasingha\n\nThis is an interactive book aimed at beginning mathematics undergraduates. You'll learn to prove\ntheorems online using a computer tool called Lean.\n\nEach chapter is represented by a coloured circular button in the right-hand pane. Blue indicates your\ncurrent position, green is for completed chapters, and grey is for unread or incomplete chapters.\n\nAt every stage in a theorem, there is a *target*, the thing you want to prove, and a *context*, the\nset of things you have already proved or assumed at the beginning of your argument.\nThe target and context change through the proof.\n\nThe word *goal* is used to refer variously to the target or to the combination of target and context.\n\nYou'll use *tactics* to modify the goal until you have proved the target (called 'closing the goal').\nEach tactic may invoke one or more *theorems*.\n\nNote: the book is roughly 30Mb in size. It must be downloaded before you can begin to work on the\nproblems. Once you open the book, wait for the text 'Lean is busy...' to disappear from the\ntop-right-hand pane before using Lean.\n\n*Pure mathematics with Lean* is part of the \n<a href=\"https://exlean.org\" target=\"blank\">exlean</a> project.\n\n\n## Credits\n\nThis game was made using the code base of the\n<a href=\"https://www.ma.imperial.ac.uk/~buzzard/xena/natural_number_game/\">Natural Number Game</a>\nby Kevin Buzzard and Mohammad Pedramfar.\n\n<a href=\"https://leanprover.github.io/\" target=\"blank\">Lean</a> is an interactive theorem prover developed at Microsoft Research under the direction of\nLeonardo de Moura.\n\nMathlib, Lean's mathematical library, is developed by the <a href=\"https://leanprover-community.github.io/\" target=\"blank\">Lean community</a>.\n\nHere's some mathematics in MathJax, just to remind me that it's possible.\nFirst inline: \\\\(a^2 + b^2 = c^2\\\\). Now displayed:\n\n\\\\[ \\int_{-\\infty}^\\infty  e^{-x^2} dx = \\sqrt \\pi. \\\\]\n\n", "Equations", "import myint.basic -- hide\n", "# Equations\n\n## Level 1: Proving equations through reflexivity\n\nIn the introduction, you read that tactics are used modify the goal, eventually proving \na theorem.\n\nThe `refl` tactic (short for `reflexivity`) can be used to prove any statement of the form\n`?X = ?X`. Here, I use `?X` to stand in for any expression of any type.\nIt could be `8 + 9` or `a * b` or `\"adele\"` or whatever.\n\nHere, you are asked to prove `x + y = x + y`, where `x` and `y` are integers.\nThe word `sorry` between the `begin` and `end` lines below asks Lean not to give an error message if a\nproof isn't complete. You'll see a warning message in the bottom-right hand pane. This indicates\nyou shouldn't trust the proof just yet, as it uses `sorry`!\n\nDelete `sorry` (using the backspace key on your keyboard). In the right-hand pane you'll see:\n```\nx y : \u2124\n\u22a2 x + y = x + y\n```\n\nHere, `x y : \u2124` is the *context*, the set of things you know. In this case, you know `x` and `y`\nare integers.\n\nThe *target* is `\u22a2 x + y = x + y`. The `\u22a2` symbol can be read 'to prove'. So your target is\nto prove `x + y = x + y`.\n\nThe bottom part of the right-hand pane shows an *error message*. Don't panic! It's just telling you\nthat you haven't yet proved the result.\n\nYour task is to replace `sorry` with `refl,`. Note the comma at the end of the line!\nIf you're successful, Lean will respond with the message `Proof complete!` or `no goals`.\n", "The `refl` tactic closes any goal of the form `?X = ?X`. That is, it proves any equation where the\nleft and right sides are *definitionally equal*.\n", "## Translation to a hand-written proof\n\nIn words, the `refl` says, \"The result holds by reflexivity\". A one-line written proof of\nthe theorem below would be, \"The result hold by reflexivity\".\n\n", "namespace exlean -- hide\n", "open myint -- hide\n", "open_locale mynum -- hide\n", "variables (x y : \u2124) -- Declare `x` and `y` to be integers.\n", "`x + y = x + y`, for all integers `x` and `y`.\n", "end exlean -- hide\n", "import myint.basic -- hide\n", "# Equations\n\n## Level 2: Commutativity of addition via `rw`\n\nNow we'll prove something (slighlty) more interesting, that `x + y = y + x` for all integers `x`\nand `y`. Try the `refl` tactic below (remember to put a comma after `refl`) and see what happens.\n\nYou'll get an error message:\n```\ninvalid apply tactic, failed to unify\n  x + y = y + x\nwith\n  ?m_2 = ?m_2\n```\n\nLean tells you that you're trying to use `refl` to prove `x + y = y + x`, but it expects a target\nof the form `?m_2 = ?m_2`. There's no special meaning to the underscores here. It's the same as\nwriting `?X = ?X` as in the previous level.\n\nThe problem: even though we 'know' the left and right sides are equal, they are not\n*identically equal*.\nFortunately, Lean comes with a *theorem* of just the right kind. It's called `add_comm`, which is\nshort for additive commutativity.\nThe result `add_comm a b` states that `a + b = b + a`, where `a` and `b` are integers.\n\nTo apply this theorem, we'll use the `rw` (short for `rewrite`) tactic.\n\nReplace the `sorry` below with `rw add_comm` (followed by a comma\u2014I won't mention this from now\non).\n\nLean will look for the first expression in the target that matches the pattern `a + b` and\nreplace every instance of that expression with `b + a`. Here, Lean finds `x + y` and replaces\nit with `y + x`.\n\nEqually, if `h` is an equation of the form `p = q` (where `p` and `q` are expressions),\n`rw h` will cause Lean to look for `p` in the target and replace it with `q`.\n\nHaving issued `rw add_comm`, the goal is to prove `y + x = y + x`.\nYou know how to prove a goal of this kind from the previous level.\nWrite the proof on the line after the `rw add_comm`.\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "variables (x y : \u2124) -- hide\n", "a + b = b + a\n", "theorem add_comm (a b : \u2124) : a + b = b + a := myint.add_comm' a b -- hide\n", "\nYour proof of the theorem below will use two lines of code. If you move your cursor to a previous\nline, Lean will show you the tactic state at any point in the proof. If you click on the name of\na theorem, you'll get some brief documentation.\n", "Moving through a proof", "`x + y = y + x`, for all integers `x` and `y`.\n", "end exlean -- hide\n", "## Translation to a hand-written proof\n\nIn words, the `rw add_comm` says, \"Rewrite using commuativity of addition\".\nAs hand-written proofs aren't interactive, it's helpful to mention explicitly any changes to the\ncontext. Here's a hand-written proof of the above result.\n\n> Rewriting using commutativity of addition, the goal is to prove `y + x = y + x`.\n> This follows by reflexivity.\n", "If `h` is an equation of the form `p = q`, `rw h` rewrites replaces `p` in the target with `q`.\n\nIf `k` is in the context, `rw h at k` performs the rewrite at `k` instead of at the target.\n\n`rw \u2190h` will rewrite backward: every occurrence of `q` is replaced with `p`. Type `\\l` to produce `\u2190`.\n\n`rw [h1, h2, h3]` rewrites with multiple hypotheses (you aren't limited to three)!\n", "## Anatomy of a level\n\nEach level contains three vertial panes. The left-hand pane contains a list of the tactics and\ntheorem statements you've seen so far. Click on the arrows to dig deeper.\n\nThe middle pane is the one you're reading now! It contains text and interactive exercises.\nThe right-hand pane contains the Lean Infoview window, showing the 'tactic state' and error messages.\n\nYou can navigate through the book using the buttons in the top horizonal pane. The circular arrow\nresets your progress.\n", "## How `rw` here differs from that in standard Lean\n\nThe `rw` tactic used in this book is slightly different the standard `rw`. In particular, if\nthe result of a rewrite is an equation of the form `X = X`, then the standard `rw` tactic will\nautomatically close the goal via reflexivity.\n\nThis automation has been disabled here to help you think more carefully about proof construction.\n", "import myint.basic equations.commutativity_rw -- hide\n", "# Equations\n\n## Level 3: Rewriting with hypotheses\n\nLook at the theorem below. It seems that you're being asked to prove `x + y = x + 2 * x`.\nSurely that isn't true in general! What's\ngoing on? If you look carefully, you'll see an additional hypothesis, `h : y = 2 * x`.\n\nThe `:` is just notation for naming a hypothesis (also called an assumption).\nSo the statement of the theorem can be read:\n\n> Let `x` and `y` be integers. Let `h` be the hypothesis `y = 2 * x`. Then `x + y = x + 2 * x`.\n\nWhen you start the proof, you'll note in the top-right pane that `h : y = 2 * x` has been\nadded to the context.\n\nYou can use the hypothesis to rewrite the goal by typing `rw h` much as you used `rw add_comm`\nto rewrite via the theorem `add_comm`.\n\n**Before doing the problem below**, think about what effect `rw h` will have on the goal.\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "variables (x y : \u2124) -- hide\n", "Let `x` and `y` be integers. Let `h` be the hypothesis `y = 2 * x`. Then `x + y = x + 2 * x`.\n", "end exlean -- hide\n", "## Translation to a hand-written proof\n\n> Rewriting using `h`, the goal is to prove `x + 2 * x = x + 2 * x`.\n> This follows by reflexivity.\n", "import myint.basic equations.commutativity_rw-- hide\n", "# Equations\n\n## Level 4: Focussed rewriting\n\nHere, you're asked to prove `(x + y) + z = z + (y + x)`. Clearly a case for rewriting with the\n`add_comm` theorem.\n\nThink about what `rw add_comm` will do. What will happen if you do `rw add_comm` twice? Try this\nbelow and test your conjecture.\n\nWhat happens is that `rw add_comm` looks for an expression of the form `a + b`. It finds one in\n`(x + y) + z`, matching `a` with `x + y` and `b` with `z`. It replaces this with `b + a`. That is,\nwith `z + (x + y)`.\n\nYou might wonder why this is the first match. Why doesn't Lean work on `x + y` first, matching\n`a` with `x` and `b` with `y`? It's because Lean works outside-in, then left-to-right. The second\n`+` operator in `(x + y) + z` is the outermost operator, so is read first by Lean.\n\nThe problem: applying `rw add_comm` to the new goal `\u22a2 z + (x + y) = z + (y + x)` will match `a`\nwith `z` and `b` with `x + y`, rewriting the goal to `\u22a2 (x + y) + z = z + (y + x)`, taking us back\nto where we started!\n\n### Focussing a rewrite with arguments\n\nRecall that `add_comm a b` is the theorem that `a + b = b + a`. The quantities `a` and `b` are\n*arguments* to the theorem `add_comm`.\nEqually, `add_comm x (y + z)` is the theorem that `x + (y + z) = (y + z) + x`. This theorem has\narguments `x` and `y + x`. Note than arguments can be expressions, not just variables.\n\nApplying `rw add_comm x (y + z)` transforms `\u22a2 z + (x + (y + z)) = z` to\n`\u22a2 z + ((y + z) + x) = z`.\n\nUse arguments, where necessary, to prove the theorem below.\n\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "variables (x y z : \u2124) -- Declare `x`, `y`, and `z` to be integers.\n", "\nWhen you start the proof below, Lean displays the target as `\u22a2 x + y + z = z + (y + x)`.\nWhat happened to the parentheses on the left-hand side? Lean treats addition as\n'left associative'. This is a fancy way of saying that `x + y + z` should always be\ninterpreted as `(x + y) + z`.\n", "Missing parentheses?", "Let `x`, `y`, and `z` be integers. Then `(x + y) + z = z + (y + x)`.\n", "end exlean -- hide\n", "## Translation to a hand-written proof\n\nHere's a suggestion. When writing a proof by hand, you need not (and should not) aim at a direct\ntranslation of a Lean proof. Here, I've kept the main idea of each line of my Lean proof while\ntranslating for ease of human understanding.\n\n> Rewriting by additive commutativity, the goal is to prove `z + (x + y) = z + (y + x)`.\n> Rewriting with additive commutativity on `x + y`, the goal is to prove `z + (y + x) = z + (y + x)`.\n> This follows by reflexivity.\n", "import myint.basic equations.commutativity_rw -- hide\n", "# Equations\n\n## Level 5: Associativity\n\nTime for a new theorem. This one is called `add_assoc`, which is short for additive associativity.\n\nThe result `add_assoc a b c` states that `(a + b) + c = a + (b + c)`, for all integers `a`, `b`,\nand `c`. You can see the statement in the sidebar on the left by unfolding 'Theorem statements'.\n\nAs with `add_comm`, you can use `add_assoc` to rewrite the goal using `rw add_assoc`.\n\nBelow, your task is to prove `(x + y) + z = x + (z + y)`. In future levels, this theorem will\nbe available as `add_right_comm`.\n\n**Before writing a Lean proof**, construct a hand-written proof.\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "(a + b) + c = a + (b + c)\n", "theorem myint.add_assoc (a b c : \u2124) : a + b + c = a + (b + c) := myint.add_assoc' a b c -- hide\n", "open myint\n", "\nYou'll need to rewrite with both `add_comm` and `add_assoc`. You may need to give arguments to one\nof your rewrites, as described in the previous level.\n", "Hint", "Let `x`, `y`, and `z` be integers. Then `(x + y) + z = x + (z + y)`.\n", "## Translation to a hand-written proof\n\nIn the following hand-written proof, I omit the word 'rewriting'.\n\n> By associativity, the goal is to prove `x + (y + z) = x + (z + y)`.\n> By commutativity, the goal is to prove `x + (z + y) = x + (z + y)`.\n> This follows by reflexivity.\n", "end exlean -- hide", "import myint.basic equations.associativity -- hide\n", "# Equations\n\n## Level 6: Structuring proofs with `have`\n\nThe `have` tactic introduces a hypothesis into the context. It's a way to add structure to your\nproofs, stating and proving intermediate results before using them.\n\nConsider the goal `\u22a2 x + ((x + y) + z) = x + (z + (x + y))`.\n\nOne way to close this goal is to rewrite, giving specific arguments to `add_comm`.\nAnother option is to introduce an intermediate goal of proving `(x + y) + z = z + (x + y)`.\n\nThis is accomplished using `have h : (x + y) + z = z + (x + y)` (followed by a comma). \nThere's nothing special about `h` as the name of the hypothesis. Change it to whatever you wish.\n\nThis opens up a new goal: you'll see 2 goals in right-hand pane. The top goal is the new goal,\nnamely `\u22a2 (x + y) + z = z + (x + y)`. The bottom goal is the old goal, only with a new hypothesis,\n`h : (x + y) + z = z + (x + y)`.\n\nYou first work on closing the new goal, then close the original goal using hypothesis `h`.\n", "\nIf you want to work only on goal, put braces after the `have`. When you're cursor is in the\ninner brace, you'll only be working on the first goal.\n```\nhave h : (x + y) + z = z + (x + y),\n{ sorry },\nsorry\n``` \n", "Focussing on one goal at a time", "`have` is used to introduce a new hypothesis into the context. It opens a new goal for the proof\nof the hypothesis.\n\nFor example, `have h2 : x + y = y + x` introduces a new goal, to prove\n`x + y = y + x` while adding the hypothesis `h2 : x + y = y + x` to the context of the old goal.\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "open myint -- hide\n", "variables (x y z : \u2124) -- hide\n", "Let `x`, `y`, and `z` be integers. Then `x + ((x + y) + z) = x + (z + (x + y)))`.\n", "## Translation to a hand-written proof\n\nIn my hand-written proof below, I omit references to reflexivity.\n\n> I claim `h : (x + y) + z = z + (x + y)`.\n> To prove this, use commutativity of addition.\n> Rewrite the original goal using `h`.\n", "end exlean -- hide", "import myint.basic equations.associativity -- hide\n", "# Equations\n\n## Level 7: Multiple rewrites\n\nRather than writing, for example `rw add_assoc x y z, rw add_comm`, you can write\n`rw [add_assoc x y z, add_comm]`. Use this technique, together with `have`, to write a structured\nproof below.\n\nNow write a proof using a long chain of rewrites followed by `refl`. Which proof do you prefer? Why?\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "open myint -- hide\n", "variables (x y z : \u2124) -- hide\n", "Let `x`, `y`, and `z` be integers. Then `x + (y + (x + z)) = (z + (x + y)) + x`.\n", "end exlean -- hide", "import myint.basic equations.multiple_rewrites -- hide\n", "# Equations\n\n## Level 8: Backward rewrites\n\nSuppose you wanted to prove `y + x = 0` on the assumptions `h1 : x + 0 = 0` and `h2 : y = 0`.\nOne option would be to rewrite with `h2` to give `\u22a2 0 + x = 0`. You could then finish by\nrewriting with `add_comm` and `h1`.\n\nAnother option is to start by rewriting with `h1` *backward*. This would replace `0`\nin the target with `x + 0`. To do this in Lean, type `rw \u2190h1`.\n\nTo get the left arrow, type `\\l` followed by space or tab. Alternatively, just type `<-`\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "open myint -- hide\n", "variables (x y z : \u2124) -- hide\n", "Here is a proof of this result, using three rewrites, one backward.\n", "example (h1 : x + 0 = 0) (h2 : y = 0) : y + x = 0 :=\nbegin\n", "  [pure_maths] -- hide\n", "  rw [\u2190h1, add_comm, h2],\n  refl,\n", "-- hide  \n", "end\n", "Your turn! Prove the following using two rewrites, one backward.\n\nOnce you've done that, write a structured proof of the same result.\n", "\nIntroduce and prove the hypotheses `h2 : y + z * x = (z + x) + y` and\n`h3 : (z + x) + y = y + (z + x)` using the `have` tactic. Finish by rewriting with these\nhypotheses.\n", "Hint for structured proof", "Let `x`, `y`, and `z` be integers. If `(z + x) + y = y + z * x`, then `y + z * x = y + (z + x)`\n", "end exlean -- hide", "import myint.basic equations.backward_rewrite -- hide\n", "# Equations\n\n## Level 9: Additive identity\n\nThe Lean theorem `add_zero` states that `x + 0 = x` for every integer `x`. In mathematics, this\nproperty is called (right) additive identity. Note `add_zero` should appear as a 'Theorem statement'\nin the left-hand pane. \n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "open myint -- hide\n", "a + 0 = a\n", "theorem add_zero (a : \u2124) : a + 0 = a := myint.add_zero' a -- hide\n", "Your goal is to prove `zero_add`, the right additive identity property, using `add_zero`.\nOnce you've done this, `zero_add` will be available to you in future levels.\n\nAs always, construct a hand-written proof **before** writing your Lean proof.\n", "`0 + a = a` for every integer `a`.\n", "end exlean -- hide", "import myint.basic equations.additive_identity -- hide\n", "# Equations\n\n## Level 10: Universal statements\n\nSo far, our hypotheses have made reference to specific variables. The hypothesis `h : x + 3 = 5`\nstates `x + 3 = 5` for the particular variable `x`.\n\nIf we want a statement that holds *for every* value of a variable, we use the *universal quantifier*\n`\u2200`. This is read, \"for all\" or \"for every\" and is typed `\\all`.\n\nFor example, `\u2200 (x : \u2124), x + 5 = 10` states that `x + 5 = 10` *for every* integer `x`. Of course,\nthis is a false statement! A statement that begins with `\u2200` is called a\n*universally quantified statement*.\n\nHere's how to *use* a universally quantified statement. Given the hypothesis\n`h : \u2200 (x : \u2124), x + 5 = 10`, the expression `h 3` corresponds to `3 + 5 = 10`.\nIt's what we get by replacing `x` with `3` in the body of the statement.\n\nIf `3 + 5` appears in the target, then `rw h 3` replaces `3 + 5` with `10`.\n\n### The specialize tactic\n\nThe `specialize` tactic specializes a universally quantified statement. For example if\n`h : \u2200 (x : \u2124), x + 5 = 10`, then `specialize h 20` *replaces* `h` with\n`h : 20 + 5 = 10`. However, after using `specialize`, you can't go back to the more general\nversion of `h`.\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "open myint -- hide\n", "variable (x : \u2124) -- hide\n", "Here, you'll prove the unusual result `2 + 5 = 8 + 5` on the assumption `\u2200 x, x + 5 = 10`.\n\nWrite a proof using `rw`.\n\nWrite another proof where you use one `rw` and one application of `specialize`.\n\nThink about how you'd write this proof by hand. Compare with my suggested translation at the bottom\nof the page.\n", "Let the hypothesis `h` be a universally-quantified statement. For example,\n`h : \u2200 (x : \u2124), x + 5 = 10`.\nThen `specialize h 8` replaces `x` with `8` in the body of `h`. Thus `h` becomes `8 + 5 = 10`.\n\nYou can specialize on more than one variable at a time. If `k : \u2200 (x y : \u2124), x + y = y * x`, then\n`specialize k 2 3` replaces `h` with `h : 2 + 3 = 3 * 2`.\n", "`2 + 5 = 8 + 5` on the assumption `\u2200 x, x + 5 = 10`.\n", "## Translation to a hand-written proof\n\n> Using `h` with `2` in space of `x`, we must show `10 = 8 + 5`.\n> But this follows on taking `x` to be `8` in `h`.\n", "end exlean -- hide", "import myint.basic equations.additive_identity -- hide\n", "# Equations\n\n## Level 11: Uniqueness of additive identity\n\nIn a previous level, we saw that there's an integer `0` with the properties that\n`x + 0 = x` for every `x`.\n\nIn this level, you'll show that `0` is the *only* integer that satisfies this property.\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "open myint -- hide\n", "Use the `specialize` tactic.\n", "Hint", "Let `e` be an integer satsifying the property `\u2200 (x : \u2124), x + e = x`. Then `e` must be `0`.\n", "end exlean -- hide", "import myint.basic equations.unique_additive_identity -- hide\n", "# Equations\n\n## Level 12: Additive inverse\n\nThe Lean theorem `add_left_neg` states that `(-a) + a = 0` for every integer `a`. In mathematics,\nthis property is called (left) additive inverse.\n\nLikewise `add_right_neg (a : \u2124) : a + (-a) = 0`.\n\nYou'll use one of these properties in proving the next result.\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "open myint -- hide\n", "(-a) + a = 0\n", "theorem add_left_neg (a : \u2124) : (-a) + a = 0  := myint.add_left_neg a -- hide\n", "(-a) + a = 0\n", "theorem add_right_neg (a : \u2124) : a + (-a) = 0  := myint.add_right_neg a -- hide\n", "You might find it useful to use the previously-proved theorem `add_right_comm`.\n", "Hint", "For all integers `x` and `y`, we have `(x + y) + -x = y`.\n", "end exlean -- hide", "import myint.basic equations.additive_inverse -- hide\n", "# Equations\n\n## Level 13: Cancellation I\n\nRecall the (right) uniqueness of additive identity. Let `y` be an integer. If for every integer `x`,\nwe have `x + y = x`, then `y = 0`.\n\nIn this level, we'll prove a theorem that is subtly different. Let `y` and `x` be integers. If\n`x + y = x`, then `y = 0`.\n\n**Question**: how does this new statement differ from from the uniqueness of additive identity?\n\nThe new result cannot be proved using only additive identity. You'll need to use the\nadditive inverse property.\n\nThis may be the most challenging level so far.\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "open myint -- hide\n", "Use `add_add_neg`.\n", "Hint", "If `a + b = a`, then `b = 0`.\n", "end exlean -- hide", "import myint.basic equations.cancellation_i -- hide\n", "# Equations\n\n## Level 14: Uniqueness of additive inverse\n\nWe've seen the uniqueness of (right) additive identity. Now we'll show the uniqueness of (right)\nadditive inverse.\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "open myint -- hide\n", "Use `add_add_neg`.\n", "Hint", "Let `x` and `y` be integers. If `x + y = 0`, then `y = -x`. \n", "end exlean -- hide", "import myint.basic equations.unique_additive_inverse -- hide\n", "# Equations\n\n## Level 15: The simplifier\n\nThis level introduces a powerful new tactic, `simp`, Lean's simplifier. It rewrites \nrepeatedly using either supplied theorems & hypotheses or theorems that it 'knows'.\n\nTo suggest theorems and hypotheses for use with `simp`, provide them as a comma-separated list.\nIn the example below, we supply `simp` with `add_assoc` and `add_comm y x`.\n\nWithout `simp`, you'd need several applications of `rw add_assoc`. \n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "open myint -- hide\n", "example (x y z : \u2124) : x + ((y + z) + x) = (y + x) + (z + x) :=\nbegin\n  simp [add_assoc, add_comm y x],\nend\n", "Prove the result below using only `simp` with supplied theorems, as in the example above. You should\nonly need to supply four theorems.\n\nFor fun (!) try proving this result using `rw`. Which proof do you prefer?\n", "Let `x`, `y`, and `z` be integers. Then `(y + x) + (0 + z + 0) + (0 + x + 0) = y + (z + (x + x))`\n", "end exlean -- hide", "Functions", "import mynat.basic -- hide\n", "# Functions\n\n## Level 1: Defining functions\n\nA function is a map from one set, called the domain, to another set, called the codomain.\n\nThe notation `f : S \u2192 T` is read, \"`f` is a function with domain `S` and codomain `T`\" or \"`f` is a\nfunction from `S` to `T`\".\n\nTo specify that `f` maps each `x` to some expression `y`, we write `f : x \u21a6 y` or\n`f(x) = y`, when doing mathematics by hand.\n\nIn Lean, we combine all the above information into:\n```\ndef f : S \u2192 T := \u03bb x, y\n```\nwhere `y` is an expression that depends on `x`. Here `\u03bb` is a Greek letter called lambda.\nIts only significance is to indicate that the following quantity `x` is a variable.\n\nBelow is the definition of a function `my_f` from the set `\u2115` of natural numbers (the non-negative)\nintegers to itself. It takes each `x` to `3 * x + 5`.\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "The function `my_f` is defined so that `my_f (x) = 3 * x + 5` for every \nnatural number `x`.\n", "def my_f : \u2115 \u2192 \u2115 := \u03bb x, 3 * x + 5\n", "Your task is to prove `my_f 10 = 35`. By definition of `my_f`, you must prove `3 * 10 + 5 = 35`.\nIt may come as a surprise to learn that Lean can prove this using `refl`.\nThe reason is that when Lean uses `refl`, it applies definitions until no further simplification is\npossible. For reasons that will become apparent later, the definitions of addition and\nmultiplication can be applied to reduce any 'sum' into a natural number.\n", "The function `my_f` takes `10` to `35`.\n", "end exlean -- hide\n"]]}
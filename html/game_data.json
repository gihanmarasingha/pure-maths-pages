{"name": "Pure Mathematics with Lean", "version": "1.0.0", "languages": ["en"], "translated_name": "0", "devmode": false, "library_zip_fn": "Pure Mathematics with Lean-1.0.0-library.zip", "introData": {"name": "", "problemIndex": -1, "objects": [{"type": "text", "content": "1"}]}, "worlds": [{"name": "2", "levels": [{"name": "", "problemIndex": 8, "objects": [{"type": "lean", "content": "3", "hidden": true}, {"type": "text", "content": "4"}, {"type": "tactic", "content": "5", "name": "refl", "sideBar": true}, {"type": "text", "content": "6"}, {"type": "lean", "content": "7", "hidden": true}, {"type": "lean", "content": "8", "hidden": true}, {"type": "lean", "content": "9", "hidden": true}, {"type": "lean", "content": "10", "hidden": false}, {"type": "theorem", "text": "11", "lean": "theorem x_plus_y_eq_x_plus_y : x + y = x + y :=\n", "sideBar": false, "firstProofLineNumber": 65, "lastProofLineNumber": 65, "textBefore": "import myint.basic -- hide\n\n/-\n# Equations\n\n## Level 1: Proving equations through reflexivity\n\nIn the introduction, you read that tactics are used modify the goal, eventually proving \na theorem.\n\nThe `refl` tactic (short for `reflexivity`) can be used to prove any statement of the form\n`?X = ?X`. Here, I use `?X` to stand in for any expression of any type.\nIt could be `8 + 9` or `a * b` or `\"adele\"` or whatever.\n\nHere, you are asked to prove `x + y = x + y`, where `x` and `y` are integers.\nThe word `sorry` between the `begin` and `end` lines below asks Lean not to give an error message if a\nproof isn't complete. You'll see a warning message in the bottom-right hand pane. This indicates\nyou shouldn't trust the proof just yet, as it uses `sorry`!\n\nDelete `sorry` (using the backspace key on your keyboard). In the right-hand pane you'll see:\n```\nx y : \u2124\n\u22a2 x + y = x + y\n```\n\nHere, `x y : \u2124` is the *context*, the set of things you know. In this case, you know `x` and `y`\nare integers.\n\nThe *target* is `\u22a2 x + y = x + y`. The `\u22a2` symbol can be read 'to prove'. So your target is\nto prove `x + y = x + y`.\n\nThe bottom part of the right-hand pane shows an *error message*. Don't panic! It's just telling you\nthat you haven't yet proved the result.\n\nYour task is to replace `sorry` with `refl,`. Note the comma at the end of the line!\nIf you're successful, Lean will respond with the message `Proof complete!` or `no goals`.\n-/\n\n/- Tactic : refl\nThe `refl` tactic closes any goal of the form `?X = ?X`. That is, it proves any equation where the\nleft and right sides are *definitionally equal*.\n-/\n\n/-\n## Translation to a hand-written proof\n\nIn words, the `refl` says, \"The result holds by reflexivity\". A one-line written proof of\nthe theorem below would be, \"The result hold by reflexivity\".\n\n-/\n\nnamespace exlean -- hide\n\nopen myint -- hide\n\nopen_locale mynum -- hide\n\nvariables (x y : \u2124) -- Declare `x` and `y` to be integers.\n\n/- Theorem : no-side-bar\n`x + y = x + y`, for all integers `x` and `y`.\n-/\ntheorem x_plus_y_eq_x_plus_y : x + y = x + y :=\nbegin\n", "proof": "  refl,", "textAfter": "\nend\n\nend exlean -- hide\n", "height": 1, "editorText": "sorry", "lineOffset": 64, "name": "x_plus_y_eq_x_plus_y", "statement": "x + y = x + y"}, {"type": "lean", "content": "12", "hidden": true}]}, {"name": "", "problemIndex": 8, "objects": [{"type": "lean", "content": "13", "hidden": true}, {"type": "lean", "content": "14", "hidden": true}, {"type": "lean", "content": "15", "hidden": true}, {"type": "text", "content": "16"}, {"type": "lean", "content": "17", "hidden": true}, {"type": "lean", "content": "18", "hidden": false}, {"type": "axiom", "content": "19", "name": "`add_comm`", "sideBar": true}, {"type": "lean", "content": "20", "hidden": false}, {"type": "theorem", "text": "21", "lean": "theorem x_plus_y_eq_y_plus_x : x + y = y + x :=\n", "sideBar": false, "firstProofLineNumber": 62, "lastProofLineNumber": 63, "textBefore": "import tactic.structure_helper tactic.pure_maths -- hide\n\nimport myint.basic -- hide\n\nopen_locale mynum -- hide\n\n/-\n# Equations\n\n## Level 2: Commutativity of addition\n\nNow we'll prove something (slighlty) more interesting, that `x + y = y + x` for all integers `x`\nand `y`. Try the `refl` tactic below (remember to put a comma after `refl`) and see what happens.\n\nYou'll get an error message:\n```\ninvalid apply tactic, failed to unify\n  x + y = y + x\nwith\n  ?m_2 = ?m_2\n```\n\nLean tells you that you're trying to use `refl` to prove `x + y = y + x`, but it expects a target\nof the form `?m_2 = ?m_2`. There's no special meaning to the underscores here. It's the same as\nwriting `?X = ?X` as in the previous level.\n\nThe problem: even though we 'know' the left and right sides are equal, they are not\n*identically equal*.\nFortunately, Lean comes with a *theorem* of just the right kind. It's called `add_comm`.\nThe result `add_comm a b` states that `a + b = b + a`, where `a` and `b` are integers.\n\nTo apply this theorem, we'll use the `rw` (short for `rewrite`) tactic.\n\nReplace the `sorry` below with `rw add_comm` (followed by a comma\u2014I won't mention this from now\non).\n\nLean will look for the first expression in the target that matches the pattern `a + b` and\nreplace it with `b + a`. Here, Lean finds `x + y` and replaces it with `y + x`.\n\nMore generally, if `h` is an equation of the form `p = q` (where `p` and `q` are expressions),\n`rw h` will cause Lean to look for `p` in the target and replace it with `q`.\n\nHaving issued `rw add_comm`, the goal is to prove `y + x = y + x`.\nYou know how to prove a goal of this kind from the previous level.\nWrite the proof on the line after the `rw add_comm`.\n-/\n\nnamespace exlean -- hide\n\nvariables (x y : \u2124) -- Declare `x` and `y` to be integers.\n\n/- Axiom : `add_comm`\n`a + b = b + a`, for all integers `a` and `b`.\n-/\ntheorem add_comm (a b : \u2124) : a + b = b + a := myint.add_comm' a b\n\n/- Theorem : no-side-bar\n`x + y = y + x`, for all integers `x` and `y`.\n-/\ntheorem x_plus_y_eq_y_plus_x : x + y = y + x :=\nbegin [pure_maths]\n", "proof": "  rw add_comm,\n  refl,", "textAfter": "\nend\n\nend exlean -- hide\n\n/-\n## Translation to a hand-written proof\n\nIn words, the `rw add_comm` says, \"Rewrite using commuativity of addition\".\nAs hand-written proofs aren't interactive, it's helpful to mention explicitly any changes to the\ncontext. Here's a hand-written proof of the above result.\n\n> Rewriting using commutativity of addition, the goal is to prove `y + x = y + x`.\n> This follows by reflexivity.\n-/\n\n/- Tactic : rw\nIf `h` is an equation of the form `p = q`, `rw h` rewrites replaces `p` in the target with `q`.\n\nIf `k` is in the context, `rw h at k` performs the rewrite at `k` instead of at the target.\n-/\n\n\n/-\n## Anatomy of a level\n\nEach level contains three vertial panes. The left-hand pane contains a list of the tactics and\ntheorem statements you've seen so far. Click on the arrows to dig deeper.\n\nThe middle pane is the one you're reading now! It contains text and interactive exercises.\nThe right-hand pane contains the Lean Infoview window, showing the goal state and error messages.\n\nYou can navigate through the book using the buttons in the top horizonal pane. The circular arrow\nresets your progress.\n-/\n\n/-\n## How `rw` here differs from that in standard Lean\n\nThe `rw` tactic used in this book is slightly different the standard `rw`. In particular, if\nthe result of a rewrite is an equation of the form `X = X`, then the standard `rw` tactic will\nautomatically close the goal via reflexivity.\n\nThis automation has been disabled here to help you think more carefully about proof construction.\n-/\n\n", "height": 2, "editorText": "sorry", "lineOffset": 61, "name": "x_plus_y_eq_y_plus_x", "statement": "x + y = y + x"}, {"type": "lean", "content": "22", "hidden": true}, {"type": "text", "content": "23"}, {"type": "tactic", "content": "24", "name": "rw", "sideBar": true}, {"type": "text", "content": "25"}, {"type": "text", "content": "26"}]}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "27", "hidden": true}, {"type": "lean", "content": "28", "hidden": true}, {"type": "lean", "content": "29", "hidden": true}, {"type": "text", "content": "30"}, {"type": "lean", "content": "31", "hidden": true}, {"type": "lean", "content": "32", "hidden": false}, {"type": "theorem", "text": "33", "lean": "theorem rw_using_h (h : y = 2 * x) : x + y = x + 2 * x :=\n", "sideBar": false, "firstProofLineNumber": 39, "lastProofLineNumber": 40, "textBefore": "import tactic.structure_helper tactic.pure_maths -- hide\n\nimport myint.basic equations.commutativity_rw.level -- hide\n\nopen_locale mynum -- hide\n\n/-\n# Equations\n\n## Level 3: Rewriting with hypotheses\n\nLook at the theorem below. It seems that you're being asked to prove `x + y = x + 2 * x`.\nSurely that isn't true in general! What's\ngoing on? If you look carefully, you'll see an additional hypothesis, `h : y = 2 * x`.\n\nThe `:` is just notation for naming a hypothesis (also called an assumption).\nSo the statement of the theorem can be read:\n\n> Let `x` and `y` be integers. Let `h` be the hypothesis `y = 2 * x`. Then `x + y = x + 2 * x`.\n\nWhen you start the proof, you'll note in the top-right pane that `h : y = 2 * x` has been\nadded to the context.\n\nYou can use the hypothesis to rewrite the goal by typing `rw h` much as you used `rw add_comm`\nto rewrite via the theorem `add_comm`.\n\n**Before doing the problem below**, think about what effect `rw h` will have on the goal.\n-/\n\nnamespace exlean -- hide\n\nvariables (x y : \u2124) -- Declare `x` and `y` to be integers.\n\n/- Theorem : no-side-bar\nLet `x` and `y` be integers. Let `h` be the hypothesis `y = 2 * x`. Then `x + y = x + 2 * x`.\n-/\ntheorem rw_using_h (h : y = 2 * x) : x + y = x + 2 * x :=\nbegin [pure_maths]\n", "proof": "  rw h,\n  refl,", "textAfter": "\nend\n\nend exlean -- hide\n\n/-\n## Translation to a hand-written proof\n\n> Rewriting using `h`, the goal is to prove `x + 2 * x = x + 2 * x`.\n> This follows by reflexivity.\n-/\n\n", "height": 2, "editorText": "sorry", "lineOffset": 38, "name": "rw_using_h", "statement": "(h : y = 2 * x) : x + y = x + 2 * x"}, {"type": "lean", "content": "34", "hidden": true}, {"type": "text", "content": "35"}]}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "36", "hidden": true}, {"type": "lean", "content": "37", "hidden": true}, {"type": "lean", "content": "38", "hidden": true}, {"type": "text", "content": "39"}, {"type": "lean", "content": "40", "hidden": true}, {"type": "lean", "content": "41", "hidden": false}, {"type": "theorem", "text": "42", "lean": "theorem add_comm_left_right : (x + y) + z = z + (y + x) :=\n", "sideBar": false, "firstProofLineNumber": 53, "lastProofLineNumber": 55, "textBefore": "import tactic.structure_helper tactic.pure_maths -- hide\n\nimport myint.basic equations.commutativity_rw.level -- hide\n\nopen_locale mynum -- hide\n\n/-\n# Equations\n\n## Level 4: Focussed rewriting\n\nHere, you're asked to prove `(x + y) + z = z + (y + x)`. Clearly a case for rewriting with the\n`add_comm` theorem.\n\nThink about what `rw add_comm` will do. What will happen if you do `rw add_comm` twice? Try this\nbelow and test your conjecture.\n\nWhat happens is that `rw add_comm` looks for an expression of the form `a + b`. It finds one in\n`(x + y) + z`, matching `a` with `x + y` and `b` with `z`. It replaces this with `b + a`. That is,\nwith `z + (x + y)`.\n\nYou might wonder why this is the first match. Why doesn't Lean work on `x + y` first, matching\n`a` with `x` and `b` with `y`? It's because Lean works outside-in, then left-to-right. The second\n`+` operator in `(x + y) + z` is the outermost operator, so is read first by Lean.\n\nThe problem: applying `rw add_comm` to the new goal `\u22a2 z + (x + y) = z + (y + x)` will match `a`\nwith `z` and `b` with `x + y`, rewriting the goal to `\u22a2 (x + y) + z = z + (y + x)`, taking us back\nto where we started!\n\n### Focussing a rewrite with arguments\n\nRecall that `add_comm a b` is the theorem that `a + b = b + a`. The quantities `a` and `b` are\n*arguments* to the theorem `add_comm`.\nEqually, `add_comm x (y + z)` is the theorem that `x + (y + z) = (y + z) + x`. This theorem has\narguments `x` and `y + x`. Note than arguments can be expressions, not just variables.\n\nApplying `rw add_comm x (y + z)` transforms `\u22a2 z + (x + (y + z)) = z` to\n`\u22a2 z + ((y + z) + x) = z`.\n\nUse arguments, where necessary, to prove the theorem below.\n\n-/\n\nnamespace exlean -- hide\n\nvariables (x y z : \u2124) -- Declare `x`, `y`, and `z` to be integers.\n\n/- Theorem : no-side-bar\nLet `x`, `y`, and `z` be integers. Then `(x + y) + z = z + (y + x)`.\n-/\ntheorem add_comm_left_right : (x + y) + z = z + (y + x) :=\nbegin [pure_maths]\n", "proof": "  rw add_comm,\n  rw add_comm x y,\n  refl,", "textAfter": "\nend\n\nend exlean -- hide\n\n/-\n## Translation to a hand-written proof\n\nHere's a suggestion. When writing a proof by hand, you need not (and should not) aim at a direct\ntranslation of a Lean proof. Here, I've kept the main idea of each line of my Lean proof while\ntranslating for ease of human understanding.\n\n> Rewriting by additive commutativity, the goal is to prove `z + (x + y) = z + (y + x)`.\n> Rewriting with additive commutativity on `x + y`, the goal is to prove `z + (y + x) = z + (y + x)`.\n> This follows by reflexivity.\n-/\n\n", "height": 3, "editorText": "sorry", "lineOffset": 52, "name": "add_comm_left_right", "statement": "(x + y) + z = z + (y + x)"}, {"type": "lean", "content": "43", "hidden": true}, {"type": "text", "content": "44"}]}]}, {"name": "45", "levels": [{"name": "", "problemIndex": -1, "objects": [{"type": "lean", "content": "46", "hidden": false}, {"type": "text", "content": "47"}, {"type": "lean", "content": "48", "hidden": true}, {"type": "text", "content": "49"}, {"type": "lean", "content": "50", "hidden": false}, {"type": "lean", "content": "51", "hidden": true}]}], "parents": [0]}], "texts": [["Pure Mathematics with Lean", "# Pure mathematics with Lean, version 1.0.0\n\n## By Gihan Marasingha\n\nThis is an interactive book aimed at beginning mathematics undergraduates. You'll learn to prove\ntheorems online using a computer tool called Lean.\n\nEach chapter is indicated by a coloured circular button on the right-hand pane. Blue indicates your\ncurrent position, green is for completed chapters, and grey is for unread or uncompleted chapters.\n\nAt every stage in a theorem, there is a *target*, the thing you want to prove, and a *context*, the\nset of things you have already proved or assumed at the beginning of your argument.\nThe target and context change through the proof.\n\nThe word *goal* is used to refer variously to the target or to the combination of target and context.\n\nYou'll use *tactics* to modify the goal until you have proved the target (called 'closing the goal').\nEach tactic may invoke one or more *theorems*.\n\n\n## Credits\n\nThis game was made using the code base of the\n<a href=\"https://www.ma.imperial.ac.uk/~buzzard/xena/natural_number_game/\">Natural Number Game</a>\nby Kevin Buzzard and Mohammad Pedramfar.\n\n<a href=\"https://leanprover.github.io/\" target=\"blank\">Lean</a> is an interactive theorem prover developed at Microsoft Research under the direction of\nLeonardo de Moura.\n\nMathlib, Lean's mathematical library, is developed by the <a href=\"https://leanprover-community.github.io/\" target=\"blank\">Lean community</a>.\n\n*Pure mathematics with Lean* is part of the \n<a href=\"https://exlean.org\" target=\"blank\">exlean</a> project.\n", "Equations", "import myint.basic -- hide\n", "# Equations\n\n## Level 1: Proving equations through reflexivity\n\nIn the introduction, you read that tactics are used modify the goal, eventually proving \na theorem.\n\nThe `refl` tactic (short for `reflexivity`) can be used to prove any statement of the form\n`?X = ?X`. Here, I use `?X` to stand in for any expression of any type.\nIt could be `8 + 9` or `a * b` or `\"adele\"` or whatever.\n\nHere, you are asked to prove `x + y = x + y`, where `x` and `y` are integers.\nThe word `sorry` between the `begin` and `end` lines below asks Lean not to give an error message if a\nproof isn't complete. You'll see a warning message in the bottom-right hand pane. This indicates\nyou shouldn't trust the proof just yet, as it uses `sorry`!\n\nDelete `sorry` (using the backspace key on your keyboard). In the right-hand pane you'll see:\n```\nx y : \u2124\n\u22a2 x + y = x + y\n```\n\nHere, `x y : \u2124` is the *context*, the set of things you know. In this case, you know `x` and `y`\nare integers.\n\nThe *target* is `\u22a2 x + y = x + y`. The `\u22a2` symbol can be read 'to prove'. So your target is\nto prove `x + y = x + y`.\n\nThe bottom part of the right-hand pane shows an *error message*. Don't panic! It's just telling you\nthat you haven't yet proved the result.\n\nYour task is to replace `sorry` with `refl,`. Note the comma at the end of the line!\nIf you're successful, Lean will respond with the message `Proof complete!` or `no goals`.\n", "The `refl` tactic closes any goal of the form `?X = ?X`. That is, it proves any equation where the\nleft and right sides are *definitionally equal*.\n", "## Translation to a hand-written proof\n\nIn words, the `refl` says, \"The result holds by reflexivity\". A one-line written proof of\nthe theorem below would be, \"The result hold by reflexivity\".\n\n", "namespace exlean -- hide\n", "open myint -- hide\n", "open_locale mynum -- hide\n", "variables (x y : \u2124) -- Declare `x` and `y` to be integers.\n", "`x + y = x + y`, for all integers `x` and `y`.\n", "end exlean -- hide\n", "import tactic.structure_helper tactic.pure_maths -- hide\n", "import myint.basic -- hide\n", "open_locale mynum -- hide\n", "# Equations\n\n## Level 2: Commutativity of addition\n\nNow we'll prove something (slighlty) more interesting, that `x + y = y + x` for all integers `x`\nand `y`. Try the `refl` tactic below (remember to put a comma after `refl`) and see what happens.\n\nYou'll get an error message:\n```\ninvalid apply tactic, failed to unify\n  x + y = y + x\nwith\n  ?m_2 = ?m_2\n```\n\nLean tells you that you're trying to use `refl` to prove `x + y = y + x`, but it expects a target\nof the form `?m_2 = ?m_2`. There's no special meaning to the underscores here. It's the same as\nwriting `?X = ?X` as in the previous level.\n\nThe problem: even though we 'know' the left and right sides are equal, they are not\n*identically equal*.\nFortunately, Lean comes with a *theorem* of just the right kind. It's called `add_comm`.\nThe result `add_comm a b` states that `a + b = b + a`, where `a` and `b` are integers.\n\nTo apply this theorem, we'll use the `rw` (short for `rewrite`) tactic.\n\nReplace the `sorry` below with `rw add_comm` (followed by a comma\u2014I won't mention this from now\non).\n\nLean will look for the first expression in the target that matches the pattern `a + b` and\nreplace it with `b + a`. Here, Lean finds `x + y` and replaces it with `y + x`.\n\nMore generally, if `h` is an equation of the form `p = q` (where `p` and `q` are expressions),\n`rw h` will cause Lean to look for `p` in the target and replace it with `q`.\n\nHaving issued `rw add_comm`, the goal is to prove `y + x = y + x`.\nYou know how to prove a goal of this kind from the previous level.\nWrite the proof on the line after the `rw add_comm`.\n", "namespace exlean -- hide\n", "variables (x y : \u2124) -- Declare `x` and `y` to be integers.\n", "`a + b = b + a`, for all integers `a` and `b`.\n", "theorem add_comm (a b : \u2124) : a + b = b + a := myint.add_comm' a b\n", "`x + y = y + x`, for all integers `x` and `y`.\n", "end exlean -- hide\n", "## Translation to a hand-written proof\n\nIn words, the `rw add_comm` says, \"Rewrite using commuativity of addition\".\nAs hand-written proofs aren't interactive, it's helpful to mention explicitly any changes to the\ncontext. Here's a hand-written proof of the above result.\n\n> Rewriting using commutativity of addition, the goal is to prove `y + x = y + x`.\n> This follows by reflexivity.\n", "If `h` is an equation of the form `p = q`, `rw h` rewrites replaces `p` in the target with `q`.\n\nIf `k` is in the context, `rw h at k` performs the rewrite at `k` instead of at the target.\n", "## Anatomy of a level\n\nEach level contains three vertial panes. The left-hand pane contains a list of the tactics and\ntheorem statements you've seen so far. Click on the arrows to dig deeper.\n\nThe middle pane is the one you're reading now! It contains text and interactive exercises.\nThe right-hand pane contains the Lean Infoview window, showing the goal state and error messages.\n\nYou can navigate through the book using the buttons in the top horizonal pane. The circular arrow\nresets your progress.\n", "## How `rw` here differs from that in standard Lean\n\nThe `rw` tactic used in this book is slightly different the standard `rw`. In particular, if\nthe result of a rewrite is an equation of the form `X = X`, then the standard `rw` tactic will\nautomatically close the goal via reflexivity.\n\nThis automation has been disabled here to help you think more carefully about proof construction.\n", "import tactic.structure_helper tactic.pure_maths -- hide\n", "import myint.basic equations.commutativity_rw.level -- hide\n", "open_locale mynum -- hide\n", "# Equations\n\n## Level 3: Rewriting with hypotheses\n\nLook at the theorem below. It seems that you're being asked to prove `x + y = x + 2 * x`.\nSurely that isn't true in general! What's\ngoing on? If you look carefully, you'll see an additional hypothesis, `h : y = 2 * x`.\n\nThe `:` is just notation for naming a hypothesis (also called an assumption).\nSo the statement of the theorem can be read:\n\n> Let `x` and `y` be integers. Let `h` be the hypothesis `y = 2 * x`. Then `x + y = x + 2 * x`.\n\nWhen you start the proof, you'll note in the top-right pane that `h : y = 2 * x` has been\nadded to the context.\n\nYou can use the hypothesis to rewrite the goal by typing `rw h` much as you used `rw add_comm`\nto rewrite via the theorem `add_comm`.\n\n**Before doing the problem below**, think about what effect `rw h` will have on the goal.\n", "namespace exlean -- hide\n", "variables (x y : \u2124) -- Declare `x` and `y` to be integers.\n", "Let `x` and `y` be integers. Let `h` be the hypothesis `y = 2 * x`. Then `x + y = x + 2 * x`.\n", "end exlean -- hide\n", "## Translation to a hand-written proof\n\n> Rewriting using `h`, the goal is to prove `x + 2 * x = x + 2 * x`.\n> This follows by reflexivity.\n", "import tactic.structure_helper tactic.pure_maths -- hide\n", "import myint.basic equations.commutativity_rw.level -- hide\n", "open_locale mynum -- hide\n", "# Equations\n\n## Level 4: Focussed rewriting\n\nHere, you're asked to prove `(x + y) + z = z + (y + x)`. Clearly a case for rewriting with the\n`add_comm` theorem.\n\nThink about what `rw add_comm` will do. What will happen if you do `rw add_comm` twice? Try this\nbelow and test your conjecture.\n\nWhat happens is that `rw add_comm` looks for an expression of the form `a + b`. It finds one in\n`(x + y) + z`, matching `a` with `x + y` and `b` with `z`. It replaces this with `b + a`. That is,\nwith `z + (x + y)`.\n\nYou might wonder why this is the first match. Why doesn't Lean work on `x + y` first, matching\n`a` with `x` and `b` with `y`? It's because Lean works outside-in, then left-to-right. The second\n`+` operator in `(x + y) + z` is the outermost operator, so is read first by Lean.\n\nThe problem: applying `rw add_comm` to the new goal `\u22a2 z + (x + y) = z + (y + x)` will match `a`\nwith `z` and `b` with `x + y`, rewriting the goal to `\u22a2 (x + y) + z = z + (y + x)`, taking us back\nto where we started!\n\n### Focussing a rewrite with arguments\n\nRecall that `add_comm a b` is the theorem that `a + b = b + a`. The quantities `a` and `b` are\n*arguments* to the theorem `add_comm`.\nEqually, `add_comm x (y + z)` is the theorem that `x + (y + z) = (y + z) + x`. This theorem has\narguments `x` and `y + x`. Note than arguments can be expressions, not just variables.\n\nApplying `rw add_comm x (y + z)` transforms `\u22a2 z + (x + (y + z)) = z` to\n`\u22a2 z + ((y + z) + x) = z`.\n\nUse arguments, where necessary, to prove the theorem below.\n\n", "namespace exlean -- hide\n", "variables (x y z : \u2124) -- Declare `x`, `y`, and `z` to be integers.\n", "Let `x`, `y`, and `z` be integers. Then `(x + y) + z = z + (y + x)`.\n", "end exlean -- hide\n", "## Translation to a hand-written proof\n\nHere's a suggestion. When writing a proof by hand, you need not (and should not) aim at a direct\ntranslation of a Lean proof. Here, I've kept the main idea of each line of my Lean proof while\ntranslating for ease of human understanding.\n\n> Rewriting by additive commutativity, the goal is to prove `z + (x + y) = z + (y + x)`.\n> Rewriting with additive commutativity on `x + y`, the goal is to prove `z + (y + x) = z + (y + x)`.\n> This follows by reflexivity.\n", "Functions", "-- import the definition of the function `f`.\nimport function.domain_codomain_map.defn\n", "# Functions\n\n## Level 1: \n\n-- Level name: the name of the level.\n\nYou are in a maze of twisty passages, all distinct! \n\nYou can go north, south east or west.\n", "namespace exlean -- hide\n", "There are 5 rooms. Rooms are called 0, 1, 2, 3 and 4, with 0 being\nwhere you start and 4 being the exit.\n\n\nUse `n`, `s`, `e`, `w` to move around. When you're at the exit, type `out`.\n\n  Don't forget the commas.\n  Don't bang into the walls -- those are errors.\n  When you get to room 4, the tactic to get you out is `out`. \n  There is also a magic word, rumoured to be\n  an ancient translation of the word `sorry`.\n", "example : my_f 5 = sorry :=\nbegin\n  sorry\nend\n", "end exlean -- hide\n"]]}
{"name": "Pure Mathematics with Lean", "version": "1.0.0", "languages": ["en"], "translated_name": "0", "devmode": false, "library_zip_fn": "Pure Mathematics with Lean-1.0.0-library.zip", "introData": {"name": "", "problemIndex": -1, "objects": [{"type": "text", "content": "1"}]}, "worlds": [{"name": "2", "levels": [{"name": "", "problemIndex": 8, "objects": [{"type": "lean", "content": "3", "hidden": true}, {"type": "text", "content": "4"}, {"type": "tactic", "content": "5", "name": "refl", "sideBar": true}, {"type": "text", "content": "6"}, {"type": "lean", "content": "7", "hidden": true}, {"type": "lean", "content": "8", "hidden": true}, {"type": "lean", "content": "9", "hidden": true}, {"type": "lean", "content": "10", "hidden": false}, {"type": "theorem", "text": "11", "lean": "theorem x_plus_y_eq_x_plus_y : x + y = x + y :=\n", "sideBar": false, "firstProofLineNumber": 65, "lastProofLineNumber": 65, "textBefore": "import myint.basic -- hide\n\n/-\n# Equations\n\n## Level 1: Proving equations through reflexivity\n\nIn the introduction, you read that tactics are used modify the goal, eventually proving \na theorem.\n\nThe `refl` tactic (short for `reflexivity`) can be used to prove any statement of the form\n`?X = ?X`. Here, I use `?X` to stand in for any expression of any type.\nIt could be `8 + 9` or `a * b` or `\"adele\"` or whatever.\n\nHere, you are asked to prove `x + y = x + y`, where `x` and `y` are integers.\nThe word `sorry` between the `begin` and `end` lines below asks Lean not to give an error message if a\nproof isn't complete. You'll see a warning message in the bottom-right hand pane. This indicates\nyou shouldn't trust the proof just yet, as it uses `sorry`!\n\nDelete `sorry` (using the backspace key on your keyboard). In the right-hand pane you'll see:\n```\nx y : \u2124\n\u22a2 x + y = x + y\n```\n\nHere, `x y : \u2124` is the *context*, the set of things you know. In this case, you know `x` and `y`\nare integers.\n\nThe *target* is `\u22a2 x + y = x + y`. The `\u22a2` symbol can be read 'to prove'. So your target is\nto prove `x + y = x + y`.\n\nThe bottom part of the right-hand pane shows an *error message*. Don't panic! It's just telling you\nthat you haven't yet proved the result.\n\nYour task is to replace `sorry` with `refl,`. Note the comma at the end of the line!\nIf you're successful, Lean will respond with the message `Proof complete!` or `no goals`.\n-/\n\n/- Tactic : refl\nThe `refl` tactic closes any goal of the form `?X = ?X`. That is, it proves any equation where the\nleft and right sides are *definitionally equal*.\n-/\n\n/-\n## Translation to a hand-written proof\n\nIn words, the `refl` says, \"The result holds by reflexivity\". A one-line written proof of\nthe theorem below would be, \"The result hold by reflexivity\".\n\n-/\n\nnamespace exlean -- hide\n\nopen myint -- hide\n\nopen_locale mynum -- hide\n\nvariables (x y : \u2124) -- Declare `x` and `y` to be integers.\n\n/- Theorem : no-side-bar\n`x + y = x + y`, for all integers `x` and `y`.\n-/\ntheorem x_plus_y_eq_x_plus_y : x + y = x + y :=\nbegin\n", "proof": "  refl,", "textAfter": "\nend\n\nend exlean -- hide\n", "height": 1, "editorText": "sorry", "lineOffset": 64, "name": "x_plus_y_eq_x_plus_y", "statement": "x + y = x + y"}, {"type": "lean", "content": "12", "hidden": true}]}, {"name": "", "problemIndex": 8, "objects": [{"type": "lean", "content": "13", "hidden": true}, {"type": "text", "content": "14"}, {"type": "lean", "content": "15", "hidden": true}, {"type": "lean", "content": "16", "hidden": true}, {"type": "lean", "content": "17", "hidden": true}, {"type": "axiom", "content": "18", "name": "add_comm (a b : \u2124) :", "sideBar": true}, {"type": "lean", "content": "19", "hidden": true}, {"type": "hint", "content": "20", "title": "21"}, {"type": "theorem", "text": "22", "lean": "theorem x_plus_y_eq_y_plus_x : x + y = y + x :=\n", "sideBar": false, "firstProofLineNumber": 68, "lastProofLineNumber": 69, "textBefore": "import myint.basic -- hide\n\n/-\n# Equations\n\n## Level 2: Commutativity of addition\n\nNow we'll prove something (slighlty) more interesting, that `x + y = y + x` for all integers `x`\nand `y`. Try the `refl` tactic below (remember to put a comma after `refl`) and see what happens.\n\nYou'll get an error message:\n```\ninvalid apply tactic, failed to unify\n  x + y = y + x\nwith\n  ?m_2 = ?m_2\n```\n\nLean tells you that you're trying to use `refl` to prove `x + y = y + x`, but it expects a target\nof the form `?m_2 = ?m_2`. There's no special meaning to the underscores here. It's the same as\nwriting `?X = ?X` as in the previous level.\n\nThe problem: even though we 'know' the left and right sides are equal, they are not\n*identically equal*.\nFortunately, Lean comes with a *theorem* of just the right kind. It's called `add_comm`, which is\nshort for additive commutativity.\nThe result `add_comm a b` states that `a + b = b + a`, where `a` and `b` are integers.\n\nTo apply this theorem, we'll use the `rw` (short for `rewrite`) tactic.\n\nReplace the `sorry` below with `rw add_comm` (followed by a comma\u2014I won't mention this from now\non).\n\nLean will look for the first expression in the target that matches the pattern `a + b` and\nreplace it with `b + a`. Here, Lean finds `x + y` and replaces it with `y + x`.\n\nMore generally, if `h` is an equation of the form `p = q` (where `p` and `q` are expressions),\n`rw h` will cause Lean to look for `p` in the target and replace it with `q`.\n\nHaving issued `rw add_comm`, the goal is to prove `y + x = y + x`.\nYou know how to prove a goal of this kind from the previous level.\nWrite the proof on the line after the `rw add_comm`.\n-/\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\nvariables (x y : \u2124) -- hide\n\n/- Axiom : add_comm (a b : \u2124) :\na + b = b + a\n-/\ntheorem add_comm (a b : \u2124) : a + b = b + a := myint.add_comm' a b -- hide\n\n/- Hint : Moving through a proof\n\nYour proof of the theorem below will use two lines of code. If you move your cursor to a previous\nline, Lean will show you the tactic state at any point in the proof. If you click on the name of\na theorem, you'll get some brief documentation.\n-/\n\n/- Theorem : no-side-bar\n`x + y = y + x`, for all integers `x` and `y`.\n-/\ntheorem x_plus_y_eq_y_plus_x : x + y = y + x :=\nbegin [pure_maths]\n", "proof": "  rw add_comm,\n  refl,", "textAfter": "\nend\n\nend exlean -- hide\n\n/-\n## Translation to a hand-written proof\n\nIn words, the `rw add_comm` says, \"Rewrite using commuativity of addition\".\nAs hand-written proofs aren't interactive, it's helpful to mention explicitly any changes to the\ncontext. Here's a hand-written proof of the above result.\n\n> Rewriting using commutativity of addition, the goal is to prove `y + x = y + x`.\n> This follows by reflexivity.\n-/\n\n/- Tactic : rw\nIf `h` is an equation of the form `p = q`, `rw h` rewrites replaces `p` in the target with `q`.\n\nIf `k` is in the context, `rw h at k` performs the rewrite at `k` instead of at the target.\n-/\n\n\n/-\n## Anatomy of a level\n\nEach level contains three vertial panes. The left-hand pane contains a list of the tactics and\ntheorem statements you've seen so far. Click on the arrows to dig deeper.\n\nThe middle pane is the one you're reading now! It contains text and interactive exercises.\nThe right-hand pane contains the Lean Infoview window, showing the 'tactic state' and error messages.\n\nYou can navigate through the book using the buttons in the top horizonal pane. The circular arrow\nresets your progress.\n-/\n\n/-\n## How `rw` here differs from that in standard Lean\n\nThe `rw` tactic used in this book is slightly different the standard `rw`. In particular, if\nthe result of a rewrite is an equation of the form `X = X`, then the standard `rw` tactic will\nautomatically close the goal via reflexivity.\n\nThis automation has been disabled here to help you think more carefully about proof construction.\n-/\n\n", "height": 2, "editorText": "sorry", "lineOffset": 67, "name": "x_plus_y_eq_y_plus_x", "statement": "x + y = y + x"}, {"type": "lean", "content": "23", "hidden": true}, {"type": "text", "content": "24"}, {"type": "tactic", "content": "25", "name": "rw", "sideBar": true}, {"type": "text", "content": "26"}, {"type": "text", "content": "27"}]}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "28", "hidden": true}, {"type": "text", "content": "29"}, {"type": "lean", "content": "30", "hidden": true}, {"type": "lean", "content": "31", "hidden": true}, {"type": "lean", "content": "32", "hidden": true}, {"type": "theorem", "text": "33", "lean": "theorem rw_using_h (h : y = 2 * x) : x + y = x + 2 * x :=\n", "sideBar": false, "firstProofLineNumber": 37, "lastProofLineNumber": 38, "textBefore": "import myint.basic equations.commutativity_rw.level -- hide\n\n/-\n# Equations\n\n## Level 3: Rewriting with hypotheses\n\nLook at the theorem below. It seems that you're being asked to prove `x + y = x + 2 * x`.\nSurely that isn't true in general! What's\ngoing on? If you look carefully, you'll see an additional hypothesis, `h : y = 2 * x`.\n\nThe `:` is just notation for naming a hypothesis (also called an assumption).\nSo the statement of the theorem can be read:\n\n> Let `x` and `y` be integers. Let `h` be the hypothesis `y = 2 * x`. Then `x + y = x + 2 * x`.\n\nWhen you start the proof, you'll note in the top-right pane that `h : y = 2 * x` has been\nadded to the context.\n\nYou can use the hypothesis to rewrite the goal by typing `rw h` much as you used `rw add_comm`\nto rewrite via the theorem `add_comm`.\n\n**Before doing the problem below**, think about what effect `rw h` will have on the goal.\n-/\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\nvariables (x y : \u2124) -- hide\n\n/- Theorem : no-side-bar\nLet `x` and `y` be integers. Let `h` be the hypothesis `y = 2 * x`. Then `x + y = x + 2 * x`.\n-/\ntheorem rw_using_h (h : y = 2 * x) : x + y = x + 2 * x :=\nbegin [pure_maths]\n", "proof": "  rw h,\n  refl,", "textAfter": "\nend\n\nend exlean -- hide\n\n/-\n## Translation to a hand-written proof\n\n> Rewriting using `h`, the goal is to prove `x + 2 * x = x + 2 * x`.\n> This follows by reflexivity.\n-/\n\n", "height": 2, "editorText": "sorry", "lineOffset": 36, "name": "rw_using_h", "statement": "(h : y = 2 * x) : x + y = x + 2 * x"}, {"type": "lean", "content": "34", "hidden": true}, {"type": "text", "content": "35"}]}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "36", "hidden": true}, {"type": "text", "content": "37"}, {"type": "lean", "content": "38", "hidden": true}, {"type": "lean", "content": "39", "hidden": true}, {"type": "lean", "content": "40", "hidden": false}, {"type": "hint", "content": "41", "title": "42"}, {"type": "theorem", "text": "43", "lean": "theorem add_comm_left_right : (x + y) + z = z + (y + x) :=\n", "sideBar": false, "firstProofLineNumber": 59, "lastProofLineNumber": 61, "textBefore": "import myint.basic equations.commutativity_rw.level -- hide\n\n/-\n# Equations\n\n## Level 4: Focussed rewriting\n\nHere, you're asked to prove `(x + y) + z = z + (y + x)`. Clearly a case for rewriting with the\n`add_comm` theorem.\n\nThink about what `rw add_comm` will do. What will happen if you do `rw add_comm` twice? Try this\nbelow and test your conjecture.\n\nWhat happens is that `rw add_comm` looks for an expression of the form `a + b`. It finds one in\n`(x + y) + z`, matching `a` with `x + y` and `b` with `z`. It replaces this with `b + a`. That is,\nwith `z + (x + y)`.\n\nYou might wonder why this is the first match. Why doesn't Lean work on `x + y` first, matching\n`a` with `x` and `b` with `y`? It's because Lean works outside-in, then left-to-right. The second\n`+` operator in `(x + y) + z` is the outermost operator, so is read first by Lean.\n\nThe problem: applying `rw add_comm` to the new goal `\u22a2 z + (x + y) = z + (y + x)` will match `a`\nwith `z` and `b` with `x + y`, rewriting the goal to `\u22a2 (x + y) + z = z + (y + x)`, taking us back\nto where we started!\n\n### Focussing a rewrite with arguments\n\nRecall that `add_comm a b` is the theorem that `a + b = b + a`. The quantities `a` and `b` are\n*arguments* to the theorem `add_comm`.\nEqually, `add_comm x (y + z)` is the theorem that `x + (y + z) = (y + z) + x`. This theorem has\narguments `x` and `y + x`. Note than arguments can be expressions, not just variables.\n\nApplying `rw add_comm x (y + z)` transforms `\u22a2 z + (x + (y + z)) = z` to\n`\u22a2 z + ((y + z) + x) = z`.\n\nUse arguments, where necessary, to prove the theorem below.\n\n-/\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\nvariables (x y z : \u2124) -- Declare `x`, `y`, and `z` to be integers.\n\n/- Hint : Missing parentheses?\n\nWhen you start the proof below, Lean displays the target as `\u22a2 x + y + z = z + (y + x)`.\nWhat happened to the parentheses on the left-hand side? Lean treats addition as\n'left associative'. This is a fancy way of saying that `x + y + z` should always be\ninterpreted as `(x + y) + z`.\n-/\n\n/- Theorem : no-side-bar\nLet `x`, `y`, and `z` be integers. Then `(x + y) + z = z + (y + x)`.\n-/\ntheorem add_comm_left_right : (x + y) + z = z + (y + x) :=\nbegin [pure_maths]\n", "proof": "  rw add_comm,\n  rw add_comm x y,\n  refl,", "textAfter": "\nend\n\nend exlean -- hide\n\n/-\n## Translation to a hand-written proof\n\nHere's a suggestion. When writing a proof by hand, you need not (and should not) aim at a direct\ntranslation of a Lean proof. Here, I've kept the main idea of each line of my Lean proof while\ntranslating for ease of human understanding.\n\n> Rewriting by additive commutativity, the goal is to prove `z + (x + y) = z + (y + x)`.\n> Rewriting with additive commutativity on `x + y`, the goal is to prove `z + (y + x) = z + (y + x)`.\n> This follows by reflexivity.\n-/\n\n", "height": 3, "editorText": "sorry", "lineOffset": 58, "name": "add_comm_left_right", "statement": "(x + y) + z = z + (y + x)"}, {"type": "lean", "content": "44", "hidden": true}, {"type": "text", "content": "45"}]}, {"name": "", "problemIndex": 9, "objects": [{"type": "lean", "content": "46", "hidden": true}, {"type": "text", "content": "47"}, {"type": "lean", "content": "48", "hidden": true}, {"type": "lean", "content": "49", "hidden": true}, {"type": "axiom", "content": "50", "name": "add_assoc (a b c : \u2124) :", "sideBar": true}, {"type": "lean", "content": "51", "hidden": true}, {"type": "lean", "content": "52", "hidden": false}, {"type": "lean", "content": "53", "hidden": true}, {"type": "hint", "content": "54", "title": "55"}, {"type": "theorem", "text": "56", "lean": "theorem add_assoc_right_comm : (x + y) + z = x + (z + y) :=\n", "sideBar": false, "firstProofLineNumber": 44, "lastProofLineNumber": 46, "textBefore": "import myint.basic equations.commutativity_rw.level -- hide\n\n/-\n# Equations\n\n## Level 5: Associativity\n\nTime for a new theorem. This one is called `add_assoc`, which is short for additive associativity.\n\nThe result `add_assoc a b c` states that `(a + b) + c = a + (b + c)`, for all integers `a`, `b`,\nand `c`. You can see the statement in the sidebar on the left by unfolding 'Theorem statements'.\n\nAs with `add_comm`, you can use `add_assoc` to rewrite the goal using `rw add_assoc`.\n\nBelow, your task is to prove `(x + y) + z = x + (z + y)`.\n\n**Before writing a Lean proof**, construct a hand-written proof.\n-/\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\n/- Axiom : add_assoc (a b c : \u2124) :\n(a + b) + c = a + (b + c)\n-/\ntheorem myint.add_assoc (a b c : \u2124) : a + b + c = a + (b + c) := myint.add_assoc' a b c -- hide\n\nopen myint\n\nvariables (x y z : \u2124) -- hide\n\n/- Hint : Hint\n\nYou'll need to rewrite with both `add_comm` and `add_assoc`. You may need to give arguments to one\nof your rewrites, as described in the previous level.\n-/\n\n/- Theorem : no-side-bar\nLet `x`, `y`, and `z` be integers. Then `(x + y) + z = x + (z + y)`.\n-/\ntheorem add_assoc_right_comm : (x + y) + z = x + (z + y) :=\nbegin [pure_maths]\n", "proof": "  rw add_assoc,\n  rw add_comm y z,\n  refl,", "textAfter": "\nend\n\n/-\n## Translation to a hand-written proof\n\nIn the following hand-written proof, I omit the word 'rewriting'.\n\n> By associativity, the goal is to prove `x + (y + z) = x + (z + y)`.\n> By commutativity, the goal is to prove `x + (z + y) = x + (z + y)`.\n> This follows by reflexivity.\n-/\n\nend exlean -- hide", "height": 3, "editorText": "sorry", "lineOffset": 43, "name": "add_assoc_right_comm", "statement": "(x + y) + z = x + (z + y)"}, {"type": "text", "content": "57"}, {"type": "lean", "content": "58", "hidden": true}]}, {"name": "", "problemIndex": 8, "objects": [{"type": "lean", "content": "59", "hidden": true}, {"type": "text", "content": "60"}, {"type": "hint", "content": "61", "title": "62"}, {"type": "tactic", "content": "63", "name": "have", "sideBar": true}, {"type": "lean", "content": "64", "hidden": true}, {"type": "lean", "content": "65", "hidden": true}, {"type": "lean", "content": "66", "hidden": true}, {"type": "lean", "content": "67", "hidden": true}, {"type": "theorem", "text": "68", "lean": "theorem add_right_comm_comm : x + ((x + y) + z) = x + (z + (x + y)) :=\n", "sideBar": false, "firstProofLineNumber": 59, "lastProofLineNumber": 61, "textBefore": "import myint.basic equations.associativity.level -- hide\n\n/-\n# Equations\n\n## Level 6: Structuring proofs with `have`\n\nThe `have` tactic introduces a hypothesis into the context. It's a way to add structure to your\nproofs, stating and proving intermediate results before using them.\n\nConsider the goal `\u22a2 x + ((x + y) + z) = x + (z + (x + y))`.\n\nOne way to close this goal is to rewrite, giving specific arguments to `add_comm`.\nAnother option is to introduce an intermediate goal of proving `(x + y) + z = z + (x + y)`.\n\nThis is accomplished using `have h : (x + y) + z = z + (x + y)` (followed by a comma). \nThere's nothing special about `h` as the name of the hypothesis. Change it to whatever you wish.\n\nThis opens up a new goal: you'll see 2 goals in right-hand pane. The top goal is the new goal,\nnamely `\u22a2 (x + y) + z = z + (x + y)`. The bottom goal is the old goal, only with a new hypothesis,\n`h : (x + y) + z = z + (x + y)`.\n\nYou first work on closing the new goal, then close the original goal using hypothesis `h`.\n-/\n\n/- Hint : Focussing on one goal at a time\n\nIf you want to work only on goal, put braces after the `have`. When you're cursor is in the\ninner brace, you'll only be working on the first goal.\n```\nhave h : (x + y) + z = z + (x + y),\n{ sorry },\nsorry\n``` \n-/\n\n/- Tactic : have\n`have` is used to introduce a new hypothesis into the context. It opens a new goal for the proof\nof the hypothesis.\n\nFor example, `have h2 : x + y = y + x` introduces a new goal, to prove\n`x + y = y + x` while adding the hypothesis `h2 : x + y = y + x` to the context of the old goal.\n-/\n\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\nopen myint -- hide\n\nvariables (x y z : \u2124) -- hide\n\n/- Theorem : no-side-bar\nLet `x`, `y`, and `z` be integers. Then `x + ((x + y) + z) = x + (z + (x + y)))`.\n-/\ntheorem add_right_comm_comm : x + ((x + y) + z) = x + (z + (x + y)) :=\nbegin [pure_maths]\n", "proof": "  have h : (x + y) + z = z + (x + y),\n  rw add_comm, refl,\n  rw h, refl,", "textAfter": "\nend\n\n/-\n## Translation to a hand-written proof\n\nIn my hand-written proof below, I omit references to reflexivity.\n\n> I claim `h : (x + y) + z = z + (x + y)`.\n> To prove this, use commutativity of addition.\n> Rewrite the original goal using `h`.\n-/\n\nend exlean -- hide", "height": 3, "editorText": "sorry", "lineOffset": 58, "name": "add_right_comm_comm", "statement": "x + ((x + y) + z) = x + (z + (x + y))"}, {"type": "text", "content": "69"}, {"type": "lean", "content": "70", "hidden": true}]}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "71", "hidden": true}, {"type": "text", "content": "72"}, {"type": "lean", "content": "73", "hidden": true}, {"type": "lean", "content": "74", "hidden": true}, {"type": "lean", "content": "75", "hidden": true}, {"type": "lean", "content": "76", "hidden": true}, {"type": "theorem", "text": "77", "lean": "theorem add_right_comm_adele : x + (y + (x + z)) = (z + (x + y)) + x :=\n", "sideBar": false, "firstProofLineNumber": 30, "lastProofLineNumber": 32, "textBefore": "import myint.basic equations.associativity.level -- hide\n\n/-\n# Equations\n\n## Level 7: Multiple rewrites\n\nRather than writing, for example `rw add_assoc x y z, rw add_comm`, you can write\n`rw [add_assoc x y z, add_comm]`. Use this technique, together with `have`, to write a structured\nproof below.\n\nNow write a proof using a long chain of rewrites followed by `refl`. Which proof do you prefer? Why?\n-/\n\n\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\nopen myint -- hide\n\nvariables (x y z : \u2124) -- hide\n\n/- Theorem : no-side-bar\nLet `x`, `y`, and `z` be integers. Then `x + (y + (x + z)) = (z + (x + y)) + x`.\n-/\ntheorem add_right_comm_adele : x + (y + (x + z)) = (z + (x + y)) + x :=\nbegin [pure_maths]\n", "proof": "  have h : y + (x + z) = z + (x + y),\n    rw add_comm, rw add_comm x, rw add_assoc, refl,\n  rw h, rw add_comm, refl,", "textAfter": "\nend\n\n\nend exlean -- hide", "height": 3, "editorText": "sorry", "lineOffset": 29, "name": "add_right_comm_adele", "statement": "x + (y + (x + z)) = (z + (x + y)) + x"}, {"type": "lean", "content": "78", "hidden": true}]}]}, {"name": "79", "levels": [{"name": "", "problemIndex": 7, "objects": [{"type": "lean", "content": "80", "hidden": true}, {"type": "text", "content": "81"}, {"type": "lean", "content": "82", "hidden": true}, {"type": "lean", "content": "83", "hidden": true}, {"type": "axiom", "content": "84", "name": "`my_f`", "sideBar": true}, {"type": "lean", "content": "85", "hidden": false}, {"type": "text", "content": "86"}, {"type": "theorem", "text": "87", "lean": "theorem my_fun : my_f 10 = 35 :=\n", "sideBar": false, "firstProofLineNumber": 51, "lastProofLineNumber": 51, "textBefore": "import mynat.basic -- hide\n\n/-\n# Functions\n\n## Level 1: Defining functions\n\nA function is a map from one set, called the domain, to another set, called the codomain.\n\nThe notation `f : S \u2192 T` is read, \"`f` is a function with domain `S` and codomain `T`\" or \"`f` is a\nfunction from `S` to `T`\".\n\nTo specify that `f` maps each `x` to some expression `y`, we write `f : x \u21a6 y` or\n`f(x) = y`, when doing mathematics by hand.\n\nIn Lean, we combine all the above information into:\n```\ndef f : S \u2192 T := \u03bb x, y\n```\nwhere `y` is an expression that depends on `x`. Here `\u03bb` is a Greek letter called lambda.\nIts only significance is to indicate that the following quantity `x` is a variable.\n\nBelow is the definition of a function `my_f` from the set `\u2115` of natural numbers (the non-negative)\nintegers to itself. It takes each `x` to `3 * x + 5`.\n-/\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\n/- Axiom : `my_f`\nThe function `my_f` is defined so that `my_f (x) = 3 * x + 5` for every \nnatural number `x`.\n-/\ndef my_f : \u2115 \u2192 \u2115 := \u03bb x, 3 * x + 5\n\n/-\nYour task is to prove `my_f 10 = 35`. By definition of `my_f`, you must prove `3 * 10 + 5 = 35`.\nIt may come as a surprise to learn that Lean can prove this using `refl`.\nThe reason is that when Lean uses `refl`, it applies definitions until no further simplification is\npossible. For reasons that will become apparent later, the definitions of addition and\nmultiplication can be applied to reduce any 'sum' into a natural number.\n-/\n\n\n/- Theorem : no-side-bar\nThe function `my_f` takes `10` to `35`.\n-/\ntheorem my_fun : my_f 10 = 35 :=\nbegin\n", "proof": "  refl,", "textAfter": "\nend\n\nend exlean -- hide\n", "height": 1, "editorText": "sorry", "lineOffset": 50, "name": "my_fun", "statement": "my_f 10 = 35"}, {"type": "lean", "content": "88", "hidden": true}]}], "parents": [0]}], "texts": [["Pure Mathematics with Lean", "# Pure mathematics with Lean, version 1.0.0\n\n## By Gihan Marasingha\n\nThis is an interactive book aimed at beginning mathematics undergraduates. You'll learn to prove\ntheorems online using a computer tool called Lean.\n\nEach chapter is represented by a coloured circular button in the right-hand pane. Blue indicates your\ncurrent position, green is for completed chapters, and grey is for unread or incomplete chapters.\n\nAt every stage in a theorem, there is a *target*, the thing you want to prove, and a *context*, the\nset of things you have already proved or assumed at the beginning of your argument.\nThe target and context change through the proof.\n\nThe word *goal* is used to refer variously to the target or to the combination of target and context.\n\nYou'll use *tactics* to modify the goal until you have proved the target (called 'closing the goal').\nEach tactic may invoke one or more *theorems*.\n\nNote: the book is roughly 30Mb in size. It must be downloaded before you can begin to work on the\nproblems. Once you open the book, wait for the text 'Lean is busy...' to disappear from the\ntop-right-hand pane before using Lean.\n\n*Pure mathematics with Lean* is part of the \n<a href=\"https://exlean.org\" target=\"blank\">exlean</a> project.\n\n\n## Credits\n\nThis game was made using the code base of the\n<a href=\"https://www.ma.imperial.ac.uk/~buzzard/xena/natural_number_game/\">Natural Number Game</a>\nby Kevin Buzzard and Mohammad Pedramfar.\n\n<a href=\"https://leanprover.github.io/\" target=\"blank\">Lean</a> is an interactive theorem prover developed at Microsoft Research under the direction of\nLeonardo de Moura.\n\nMathlib, Lean's mathematical library, is developed by the <a href=\"https://leanprover-community.github.io/\" target=\"blank\">Lean community</a>.\n\nHere's some mathematics in MathJax, just to remind me that it's possible.\nFirst inline: \\\\(a^2 + b^2 = c^2\\\\). Now displayed:\n\n\\\\[ \\int_{-\\infty}^\\infty  e^{-x^2} dx = \\sqrt \\pi. \\\\]\n\n", "Equations", "import myint.basic -- hide\n", "# Equations\n\n## Level 1: Proving equations through reflexivity\n\nIn the introduction, you read that tactics are used modify the goal, eventually proving \na theorem.\n\nThe `refl` tactic (short for `reflexivity`) can be used to prove any statement of the form\n`?X = ?X`. Here, I use `?X` to stand in for any expression of any type.\nIt could be `8 + 9` or `a * b` or `\"adele\"` or whatever.\n\nHere, you are asked to prove `x + y = x + y`, where `x` and `y` are integers.\nThe word `sorry` between the `begin` and `end` lines below asks Lean not to give an error message if a\nproof isn't complete. You'll see a warning message in the bottom-right hand pane. This indicates\nyou shouldn't trust the proof just yet, as it uses `sorry`!\n\nDelete `sorry` (using the backspace key on your keyboard). In the right-hand pane you'll see:\n```\nx y : \u2124\n\u22a2 x + y = x + y\n```\n\nHere, `x y : \u2124` is the *context*, the set of things you know. In this case, you know `x` and `y`\nare integers.\n\nThe *target* is `\u22a2 x + y = x + y`. The `\u22a2` symbol can be read 'to prove'. So your target is\nto prove `x + y = x + y`.\n\nThe bottom part of the right-hand pane shows an *error message*. Don't panic! It's just telling you\nthat you haven't yet proved the result.\n\nYour task is to replace `sorry` with `refl,`. Note the comma at the end of the line!\nIf you're successful, Lean will respond with the message `Proof complete!` or `no goals`.\n", "The `refl` tactic closes any goal of the form `?X = ?X`. That is, it proves any equation where the\nleft and right sides are *definitionally equal*.\n", "## Translation to a hand-written proof\n\nIn words, the `refl` says, \"The result holds by reflexivity\". A one-line written proof of\nthe theorem below would be, \"The result hold by reflexivity\".\n\n", "namespace exlean -- hide\n", "open myint -- hide\n", "open_locale mynum -- hide\n", "variables (x y : \u2124) -- Declare `x` and `y` to be integers.\n", "`x + y = x + y`, for all integers `x` and `y`.\n", "end exlean -- hide\n", "import myint.basic -- hide\n", "# Equations\n\n## Level 2: Commutativity of addition\n\nNow we'll prove something (slighlty) more interesting, that `x + y = y + x` for all integers `x`\nand `y`. Try the `refl` tactic below (remember to put a comma after `refl`) and see what happens.\n\nYou'll get an error message:\n```\ninvalid apply tactic, failed to unify\n  x + y = y + x\nwith\n  ?m_2 = ?m_2\n```\n\nLean tells you that you're trying to use `refl` to prove `x + y = y + x`, but it expects a target\nof the form `?m_2 = ?m_2`. There's no special meaning to the underscores here. It's the same as\nwriting `?X = ?X` as in the previous level.\n\nThe problem: even though we 'know' the left and right sides are equal, they are not\n*identically equal*.\nFortunately, Lean comes with a *theorem* of just the right kind. It's called `add_comm`, which is\nshort for additive commutativity.\nThe result `add_comm a b` states that `a + b = b + a`, where `a` and `b` are integers.\n\nTo apply this theorem, we'll use the `rw` (short for `rewrite`) tactic.\n\nReplace the `sorry` below with `rw add_comm` (followed by a comma\u2014I won't mention this from now\non).\n\nLean will look for the first expression in the target that matches the pattern `a + b` and\nreplace it with `b + a`. Here, Lean finds `x + y` and replaces it with `y + x`.\n\nMore generally, if `h` is an equation of the form `p = q` (where `p` and `q` are expressions),\n`rw h` will cause Lean to look for `p` in the target and replace it with `q`.\n\nHaving issued `rw add_comm`, the goal is to prove `y + x = y + x`.\nYou know how to prove a goal of this kind from the previous level.\nWrite the proof on the line after the `rw add_comm`.\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "variables (x y : \u2124) -- hide\n", "a + b = b + a\n", "theorem add_comm (a b : \u2124) : a + b = b + a := myint.add_comm' a b -- hide\n", "\nYour proof of the theorem below will use two lines of code. If you move your cursor to a previous\nline, Lean will show you the tactic state at any point in the proof. If you click on the name of\na theorem, you'll get some brief documentation.\n", "Moving through a proof", "`x + y = y + x`, for all integers `x` and `y`.\n", "end exlean -- hide\n", "## Translation to a hand-written proof\n\nIn words, the `rw add_comm` says, \"Rewrite using commuativity of addition\".\nAs hand-written proofs aren't interactive, it's helpful to mention explicitly any changes to the\ncontext. Here's a hand-written proof of the above result.\n\n> Rewriting using commutativity of addition, the goal is to prove `y + x = y + x`.\n> This follows by reflexivity.\n", "If `h` is an equation of the form `p = q`, `rw h` rewrites replaces `p` in the target with `q`.\n\nIf `k` is in the context, `rw h at k` performs the rewrite at `k` instead of at the target.\n", "## Anatomy of a level\n\nEach level contains three vertial panes. The left-hand pane contains a list of the tactics and\ntheorem statements you've seen so far. Click on the arrows to dig deeper.\n\nThe middle pane is the one you're reading now! It contains text and interactive exercises.\nThe right-hand pane contains the Lean Infoview window, showing the 'tactic state' and error messages.\n\nYou can navigate through the book using the buttons in the top horizonal pane. The circular arrow\nresets your progress.\n", "## How `rw` here differs from that in standard Lean\n\nThe `rw` tactic used in this book is slightly different the standard `rw`. In particular, if\nthe result of a rewrite is an equation of the form `X = X`, then the standard `rw` tactic will\nautomatically close the goal via reflexivity.\n\nThis automation has been disabled here to help you think more carefully about proof construction.\n", "import myint.basic equations.commutativity_rw.level -- hide\n", "# Equations\n\n## Level 3: Rewriting with hypotheses\n\nLook at the theorem below. It seems that you're being asked to prove `x + y = x + 2 * x`.\nSurely that isn't true in general! What's\ngoing on? If you look carefully, you'll see an additional hypothesis, `h : y = 2 * x`.\n\nThe `:` is just notation for naming a hypothesis (also called an assumption).\nSo the statement of the theorem can be read:\n\n> Let `x` and `y` be integers. Let `h` be the hypothesis `y = 2 * x`. Then `x + y = x + 2 * x`.\n\nWhen you start the proof, you'll note in the top-right pane that `h : y = 2 * x` has been\nadded to the context.\n\nYou can use the hypothesis to rewrite the goal by typing `rw h` much as you used `rw add_comm`\nto rewrite via the theorem `add_comm`.\n\n**Before doing the problem below**, think about what effect `rw h` will have on the goal.\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "variables (x y : \u2124) -- hide\n", "Let `x` and `y` be integers. Let `h` be the hypothesis `y = 2 * x`. Then `x + y = x + 2 * x`.\n", "end exlean -- hide\n", "## Translation to a hand-written proof\n\n> Rewriting using `h`, the goal is to prove `x + 2 * x = x + 2 * x`.\n> This follows by reflexivity.\n", "import myint.basic equations.commutativity_rw.level -- hide\n", "# Equations\n\n## Level 4: Focussed rewriting\n\nHere, you're asked to prove `(x + y) + z = z + (y + x)`. Clearly a case for rewriting with the\n`add_comm` theorem.\n\nThink about what `rw add_comm` will do. What will happen if you do `rw add_comm` twice? Try this\nbelow and test your conjecture.\n\nWhat happens is that `rw add_comm` looks for an expression of the form `a + b`. It finds one in\n`(x + y) + z`, matching `a` with `x + y` and `b` with `z`. It replaces this with `b + a`. That is,\nwith `z + (x + y)`.\n\nYou might wonder why this is the first match. Why doesn't Lean work on `x + y` first, matching\n`a` with `x` and `b` with `y`? It's because Lean works outside-in, then left-to-right. The second\n`+` operator in `(x + y) + z` is the outermost operator, so is read first by Lean.\n\nThe problem: applying `rw add_comm` to the new goal `\u22a2 z + (x + y) = z + (y + x)` will match `a`\nwith `z` and `b` with `x + y`, rewriting the goal to `\u22a2 (x + y) + z = z + (y + x)`, taking us back\nto where we started!\n\n### Focussing a rewrite with arguments\n\nRecall that `add_comm a b` is the theorem that `a + b = b + a`. The quantities `a` and `b` are\n*arguments* to the theorem `add_comm`.\nEqually, `add_comm x (y + z)` is the theorem that `x + (y + z) = (y + z) + x`. This theorem has\narguments `x` and `y + x`. Note than arguments can be expressions, not just variables.\n\nApplying `rw add_comm x (y + z)` transforms `\u22a2 z + (x + (y + z)) = z` to\n`\u22a2 z + ((y + z) + x) = z`.\n\nUse arguments, where necessary, to prove the theorem below.\n\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "variables (x y z : \u2124) -- Declare `x`, `y`, and `z` to be integers.\n", "\nWhen you start the proof below, Lean displays the target as `\u22a2 x + y + z = z + (y + x)`.\nWhat happened to the parentheses on the left-hand side? Lean treats addition as\n'left associative'. This is a fancy way of saying that `x + y + z` should always be\ninterpreted as `(x + y) + z`.\n", "Missing parentheses?", "Let `x`, `y`, and `z` be integers. Then `(x + y) + z = z + (y + x)`.\n", "end exlean -- hide\n", "## Translation to a hand-written proof\n\nHere's a suggestion. When writing a proof by hand, you need not (and should not) aim at a direct\ntranslation of a Lean proof. Here, I've kept the main idea of each line of my Lean proof while\ntranslating for ease of human understanding.\n\n> Rewriting by additive commutativity, the goal is to prove `z + (x + y) = z + (y + x)`.\n> Rewriting with additive commutativity on `x + y`, the goal is to prove `z + (y + x) = z + (y + x)`.\n> This follows by reflexivity.\n", "import myint.basic equations.commutativity_rw.level -- hide\n", "# Equations\n\n## Level 5: Associativity\n\nTime for a new theorem. This one is called `add_assoc`, which is short for additive associativity.\n\nThe result `add_assoc a b c` states that `(a + b) + c = a + (b + c)`, for all integers `a`, `b`,\nand `c`. You can see the statement in the sidebar on the left by unfolding 'Theorem statements'.\n\nAs with `add_comm`, you can use `add_assoc` to rewrite the goal using `rw add_assoc`.\n\nBelow, your task is to prove `(x + y) + z = x + (z + y)`.\n\n**Before writing a Lean proof**, construct a hand-written proof.\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "(a + b) + c = a + (b + c)\n", "theorem myint.add_assoc (a b c : \u2124) : a + b + c = a + (b + c) := myint.add_assoc' a b c -- hide\n", "open myint\n", "variables (x y z : \u2124) -- hide\n", "\nYou'll need to rewrite with both `add_comm` and `add_assoc`. You may need to give arguments to one\nof your rewrites, as described in the previous level.\n", "Hint", "Let `x`, `y`, and `z` be integers. Then `(x + y) + z = x + (z + y)`.\n", "## Translation to a hand-written proof\n\nIn the following hand-written proof, I omit the word 'rewriting'.\n\n> By associativity, the goal is to prove `x + (y + z) = x + (z + y)`.\n> By commutativity, the goal is to prove `x + (z + y) = x + (z + y)`.\n> This follows by reflexivity.\n", "end exlean -- hide", "import myint.basic equations.associativity.level -- hide\n", "# Equations\n\n## Level 6: Structuring proofs with `have`\n\nThe `have` tactic introduces a hypothesis into the context. It's a way to add structure to your\nproofs, stating and proving intermediate results before using them.\n\nConsider the goal `\u22a2 x + ((x + y) + z) = x + (z + (x + y))`.\n\nOne way to close this goal is to rewrite, giving specific arguments to `add_comm`.\nAnother option is to introduce an intermediate goal of proving `(x + y) + z = z + (x + y)`.\n\nThis is accomplished using `have h : (x + y) + z = z + (x + y)` (followed by a comma). \nThere's nothing special about `h` as the name of the hypothesis. Change it to whatever you wish.\n\nThis opens up a new goal: you'll see 2 goals in right-hand pane. The top goal is the new goal,\nnamely `\u22a2 (x + y) + z = z + (x + y)`. The bottom goal is the old goal, only with a new hypothesis,\n`h : (x + y) + z = z + (x + y)`.\n\nYou first work on closing the new goal, then close the original goal using hypothesis `h`.\n", "\nIf you want to work only on goal, put braces after the `have`. When you're cursor is in the\ninner brace, you'll only be working on the first goal.\n```\nhave h : (x + y) + z = z + (x + y),\n{ sorry },\nsorry\n``` \n", "Focussing on one goal at a time", "`have` is used to introduce a new hypothesis into the context. It opens a new goal for the proof\nof the hypothesis.\n\nFor example, `have h2 : x + y = y + x` introduces a new goal, to prove\n`x + y = y + x` while adding the hypothesis `h2 : x + y = y + x` to the context of the old goal.\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "open myint -- hide\n", "variables (x y z : \u2124) -- hide\n", "Let `x`, `y`, and `z` be integers. Then `x + ((x + y) + z) = x + (z + (x + y)))`.\n", "## Translation to a hand-written proof\n\nIn my hand-written proof below, I omit references to reflexivity.\n\n> I claim `h : (x + y) + z = z + (x + y)`.\n> To prove this, use commutativity of addition.\n> Rewrite the original goal using `h`.\n", "end exlean -- hide", "import myint.basic equations.associativity.level -- hide\n", "# Equations\n\n## Level 7: Multiple rewrites\n\nRather than writing, for example `rw add_assoc x y z, rw add_comm`, you can write\n`rw [add_assoc x y z, add_comm]`. Use this technique, together with `have`, to write a structured\nproof below.\n\nNow write a proof using a long chain of rewrites followed by `refl`. Which proof do you prefer? Why?\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "open myint -- hide\n", "variables (x y z : \u2124) -- hide\n", "Let `x`, `y`, and `z` be integers. Then `x + (y + (x + z)) = (z + (x + y)) + x`.\n", "end exlean -- hide", "Functions", "import mynat.basic -- hide\n", "# Functions\n\n## Level 1: Defining functions\n\nA function is a map from one set, called the domain, to another set, called the codomain.\n\nThe notation `f : S \u2192 T` is read, \"`f` is a function with domain `S` and codomain `T`\" or \"`f` is a\nfunction from `S` to `T`\".\n\nTo specify that `f` maps each `x` to some expression `y`, we write `f : x \u21a6 y` or\n`f(x) = y`, when doing mathematics by hand.\n\nIn Lean, we combine all the above information into:\n```\ndef f : S \u2192 T := \u03bb x, y\n```\nwhere `y` is an expression that depends on `x`. Here `\u03bb` is a Greek letter called lambda.\nIts only significance is to indicate that the following quantity `x` is a variable.\n\nBelow is the definition of a function `my_f` from the set `\u2115` of natural numbers (the non-negative)\nintegers to itself. It takes each `x` to `3 * x + 5`.\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "The function `my_f` is defined so that `my_f (x) = 3 * x + 5` for every \nnatural number `x`.\n", "def my_f : \u2115 \u2192 \u2115 := \u03bb x, 3 * x + 5\n", "Your task is to prove `my_f 10 = 35`. By definition of `my_f`, you must prove `3 * 10 + 5 = 35`.\nIt may come as a surprise to learn that Lean can prove this using `refl`.\nThe reason is that when Lean uses `refl`, it applies definitions until no further simplification is\npossible. For reasons that will become apparent later, the definitions of addition and\nmultiplication can be applied to reduce any 'sum' into a natural number.\n", "The function `my_f` takes `10` to `35`.\n", "end exlean -- hide\n"]]}
{"name": "Pure Mathematics with Lean", "version": "1.4.0", "languages": ["en"], "translated_name": "0", "devmode": false, "library_zip_fn": "Pure Mathematics with Lean-1.4.0-library.zip", "introData": {"name": "", "problemIndex": -1, "objects": [{"type": "text", "content": "1"}]}, "worlds": [{"name": "2", "levels": [{"name": "", "problemIndex": 8, "objects": [{"type": "lean", "content": "3", "hidden": true}, {"type": "text", "content": "4"}, {"type": "tactic", "content": "5", "name": "refl", "sideBar": true}, {"type": "text", "content": "6"}, {"type": "lean", "content": "7", "hidden": true}, {"type": "lean", "content": "8", "hidden": true}, {"type": "lean", "content": "9", "hidden": true}, {"type": "lean", "content": "10", "hidden": false}, {"type": "theorem", "text": "11", "lean": "theorem x_plus_y_eq_x_plus_y : x + y = x + y :=\n", "sideBar": false, "firstProofLineNumber": 66, "lastProofLineNumber": 68, "textBefore": "import myint.basic -- hide\n\n/-\n# Equations\n\n## Level 1: Proving equations through reflexivity\n\nIn the introduction, you read that tactics are used modify the goal, eventually proving \na theorem.\n\nThe `refl` tactic (short for `reflexivity`) can be used to prove any statement of the form\n`?X = ?X`. Here, I use `?X` to stand in for any expression of any type.\nIt could be `8 + 9` or `a * b` or `\"adele\"` or whatever.\n\nBelow, you are asked to prove `x + y = x + y`, where `x` and `y` are integers.\nThe word `sorry` between the `begin` and `end` lines below asks Lean not to give an error message if a\nproof isn't complete. You'll see a <span style=\"color:orange\">warning</span> message in the\nbottom-right hand pane. This indicates you shouldn't trust the proof just yet, as it uses `sorry`!\n\nDelete `sorry` (using the backspace key on your keyboard). In the right-hand pane you'll see:\n```\nx y : \u2124\n\u22a2 x + y = x + y\n```\n\nHere, `x y : \u2124` is the *context*, the set of things you know. In this case, you know `x` and `y`\nare integers.\n\nThe *target* is `\u22a2 x + y = x + y`. The `\u22a2` symbol can be read 'to prove'. So your target is\nto prove `x + y = x + y`.\n\nThe bottom part of the right-hand pane shows an <span style=\"color:red\">error</span>  message:\ntactic failed, there are unsolved goals. Don't panic! It's just telling you that you haven't yet\nproved the result.\n\nYour task is to replace `sorry` with `refl,`. Note the comma at the end of the line!\nIf you're successful, Lean will respond with the message `no goals` or `Proof complete!`\n-/\n\n/- Tactic : refl\nThe `refl` tactic closes any goal of the form `?X = ?X`. That is, it proves any equation where the\nleft and right sides are *definitionally equal*.\n-/\n\n/-\n## Translation to a hand-written proof\n\nIn words, the `refl` says, \"The result holds by reflexivity\". A one-line written proof of\nthe theorem below would be, \"The result hold by reflexivity\".\n\n-/\n\nnamespace exlean -- hide\n\nopen myint -- hide\n\nopen_locale mynum -- hide\n\nvariables (x y : \u2124) -- Declare `x` and `y` to be integers.\n\n/- Theorem : no-side-bar\n`x + y = x + y`, for all integers `x` and `y`.\n-/\ntheorem x_plus_y_eq_x_plus_y : x + y = x + y :=\nbegin\n", "proof": "  refl,\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide\n", "height": 3, "editorText": "sorry", "lineOffset": 65, "name": "x_plus_y_eq_x_plus_y", "statement": "x + y = x + y"}, {"type": "lean", "content": "12", "hidden": true}]}, {"name": "", "problemIndex": 9, "objects": [{"type": "lean", "content": "13", "hidden": true}, {"type": "text", "content": "14"}, {"type": "lean", "content": "15", "hidden": true}, {"type": "lean", "content": "16", "hidden": true}, {"type": "lean", "content": "17", "hidden": true}, {"type": "lean", "content": "18", "hidden": true}, {"type": "axiom", "content": "19", "name": "add_comm (a b : \u2124) :", "sideBar": true}, {"type": "lean", "content": "20", "hidden": true}, {"type": "hint", "content": "21", "title": "22"}, {"type": "theorem", "text": "23", "lean": "theorem x_plus_y_eq_y_plus_x : x + y = y + x :=\n", "sideBar": false, "firstProofLineNumber": 71, "lastProofLineNumber": 72, "textBefore": "import myint.basic -- hide\n\n/-\n# Equations\n\n## Level 2: Commutativity of addition via `rw`\n\nNow we'll prove something (slighlty) more interesting, that `x + y = y + x` for all integers `x`\nand `y`. Try the `refl` tactic below (remember to put a comma after `refl`) and see what happens.\n\nYou'll get an error message:\n```\ninvalid apply tactic, failed to unify\n  x + y = y + x\nwith\n  ?m_2 = ?m_2\n```\n\nLean tells you that you're trying to use `refl` to prove `x + y = y + x`, but it expects a target\nof the form `?m_2 = ?m_2`. There's no special meaning to the underscores here. It's the same as\nwriting `?X = ?X` as in the previous level.\n\nThe problem: even though we 'know' the left and right sides are equal, they are not\n*identically equal*.\nFortunately, Lean comes with a *theorem* of just the right kind. It's called `add_comm`, which is\nshort for additive commutativity.\nThe result `add_comm a b` states that `a + b = b + a`, where `a` and `b` are integers.\n\nTo apply this theorem, we'll use the `rw` (short for `rewrite`) tactic.\n\nReplace the `sorry` below with `rw add_comm` (followed by a comma\u2014I won't mention this from now\non).\n\nLean will look for the first expression in the target that matches the pattern `a + b` and\nreplace every instance of that expression with `b + a`. Here, Lean finds `x + y` and replaces\nit with `y + x`.\n\nEqually, if `h` is an equation of the form `p = q` (where `p` and `q` are expressions),\n`rw h` will cause Lean to look for `p` in the target and replace it with `q`.\n\nHaving issued `rw add_comm`, the goal is to prove `y + x = y + x`.\nYou know how to prove a goal of this kind from the previous level.\nWrite the proof on the line after the `rw add_comm`.\n-/\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\nvariables (x y : \u2124) -- hide\n\nnamespace pre_group -- hide\n\n/- Axiom : add_comm (a b : \u2124) :\na + b = b + a\n-/\ntheorem add_comm (a b : \u2124) : a + b = b + a := myint.add_comm' a b -- hide\n\n/- Hint : Moving through a proof\n\nYour proof of the theorem below will use two lines of code. If you move your cursor to a previous\nline, Lean will show you the tactic state at any point in the proof. If you click on the name of\na theorem, you'll get some brief documentation.\n-/\n\n/- Theorem : no-side-bar\n`x + y = y + x`, for all integers `x` and `y`.\n-/\ntheorem x_plus_y_eq_y_plus_x : x + y = y + x :=\nbegin [pure_maths]\n", "proof": "  rw add_comm,\n  refl,", "proof_hint": "sorry", "textAfter": "\nend\n\nend pre_group -- hide\n\nend exlean -- hide\n\n/-\n## Translation to a hand-written proof\n\nIn words, the `rw add_comm` says, \"Rewrite using commuativity of addition\".\nAs hand-written proofs aren't interactive, it's helpful to mention explicitly any changes to the\ncontext. Here's a hand-written proof of the above result.\n\n> Rewriting using commutativity of addition, the goal is to prove `y + x = y + x`.\n> This follows by reflexivity.\n-/\n\n/- Tactic : rw\nIf `h` is an equation of the form `p = q`, `rw h` rewrites replaces `p` in the target with `q`.\n\nIf `k` is in the context, `rw h at k` performs the rewrite at `k` instead of at the target.\n\n`rw \u2190h` will rewrite backward: every occurrence of `q` is replaced with `p`. Type `\\l` to produce `\u2190`.\n\n`rw [h1, h2, h3]` rewrites with multiple hypotheses (you aren't limited to three)!\n-/\n\n/-\n## Anatomy of a level\n\nEach level contains three vertial panes. The left-hand pane contains a list of the tactics and\ntheorem statements you've seen so far. Click on the arrows to dig deeper.\n\nThe middle pane is the one you're reading now! It contains text and interactive exercises.\nThe right-hand pane contains the Lean Infoview window, showing the 'tactic state' and error messages.\n\nYou can navigate through the book using the buttons in the top horizonal pane. The circular arrow\nresets your progress.\n-/\n\n/-\n## How `rw` here differs from that in standard Lean\n\nThe `rw` tactic used in this book is slightly different the standard `rw`. In particular, if\nthe result of a rewrite is an equation of the form `X = X`, then the standard `rw` tactic will\nautomatically close the goal via reflexivity.\n\nThis automation has been disabled here to help you think more carefully about proof construction.\n-/\n\n", "height": 2, "editorText": "sorry", "lineOffset": 70, "name": "x_plus_y_eq_y_plus_x", "statement": "x + y = y + x"}, {"type": "lean", "content": "24", "hidden": true}, {"type": "lean", "content": "25", "hidden": true}, {"type": "text", "content": "26"}, {"type": "tactic", "content": "27", "name": "rw", "sideBar": true}, {"type": "text", "content": "28"}, {"type": "text", "content": "29"}]}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "30", "hidden": true}, {"type": "text", "content": "31"}, {"type": "lean", "content": "32", "hidden": true}, {"type": "lean", "content": "33", "hidden": true}, {"type": "lean", "content": "34", "hidden": true}, {"type": "lean", "content": "35", "hidden": true}, {"type": "theorem", "text": "36", "lean": "theorem add_eq_add_two_mul_self_of_eq_two_mul (h : y = 2 * x)\n  : x + y = x + 2 * x :=\n", "sideBar": false, "firstProofLineNumber": 46, "lastProofLineNumber": 47, "textBefore": "import myint.basic equations.commutativity_rw -- hide\n\n/-\n# Equations\n\n## Level 3: Rewriting with hypotheses\n\nLook at the theorem below. It seems that you're being asked to prove `x + y = x + 2 * x`.\nSurely that isn't true in general! What's\ngoing on? If you look carefully, you'll see an additional hypothesis, `h : y = 2 * x`.\n\nThe `:` is just notation for naming a hypothesis (also called an assumption).\nSo the statement of the theorem can be read:\n\n> Let `x` and `y` be integers. Let `h` be the hypothesis `y = 2 * x`.\n> Then `x + y = x + 2 * x`.\n\nWhen you start the proof, you'll note in the top-right pane that `h : y = 2 * x` has been\nadded to the context.\n\nYou can use the hypothesis to rewrite the goal by typing `rw h` much as you used `rw add_comm`\nto rewrite via the theorem `add_comm`.\n\n### Tasks\n\n* Before doing the problem in Lean, think about what effect `rw h` will have on the goal.\n\n* Predict what error message Lean will produce if you replace `sorry` with `refl`. Test your\nprediction.\n-/\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\nnamespace pre_group -- hide\n\nvariables (x y : \u2124) -- hide\n\n/- Theorem : no-side-bar\nLet `x` and `y` be integers. Let `h` be the hypothesis `y = 2 * x`. Then `x + y = x + 2 * x`.\n-/\ntheorem add_eq_add_two_mul_self_of_eq_two_mul (h : y = 2 * x)\n  : x + y = x + 2 * x :=\nbegin [pure_maths]\n", "proof": "  rw h,\n  refl,", "proof_hint": "sorry", "textAfter": "\nend\n\nend pre_group -- hide\n\nend exlean -- hide\n\n/-\n## Translation to a hand-written proof\n\n> Rewriting using `h`, the goal is to prove `x + 2 * x = x + 2 * x`.\n> This follows by reflexivity.\n-/\n\n", "height": 2, "editorText": "sorry", "lineOffset": 45, "name": "add_eq_add_two_mul_self_of_eq_two_mul", "statement": "(h : y = 2 * x)\n  : x + y = x + 2 * x"}, {"type": "lean", "content": "37", "hidden": true}, {"type": "lean", "content": "38", "hidden": true}, {"type": "text", "content": "39"}]}, {"name": "", "problemIndex": 7, "objects": [{"type": "lean", "content": "40", "hidden": true}, {"type": "text", "content": "41"}, {"type": "lean", "content": "42", "hidden": true}, {"type": "lean", "content": "43", "hidden": true}, {"type": "lean", "content": "44", "hidden": true}, {"type": "lean", "content": "45", "hidden": false}, {"type": "hint", "content": "46", "title": "47"}, {"type": "theorem", "text": "48", "lean": "theorem add_comm_left_right : (x + y) + z = z + (y + x) :=\n", "sideBar": false, "firstProofLineNumber": 66, "lastProofLineNumber": 68, "textBefore": "import myint.basic equations.commutativity_rw-- hide\n\n/-\n# Equations\n\n## Level 4: Focussed rewriting\n\nHere, you're asked to prove `(x + y) + z = z + (y + x)`. Clearly a case for rewriting with the\n`add_comm` theorem.\n\nThink about what `rw add_comm` will do. What will happen if you do `rw add_comm` twice? Try this\nbelow and test your conjecture.\n\nWhat happens is that `rw add_comm` looks for an expression of the form `a + b`. It finds one in\n`(x + y) + z`, matching `a` with `x + y` and `b` with `z`. It replaces this with `b + a`. That is,\nwith `z + (x + y)`.\n\nYou might wonder why this is the first match. Why doesn't Lean work on `x + y` first, matching\n`a` with `x` and `b` with `y`? It's because Lean works outside-in, then left-to-right. The second\n`+` operator in `(x + y) + z` is the outermost operator, so is read first by Lean.\n\nThe problem: applying `rw add_comm` to the new goal `\u22a2 z + (x + y) = z + (y + x)` will match `a`\nwith `z` and `b` with `x + y`, rewriting the goal to `\u22a2 (x + y) + z = z + (y + x)`, taking us back\nto where we started!\n\n### Focussing a rewrite with arguments\n\nRecall that `add_comm a b` is the theorem that `a + b = b + a`. The quantities `a` and `b` are\n*arguments* to the theorem `add_comm`.\nEqually, `add_comm x (y + z)` is the theorem that `x + (y + z) = (y + z) + x`. This theorem has\narguments `x` and `y + x`. Note than arguments can be expressions, not just variables.\n\nApplying `rw add_comm x (y + z)` transforms `\u22a2 z + (x + (y + z)) = z` to\n`\u22a2 z + ((y + z) + x) = z`.\n\n### Tasks\n* Think about what would happen if you replaced `sorry` with `rw z y`. Try it out. Explain the\nresulting error message.\n\n* Use arguments, where necessary, to prove the theorem below.\n\n\n-/\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\nnamespace pre_group -- hide\n\nvariables (x y z : \u2124) -- Declare `x`, `y`, and `z` to be integers.\n\n/- Hint : Missing parentheses?\n\nWhen you start the proof below, Lean displays the target as `\u22a2 x + y + z = z + (y + x)`.\nWhat happened to the parentheses on the left-hand side? Lean treats addition as\n'left associative'. This is a fancy way of saying that `x + y + z` should always be\ninterpreted as `(x + y) + z`.\n-/\n\n/- Theorem : no-side-bar\nLet `x`, `y`, and `z` be integers. Then `(x + y) + z = z + (y + x)`.\n-/\ntheorem add_comm_left_right : (x + y) + z = z + (y + x) :=\nbegin [pure_maths]\n", "proof": "  rw add_comm,\n  rw add_comm x y,\n  refl,", "proof_hint": "sorry", "textAfter": "\nend\n\nend pre_group -- hide\n\nend exlean -- hide\n\n/-\n## Translation to a hand-written proof\n\nHere's a suggestion. When writing a proof by hand, you need not (and should not) aim at a direct\ntranslation of a Lean proof. Here, I've kept the main idea of each line of my Lean proof while\ntranslating for ease of human understanding.\n\n> Rewriting by additive commutativity, the goal is to prove `z + (x + y) = z + (y + x)`.\n> Rewriting with additive commutativity on `x + y`, the goal is to prove `z + (y + x) = z + (y + x)`.\n> This follows by reflexivity.\n-/\n\n", "height": 3, "editorText": "sorry", "lineOffset": 65, "name": "add_comm_left_right", "statement": "(x + y) + z = z + (y + x)"}, {"type": "lean", "content": "49", "hidden": true}, {"type": "lean", "content": "50", "hidden": true}, {"type": "text", "content": "51"}]}, {"name": "", "problemIndex": 10, "objects": [{"type": "lean", "content": "52", "hidden": true}, {"type": "text", "content": "53"}, {"type": "lean", "content": "54", "hidden": true}, {"type": "lean", "content": "55", "hidden": true}, {"type": "lean", "content": "56", "hidden": true}, {"type": "axiom", "content": "57", "name": "add_assoc (a b c : \u2124) :", "sideBar": true}, {"type": "lean", "content": "58", "hidden": true}, {"type": "lean", "content": "59", "hidden": false}, {"type": "text", "content": "60"}, {"type": "hint", "content": "61", "title": "62"}, {"type": "theorem", "text": "63", "lean": "theorem add_right_comm (x y z : \u2124) : (x + y) + z = (x + z) + y :=\n", "sideBar": true, "firstProofLineNumber": 56, "lastProofLineNumber": 59, "textBefore": "import myint.basic equations.commutativity_rw -- hide\n\n/-\n# Equations\n\n## Level 5: Associativity\n\nTime for a new theorem. This one is called `add_assoc`, which is short for additive associativity.\n\nThe result `add_assoc a b c` states that `(a + b) + c = a + (b + c)`, for all integers `a`, `b`,\nand `c`. You can see the statement in the sidebar on the left by unfolding 'Theorem statements'.\n\nAs with `add_comm`, you can use `add_assoc` to rewrite the goal using `rw add_assoc`.\n\nBelow, your task is to prove `(x + y) + z = x + (z + y)`. In future levels, this theorem will\nbe available as `add_right_comm`.\n\n**Before writing a Lean proof**, construct a hand-written proof.\n-/\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\nnamespace pre_group -- hide\n\n/- Axiom : add_assoc (a b c : \u2124) :\n(a + b) + c = a + (b + c)\n-/\ntheorem myint.add_assoc (a b c : \u2124) : a + b + c = a + (b + c) := myint.add_assoc' a b c -- hide\n\nopen myint\n\n/-\n### Tasks\n\n* Think about what would happen if you performed `rw add_assoc` once, twice, and thrice.\n  Try it out and compare with your predication.\n\n* Prove the theorem below.\n\n-/\n\n\n/- Hint : Hint\n\nYou'll need to rewrite with both `add_comm` and `add_assoc`. You may need to give arguments to one\nof your rewrites, as described in the previous level.\n-/\n\n/- Theorem : \nLet `x`, `y`, and `z` be integers. Then `(x + y) + z = x + (z + y)`.\n-/\ntheorem add_right_comm (x y z : \u2124) : (x + y) + z = (x + z) + y :=\nbegin [pure_maths]\n", "proof": "  rw add_assoc,\n  rw add_comm y z,\n  rw add_assoc,\n  refl,", "proof_hint": "sorry", "textAfter": "\nend\n\n/-\n## Translation to a hand-written proof\n\nIn the following hand-written proof, I omit the word 'rewriting'.\n\n> By associativity, the goal is to prove `x + (y + z) = x + (z + y)`.\n> By commutativity, the goal is to prove `x + (z + y) = x + (z + y)`.\n> This follows by reflexivity.\n-/\n\nend pre_group -- hide\n\nend exlean -- hide", "height": 4, "editorText": "sorry", "lineOffset": 55, "name": "add_right_comm", "statement": "(x y z : \u2124) : (x + y) + z = (x + z) + y"}, {"type": "text", "content": "64"}, {"type": "lean", "content": "65", "hidden": true}, {"type": "lean", "content": "66", "hidden": true}]}, {"name": "", "problemIndex": 9, "objects": [{"type": "lean", "content": "67", "hidden": true}, {"type": "text", "content": "68"}, {"type": "hint", "content": "69", "title": "70"}, {"type": "tactic", "content": "71", "name": "have", "sideBar": true}, {"type": "lean", "content": "72", "hidden": true}, {"type": "lean", "content": "73", "hidden": true}, {"type": "lean", "content": "74", "hidden": true}, {"type": "lean", "content": "75", "hidden": true}, {"type": "lean", "content": "76", "hidden": true}, {"type": "theorem", "text": "77", "lean": "theorem add_left_comm_comm : x + ((x + y) + z) = x + (z + (x + y)) :=\n", "sideBar": false, "firstProofLineNumber": 61, "lastProofLineNumber": 63, "textBefore": "import myint.basic equations.associativity -- hide\n\n/-\n# Equations\n\n## Level 6: Structuring proofs with `have`\n\nThe `have` tactic introduces a hypothesis into the context. It's a way to add structure to your\nproofs, stating and proving intermediate results before using them.\n\nConsider the goal `\u22a2 x + ((x + y) + z) = x + (z + (x + y))`.\n\nOne way to close this goal is to rewrite, giving specific arguments to `add_comm`.\nAnother option is to introduce an intermediate goal of proving `(x + y) + z = z + (x + y)`.\n\nThis is accomplished using `have h : (x + y) + z = z + (x + y)` (followed by a comma). \nThere's nothing special about `h` as the name of the hypothesis. Change it to whatever you wish.\n\nThis opens up a new goal: you'll see 2 goals in right-hand pane. The top goal is the new goal,\nnamely `\u22a2 (x + y) + z = z + (x + y)`. The bottom goal is the old goal, only with a new hypothesis,\n`h : (x + y) + z = z + (x + y)`.\n\nYou first work on closing the new goal, then close the original goal using hypothesis `h`.\n-/\n\n/- Hint : Focussing on one goal at a time\n\nIf you want to work only on goal, put braces after the `have`. When you're cursor is in the\ninner brace, you'll only be working on the first goal.\n```\nhave h : (x + y) + z = z + (x + y),\n{ sorry },\nsorry\n``` \n-/\n\n/- Tactic : have\n`have` is used to introduce a new hypothesis into the context. It opens a new goal for the proof\nof the hypothesis.\n\n### Example\n`have h2 : x + y = y + x` introduces a new goal, to prove\n`x + y = y + x` while adding the hypothesis `h2 : x + y = y + x` to the context of the old goal.\n-/\n\nnamespace exlean -- hide\n\nnamespace pre_group -- hide\n\nopen_locale mynum -- hide\n\nopen myint -- hide\n\nvariables (x y z : \u2124) -- hide\n\n/- Theorem : no-side-bar\nLet `x`, `y`, and `z` be integers. Then `x + ((x + y) + z) = x + (z + (x + y)))`.\n-/\ntheorem add_left_comm_comm : x + ((x + y) + z) = x + (z + (x + y)) :=\nbegin [pure_maths]\n", "proof": "  have h : (x + y) + z = z + (x + y),\n  rw add_comm, refl,\n  rw h, refl,", "proof_hint": "sorry", "textAfter": "\nend\n\n/-\n## Translation to a hand-written proof\n\nIn my hand-written proof below, I omit references to reflexivity.\n\n> I claim `h : (x + y) + z = z + (x + y)`.\n> To prove this, use commutativity of addition.\n> Rewrite the original goal using `h`.\n-/\n\nend pre_group -- hide\n\nend exlean -- hide", "height": 3, "editorText": "sorry", "lineOffset": 60, "name": "add_left_comm_comm", "statement": "x + ((x + y) + z) = x + (z + (x + y))"}, {"type": "text", "content": "78"}, {"type": "lean", "content": "79", "hidden": true}, {"type": "lean", "content": "80", "hidden": true}]}, {"name": "", "problemIndex": 7, "objects": [{"type": "lean", "content": "81", "hidden": true}, {"type": "text", "content": "82"}, {"type": "lean", "content": "83", "hidden": true}, {"type": "lean", "content": "84", "hidden": true}, {"type": "lean", "content": "85", "hidden": true}, {"type": "lean", "content": "86", "hidden": true}, {"type": "lean", "content": "87", "hidden": true}, {"type": "theorem", "text": "88", "lean": "theorem add_comm_adele : x + (y + (x + z)) = (z + (x + y)) + x :=\n", "sideBar": false, "firstProofLineNumber": 33, "lastProofLineNumber": 35, "textBefore": "import myint.basic equations.associativity -- hide\n\n/-\n# Equations\n\n## Level 7: Multiple rewrites\n\nRather than writing, for example `rw add_assoc x y z, rw add_comm`, you can write\n`rw [add_assoc x y z, add_comm]`.\n\n### Tasks\n\n* Use this technique, together with `have`, to write a structured proof below.\n\n* Now write a proof using a long chain of rewrites followed by `refl`. Which proof do you prefer? Why?\n-/\n\nnamespace exlean -- hide\n\nnamespace pre_group -- hide\n\nopen_locale mynum -- hide\n\nopen myint -- hide\n\nvariables (x y z : \u2124) -- hide\n\n/- Theorem : no-side-bar\nLet `x`, `y`, and `z` be integers. Then `x + (y + (x + z)) = (z + (x + y)) + x`.\n-/\ntheorem add_comm_adele : x + (y + (x + z)) = (z + (x + y)) + x :=\nbegin [pure_maths]\n", "proof": "  have h : y + (x + z) = z + (x + y),\n    rw add_comm, rw add_comm x, rw add_assoc, refl,\n  rw h, rw add_comm, refl,", "proof_hint": "sorry", "textAfter": "\nend\n\nend pre_group -- hide\n\nend exlean -- hide", "height": 3, "editorText": "sorry", "lineOffset": 32, "name": "add_comm_adele", "statement": "x + (y + (x + z)) = (z + (x + y)) + x"}, {"type": "lean", "content": "89", "hidden": true}, {"type": "lean", "content": "90", "hidden": true}]}, {"name": "", "problemIndex": 15, "objects": [{"type": "lean", "content": "91", "hidden": true}, {"type": "text", "content": "92"}, {"type": "lean", "content": "93", "hidden": true}, {"type": "lean", "content": "94", "hidden": true}, {"type": "lean", "content": "95", "hidden": true}, {"type": "lean", "content": "96", "hidden": true}, {"type": "lean", "content": "97", "hidden": true}, {"type": "text", "content": "98"}, {"type": "lean", "content": "99", "hidden": false}, {"type": "lean", "content": "100", "hidden": true}, {"type": "lean", "content": "101", "hidden": false}, {"type": "lean", "content": "102", "hidden": true}, {"type": "lean", "content": "103", "hidden": false}, {"type": "text", "content": "104"}, {"type": "hint", "content": "105", "title": "106"}, {"type": "theorem", "text": "107", "lean": "theorem funky_town\n(h : (z + x) + y = y + z * x) : y + z * x = y + (z + x) :=\n", "sideBar": false, "firstProofLineNumber": 61, "lastProofLineNumber": 67, "textBefore": "import myint.basic equations.multiple_rewrites -- hide\n\n/-\n# Equations\n\n## Level 8: Backward rewrites\n\nSuppose you wanted to prove `y + x = 0` on the assumptions `h1 : x + 0 = 0` and `h2 : y = 0`.\nOne option would be to rewrite with `h2` to give `\u22a2 0 + x = 0`. You could then finish by\nrewriting with `add_comm` and `h1`.\n\nAnother option is to start by rewriting with `h1` *backward*. This would replace `0`\nin the target with `x + 0`. To do this in Lean, type `rw \u2190h1`.\n\nTo get the left arrow, type `\\l` followed by space or tab. Alternatively, just type `<-`\n-/\n\nnamespace exlean -- hide\n\nnamespace pre_group -- hide\n\nopen_locale mynum -- hide\n\nopen myint -- hide\n\nvariables (x y z : \u2124) -- hide\n\n/-\nHere is a proof of this result, using three rewrites, one backward.\n-/\n\nexample (h1 : x + 0 = 0) (h2 : y = 0) : y + x = 0 :=\nbegin\n  [pure_maths] -- hide\n  rw [\u2190h1, add_comm, h2],\n  refl,\n\n-- hide  \nend\n\n/-\n### Tasks\n* Prove the following using two rewrites, one backward.\n\n* Once you've done that, write a structured proof of the same result.\n-/\n\n/- Hint: Hint for structured proof\n\nIntroduce and prove the hypotheses `h2 : y + z * x = (z + x) + y` and\n`h3 : (z + x) + y = y + (z + x)` using the `have` tactic. Finish by rewriting with these\nhypotheses.\n-/\n\n/- Theorem : no-side-bar\nLet `x`, `y`, and `z` be integers. If `(z + x) + y = y + z * x`, then `y + z * x = y + (z + x)`\n-/\ntheorem funky_town\n(h : (z + x) + y = y + z * x) : y + z * x = y + (z + x) :=\nbegin [pure_maths]\n", "proof": "  rw [\u2190h, add_comm],\n  refl,\n/-   have h2 : y + z * x = (z + x) + y,\n  { rw h, refl },\n  have h3 : (z + x) + y = y + (z + x),\n  { rw add_comm, refl },\n  rw [h2, h3], refl,  -/", "proof_hint": "sorry", "textAfter": "\nend\n\nend pre_group -- hide\n\nend exlean -- hide", "height": 7, "editorText": "sorry", "lineOffset": 60, "name": "funky_town", "statement": "(h : (z + x) + y = y + z * x) : y + z * x = y + (z + x)"}, {"type": "lean", "content": "108", "hidden": true}, {"type": "lean", "content": "109", "hidden": true}]}, {"name": "", "problemIndex": 11, "objects": [{"type": "lean", "content": "110", "hidden": true}, {"type": "text", "content": "111"}, {"type": "lean", "content": "112", "hidden": true}, {"type": "lean", "content": "113", "hidden": true}, {"type": "lean", "content": "114", "hidden": true}, {"type": "lean", "content": "115", "hidden": true}, {"type": "axiom", "content": "116", "name": "add_zero (a : \u2124) :", "sideBar": true}, {"type": "lean", "content": "117", "hidden": true}, {"type": "text", "content": "118"}, {"type": "tactic", "content": "119", "name": "exact", "sideBar": true}, {"type": "hint", "content": "120", "title": "121"}, {"type": "theorem", "text": "122", "lean": "theorem zero_add (a : \u2124) : 0 + a = a :=\n", "sideBar": true, "firstProofLineNumber": 55, "lastProofLineNumber": 58, "textBefore": "import myint.basic equations.backward_rewrite -- hide\n\n/-\n# Equations\n\n## Level 9: Additive identity\n\nThe Lean theorem `add_zero` states that `x + 0 = x` for every integer `x`. In mathematics, this\nproperty is called (right) additive identity. Note `add_zero` should appear as a 'Theorem statement'\nin the left-hand pane. \n-/\n\nnamespace exlean -- hide\n\nnamespace pre_group -- hide\n\nopen_locale mynum -- hide\n\nopen myint -- hide\n\n/- Axiom : add_zero (a : \u2124) :\na + 0 = a\n-/\ntheorem add_zero (a : \u2124) : a + 0 = a := myint.add_zero' a -- hide\n\n/- \nYour goal is to prove `zero_add`, the right additive identity property, using `add_zero`.\nOnce you've done this, `zero_add` will be available to you in future levels.\n\nYou can use a series of rewrites and a `refl` or you can use a `rw` and the `exact` tactic, as\ndescrbed in the drop-down box below.\n\nAs always, construct a hand-written proof **before** writing your Lean proof.\n-/\n\n/- Tactic : exact\nIf `h` an expression (or the name of a hypothesis or theorem) that exactly matches the target,\nthen `exact h` will close the current goal.\n-/\n\n/- Hint : The `exact` tactic.\nThe `exact` tactic can be used in place of `rw` where a hypothesis or theorem *exactly*\nmatches the target.\n\nThus, the goal `\u22a2 (x + y) + z = x + (y + z)` is closed with `exact add_assoc x y z`.\n\nLikewise, if `h : x + y + 5 = 10`, then `\u22a2 x + y + 5 = 10` is closed with `exact h`.\n-/\n\n/- Theorem :\n`0 + a = a` for every integer `a`.\n-/\ntheorem zero_add (a : \u2124) : 0 + a = a :=\nbegin [pure_maths]\n", "proof": "  rw add_comm,\n  exact add_zero a,\n\n  ", "proof_hint": "sorry", "textAfter": "\nend\n\nend pre_group -- hide\n\nend exlean -- hide", "height": 4, "editorText": "sorry", "lineOffset": 54, "name": "zero_add", "statement": "(a : \u2124) : 0 + a = a"}, {"type": "lean", "content": "123", "hidden": true}, {"type": "lean", "content": "124", "hidden": true}]}, {"name": "", "problemIndex": 9, "objects": [{"type": "lean", "content": "125", "hidden": true}, {"type": "text", "content": "126"}, {"type": "lean", "content": "127", "hidden": true}, {"type": "lean", "content": "128", "hidden": true}, {"type": "lean", "content": "129", "hidden": true}, {"type": "lean", "content": "130", "hidden": true}, {"type": "lean", "content": "131", "hidden": true}, {"type": "text", "content": "132"}, {"type": "tactic", "content": "133", "name": "specialize", "sideBar": true}, {"type": "theorem", "text": "134", "lean": "theorem two_add_five_eq_eight_add_five_of (h : \u2200 x, x + 5 = 10)\n  : 2 + 5 = 8 + 5 :=\n", "sideBar": false, "firstProofLineNumber": 72, "lastProofLineNumber": 75, "textBefore": "import myint.basic equations.additive_identity -- hide\n\n/-\n# Equations\n\n## Level 10: Universal statements\n\nSo far, our hypotheses have made reference to specific variables. The hypothesis `h : x + 3 = 5`\nstates `x + 3 = 5` for the particular variable `x`.\n\nIf we want a statement that holds *for every* value of a variable, we use the *universal quantifier*\n`\u2200`. This is read, \"for all\" or \"for every\" and is typed `\\all`.\n\nFor example, `\u2200 (x : \u2124), x + 5 = 10` states that `x + 5 = 10` *for every* integer `x`. Of course,\nthis is a false statement! A statement that begins with `\u2200` is called a\n*universally quantified statement*.\n\nHere's how to *use* a universally quantified statement. Given the hypothesis\n`h : \u2200 (x : \u2124), x + 5 = 10`, the expression `h 3` corresponds to `3 + 5 = 10`.\nIt's what we get by replacing `x` with `3` in the body of the statement.\n\nIf `3 + 5` appears in the target, then `rw h 3` replaces `3 + 5` with `10`.\n\n### The specialize tactic\n\nThe `specialize` tactic specializes a universally quantified statement. For example if\n`h : \u2200 (x : \u2124), x + 5 = 10`, then `specialize h 20` *replaces* `h` with\n`h : 20 + 5 = 10`. However, after using `specialize`, you can't go back to the more general\nversion of `h`.\n-/\n\nnamespace exlean -- hide\n\nnamespace pre_group -- hide\n\nopen_locale mynum -- hide\n\nopen myint -- hide\n\nvariable (x : \u2124) -- hide\n\n/-\n\n### Tasks\n\nHere, you'll prove the unusual result `2 + 5 = 8 + 5` on the assumption `\u2200 x, x + 5 = 10`.\n\n\n* Write a proof using `rw`.\n\n* Write another proof where you use one `rw` and one application of `specialize`.\n\n* Think about how you'd write this proof by hand. Compare with my suggested translation at the bottom\nof the page.\n-/\n\n/- Tactic : specialize\nLet the hypothesis `h` be a universally-quantified statement. For example,\n`h : \u2200 (x : \u2124), x + 5 = 10`.\nThen `specialize h 8` replaces `x` with `8` in the body of `h`. Thus `h` becomes `8 + 5 = 10`.\n\nYou can specialize on more than one variable at a time. If `k : \u2200 (x y : \u2124), x + y = y * x`, then\n`specialize k 2 3` replaces `h` with `h : 2 + 3 = 3 * 2`.\n-/\n\n/- Theorem : no-side-bar\n`2 + 5 = 8 + 5` on the assumption `\u2200 x, x + 5 = 10`.\n-/\ntheorem two_add_five_eq_eight_add_five_of (h : \u2200 x, x + 5 = 10)\n  : 2 + 5 = 8 + 5 :=\nbegin [pure_maths]\n", "proof": "  rw [h 2, h 8],\n  refl,\n\n  ", "proof_hint": "sorry", "textAfter": "\nend\n\n/-\n## Translation to a hand-written proof\n\n> Using `h` with `2` in space of `x`, we must show `10 = 8 + 5`.\n> But this follows on taking `x` to be `8` in `h`.\n-/\n\nend pre_group -- hide\n\nend exlean -- hide", "height": 4, "editorText": "sorry", "lineOffset": 71, "name": "two_add_five_eq_eight_add_five_of", "statement": "(h : \u2200 x, x + 5 = 10)\n  : 2 + 5 = 8 + 5"}, {"type": "text", "content": "135"}, {"type": "lean", "content": "136", "hidden": true}, {"type": "lean", "content": "137", "hidden": true}]}, {"name": "", "problemIndex": 9, "objects": [{"type": "lean", "content": "138", "hidden": true}, {"type": "text", "content": "139"}, {"type": "lean", "content": "140", "hidden": true}, {"type": "lean", "content": "141", "hidden": true}, {"type": "lean", "content": "142", "hidden": true}, {"type": "lean", "content": "143", "hidden": true}, {"type": "text", "content": "144"}, {"type": "lean", "content": "145", "hidden": false}, {"type": "hint", "content": "146", "title": "147"}, {"type": "theorem", "text": "148", "lean": "theorem right_additive_identity_unique (e : \u2124)\n  (h : \u2200 (x : \u2124), x + e = x) : e = 0 :=\n", "sideBar": false, "firstProofLineNumber": 48, "lastProofLineNumber": 50, "textBefore": "import myint.basic equations.additive_identity -- hide\n\n/-\n# Equations\n\n## Level 11: Uniqueness of additive identity\n\nIn a previous level, we saw that there's an integer `0` with the property that\n`x + 0 = x` for every `x`.\n\nIn this level, you'll show that `0` is the *only* integer that satisfies this property.\n-/\n\nnamespace exlean -- hide\n\nnamespace pre_group -- hide\n\nopen_locale mynum -- hide\n\nopen myint -- hide\n\n/-\n### Rewriting at a hypothesis\n\nBy default, `rw add_assoc` (say) applies `add_assoc` to the target. If `h` is a hypothesis in the\nlocal context, `rw add_assoc at h` will rewrite `h` using `add_assoc`.\n\nIn the example below, we rewrite at `h` and finish with `exact`. Alternatively, we could have\nperformed a backward `rw` at the target using `rw \u2190add_assoc`.\n-/\n\nexample (x y z : \u2124) (h : (x + y) + z = 20) : x + (y + z) = 20 :=\nbegin\n  rw add_assoc at h,\n  exact h,\nend\n\n/- Hint : Hint\nUse the `specialize` tactic.\n-/\n\n/- Theorem : no-side-bar\nLet `e` be an integer satsifying the property `\u2200 (x : \u2124), x + e = x`. Then `e` must be `0`.\n-/\ntheorem right_additive_identity_unique (e : \u2124)\n  (h : \u2200 (x : \u2124), x + e = x) : e = 0 :=\nbegin [pure_maths]\n", "proof": "  specialize h 0,\n  rw zero_add at h,\n  exact h,", "proof_hint": "sorry", "textAfter": "\nend\n\nend pre_group -- hide\n\nend exlean -- hide", "height": 3, "editorText": "sorry", "lineOffset": 47, "name": "right_additive_identity_unique", "statement": "(e : \u2124)\n  (h : \u2200 (x : \u2124), x + e = x) : e = 0"}, {"type": "lean", "content": "149", "hidden": true}, {"type": "lean", "content": "150", "hidden": true}]}, {"name": "", "problemIndex": 11, "objects": [{"type": "lean", "content": "151", "hidden": true}, {"type": "text", "content": "152"}, {"type": "lean", "content": "153", "hidden": true}, {"type": "lean", "content": "154", "hidden": true}, {"type": "lean", "content": "155", "hidden": true}, {"type": "lean", "content": "156", "hidden": true}, {"type": "axiom", "content": "157", "name": "add_left_neg (a : \u2124) :", "sideBar": true}, {"type": "lean", "content": "158", "hidden": true}, {"type": "axiom", "content": "159", "name": "add_right_neg (a : \u2124) :", "sideBar": true}, {"type": "lean", "content": "160", "hidden": true}, {"type": "hint", "content": "161", "title": "162"}, {"type": "theorem", "text": "163", "lean": "theorem add_add_neg (x y : \u2124) : (x + y) + (-x) = y :=\n", "sideBar": true, "firstProofLineNumber": 43, "lastProofLineNumber": 46, "textBefore": "import myint.basic equations.unique_additive_identity -- hide\n\n/-\n# Equations\n\n## Level 12: Additive inverse\n\nThe Lean theorem `add_left_neg` states that `(-a) + a = 0` for every integer `a`. In mathematics,\nthis property is called (left) additive inverse.\n\nLikewise `add_right_neg (a : \u2124) : a + (-a) = 0`.\n\nYou'll use one of these properties in proving the next result.\n-/\n\nnamespace exlean -- hide\n\nnamespace pre_group -- hide\n\nopen_locale mynum -- hide\n\nopen myint -- hide\n\n/- Axiom : add_left_neg (a : \u2124) :\n(-a) + a = 0\n-/\ntheorem add_left_neg (a : \u2124) : (-a) + a = 0  := myint.add_left_neg a -- hide\n\n/- Axiom : add_right_neg (a : \u2124) :\na + (-a) = 0\n-/\ntheorem add_right_neg (a : \u2124) : a + (-a) = 0  := myint.add_right_neg a -- hide\n\n/- Hint : Hint\nYou might find it useful to use the previously-proved theorem `add_right_comm`.\n-/\n\n/- Theorem :\nFor all integers `x` and `y`, we have `(x + y) + -x = y`.\n-/\ntheorem add_add_neg (x y : \u2124) : (x + y) + (-x) = y :=\nbegin [pure_maths]\n", "proof": "  rw add_right_comm,\n  rw add_right_neg,\n  rw zero_add,\n  refl,", "proof_hint": "sorry", "textAfter": "\nend\n\nend pre_group -- hide\n\nexport pre_group (add_add_neg) -- hide\n\nend exlean -- hide", "height": 4, "editorText": "sorry", "lineOffset": 42, "name": "add_add_neg", "statement": "(x y : \u2124) : (x + y) + (-x) = y"}, {"type": "lean", "content": "164", "hidden": true}, {"type": "lean", "content": "165", "hidden": true}, {"type": "lean", "content": "166", "hidden": true}]}, {"name": "", "problemIndex": 7, "objects": [{"type": "lean", "content": "167", "hidden": true}, {"type": "text", "content": "168"}, {"type": "lean", "content": "169", "hidden": true}, {"type": "lean", "content": "170", "hidden": true}, {"type": "lean", "content": "171", "hidden": true}, {"type": "lean", "content": "172", "hidden": true}, {"type": "hint", "content": "173", "title": "174"}, {"type": "theorem", "text": "175", "lean": "theorem eq_zero_of_add_right_eq_self (a b : \u2124) (h : a + b = a)\n  : b = 0 :=\n", "sideBar": false, "firstProofLineNumber": 40, "lastProofLineNumber": 45, "textBefore": "import myint.basic equations.additive_inverse -- hide\n\n/-\n# Equations\n\n## Level 13: Cancellation I\n\nRecall the (right) uniqueness of additive identity. Let `y` be an integer. If for every integer `x`,\nwe have `x + y = x`, then `y = 0`.\n\nIn this level, we'll prove a theorem that is subtly different. Let `y` and `x` be integers. If\n`x + y = x`, then `y = 0`.\n\n**Question**: how does this new statement differ from from the uniqueness of additive identity?\n\nThe new result cannot be proved using only additive identity. You'll need to use the\nadditive inverse property.\n\nThis may be the most challenging level so far.\n-/\n\nnamespace exlean -- hide\n\nnamespace pre_group -- hide\n\nopen_locale mynum -- hide\n\nopen myint -- hide\n\n/- Hint : Hint\nUse `add_add_neg`.\n-/\n\n/- Theorem : no-side-bar\nIf `a + b = a`, then `b = 0`.\n-/\ntheorem eq_zero_of_add_right_eq_self (a b : \u2124) (h : a + b = a)\n  : b = 0 :=\nbegin [pure_maths]\n", "proof": "  have h2 : (a + b) + (-a) = b,\n  { rw add_add_neg, refl,  },\n  rw \u2190 h2,\n  rw h,\n  exact add_right_neg a,\n  ", "proof_hint": "sorry", "textAfter": "\nend\n\nend pre_group -- hide\n\nend exlean -- hide", "height": 6, "editorText": "sorry", "lineOffset": 39, "name": "eq_zero_of_add_right_eq_self", "statement": "(a b : \u2124) (h : a + b = a)\n  : b = 0"}, {"type": "lean", "content": "176", "hidden": true}, {"type": "lean", "content": "177", "hidden": true}]}, {"name": "", "problemIndex": 7, "objects": [{"type": "lean", "content": "178", "hidden": true}, {"type": "text", "content": "179"}, {"type": "lean", "content": "180", "hidden": true}, {"type": "lean", "content": "181", "hidden": true}, {"type": "lean", "content": "182", "hidden": true}, {"type": "lean", "content": "183", "hidden": true}, {"type": "hint", "content": "184", "title": "185"}, {"type": "theorem", "text": "186", "lean": "theorem right_additive_inverse_unique (x y : \u2124) (h : x + y = 0)\n  : y = -x :=\n", "sideBar": false, "firstProofLineNumber": 30, "lastProofLineNumber": 33, "textBefore": "import myint.basic equations.cancellation_i -- hide\n\n/-\n# Equations\n\n## Level 14: Uniqueness of additive inverse\n\nWe've seen the uniqueness of (right) additive identity. Now we'll show the uniqueness of (right)\nadditive inverse.\n-/\n\nnamespace exlean -- hide\n\nnamespace pre_group -- hide\n\nopen_locale mynum -- hide\n\nopen myint -- hide\n\n/- Hint : Hint\nUse `add_add_neg`.\n-/\n\n/- Theorem : no-side-bar\nLet `x` and `y` be integers. If `x + y = 0`, then `y = -x`. \n-/\ntheorem right_additive_inverse_unique (x y : \u2124) (h : x + y = 0)\n  : y = -x :=\nbegin [pure_maths]\n", "proof": "  rw \u2190add_add_neg x y,\n  rw h,\n  rw zero_add,\n  refl,", "proof_hint": "sorry", "textAfter": "\nend\n\nend pre_group -- hide\n\nend exlean -- hide", "height": 4, "editorText": "sorry", "lineOffset": 29, "name": "right_additive_inverse_unique", "statement": "(x y : \u2124) (h : x + y = 0)\n  : y = -x"}, {"type": "lean", "content": "187", "hidden": true}, {"type": "lean", "content": "188", "hidden": true}]}, {"name": "", "problemIndex": 8, "objects": [{"type": "lean", "content": "189", "hidden": true}, {"type": "text", "content": "190"}, {"type": "lean", "content": "191", "hidden": true}, {"type": "lean", "content": "192", "hidden": true}, {"type": "lean", "content": "193", "hidden": true}, {"type": "lean", "content": "194", "hidden": true}, {"type": "lean", "content": "195", "hidden": false}, {"type": "text", "content": "196"}, {"type": "theorem", "text": "197", "lean": "theorem ymca (x y z : \u2124)\n  : (y + x) + (0 + z + 0) + (0 + x + 0) = y + (z + (x + x)) :=\n", "sideBar": false, "firstProofLineNumber": 45, "lastProofLineNumber": 53, "textBefore": "import myint.basic equations.unique_additive_inverse -- hide\n\n/-\n# Equations\n\n## Level 15: The simplifier\n\nThis level introduces a powerful new tactic, `simp`, Lean's simplifier. It rewrites \nrepeatedly using either supplied theorems & hypotheses or theorems that it 'knows'.\n\nTo suggest theorems and hypotheses for use with `simp`, provide them as a comma-separated list.\nIn the example below, we supply `simp` with `add_assoc` and `add_comm y x`.\n\nWithout `simp`, you'd need several applications of `rw add_assoc`. \n-/\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\nnamespace pre_group -- hide\n\nopen myint -- hide\n\nexample (x y z : \u2124) : x + ((y + z) + x) = (y + x) + (z + x) :=\nbegin\n  simp [add_assoc, add_comm y x],\nend\n\n/-\n### Tasks\n\n* Prove the result below using only `simp` with supplied theorems, as in the example above. You should\nonly need to supply four theorems.\n\n* For fun (!) try proving this result using `rw`. Which proof do you prefer?\n-/\n\n/- Theorem : no-side-bar\nLet `x`, `y`, and `z` be integers. Then `(y + x) + (0 + z + 0) + (0 + x + 0) = y + (z + (x + x))`\n-/\ntheorem ymca (x y z : \u2124)\n  : (y + x) + (0 + z + 0) + (0 + x + 0) = y + (z + (x + x)) :=\nbegin\n", "proof": "  --simp [add_assoc, add_comm x z, add_zero, zero_add],\n  rw [add_zero, add_zero, zero_add, zero_add, add_assoc y x z, add_assoc,\n    add_right_comm, add_comm _ z],\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n/- Tactic : simp\nThe `simp` tactic rewrites repeatedly using either supplied theorems & hypotheses or theorems\nthat it 'knows'.\n\nTo suggest theorems and hypotheses for use with `simp`, provide them as a comma-separated list.\nFor example `simp [h, add_comm]` rewrites repeatedly with hypotheses `h` and theorem `add_comm`.\n-/\n\nend pre_group -- hide\n\nend exlean -- hide", "height": 9, "editorText": "sorry", "lineOffset": 44, "name": "ymca", "statement": "(x y z : \u2124)\n  : (y + x) + (0 + z + 0) + (0 + x + 0) = y + (z + (x + x))"}, {"type": "tactic", "content": "198", "name": "simp", "sideBar": true}, {"type": "lean", "content": "199", "hidden": true}, {"type": "lean", "content": "200", "hidden": true}]}, {"name": "", "problemIndex": 26, "objects": [{"type": "lean", "content": "201", "hidden": true}, {"type": "lean", "content": "202", "hidden": false}, {"type": "text", "content": "203"}, {"type": "lean", "content": "204", "hidden": true}, {"type": "lean", "content": "205", "hidden": true}, {"type": "lean", "content": "206", "hidden": true}, {"type": "lean", "content": "207", "hidden": true}, {"type": "text", "content": "208"}, {"type": "lean", "content": "209", "hidden": false}, {"type": "text", "content": "210"}, {"type": "lean", "content": "211", "hidden": false}, {"type": "text", "content": "212"}, {"type": "lean", "content": "213", "hidden": false}, {"type": "text", "content": "214"}, {"type": "lean", "content": "215", "hidden": false}, {"type": "lean", "content": "216", "hidden": true}, {"type": "text", "content": "217"}, {"type": "lean", "content": "218", "hidden": false}, {"type": "text", "content": "219"}, {"type": "lean", "content": "220", "hidden": false}, {"type": "text", "content": "221"}, {"type": "lean", "content": "222", "hidden": false}, {"type": "text", "content": "223"}, {"type": "lean", "content": "224", "hidden": false}, {"type": "tactic", "content": "225", "name": "cc", "sideBar": true}, {"type": "text", "content": "226"}, {"type": "theorem", "text": "227", "lean": "theorem eq_zero_of_add_left_eq_self (x y z : \u2124) (h : y + x = x)\n  : y = 0 :=\n", "sideBar": false, "firstProofLineNumber": 164, "lastProofLineNumber": 166, "textBefore": "import myint.basic equations.simplifier -- hide\n\n-- This import contains the definitions of the algebraic structures `add_monoid`, `add_comm_group`, etc.\nimport algebra.group.basic\n\n/-\n# Equations\n\n## Level 16: Algebraic structures and advanced tactics\n\nIn this level, we'll show how to unleash `simp`'s power using 'type classes'. We'll introduce\nalgebraic structures (such as additive monoid and additive commutative group) that you'll explore\nin greater detail later.\n\nIn the last level, I mentioned that `simp` can use theorems that it knows, but we still had to\nsupply every theorem explicitly.\n\nThe reason is that `simp` doesn't (yet) know anything about\nthe integer type we've been using. That's because we aren't actually using Lean's built-in integer\ntype, but our own copy, called `myint`.\n\nThe result I've called `zero_add` is short for `exlean.pre_group.zero_add`.\nHere `exlean` and `pre_group` are\n<a href=\"https://leanprover.github.io/theorem_proving_in_lean/dependent_type_theory.html#namespaces\",\ntarget = \"blank\">namespaces</a> I've created to hide the messy details. You don't need to\nunderstand namespaces at the moment, beyond the fact that they permit the same name to be used\nfor different functions.\n\n### Monoids and groups\n\nThe simplifier does know a *different* theorem called `zero_add`, outside of any namespace.\nThis theorem isn't restricted to a particular type (such as integers, natural numbers, vectors of\nlength 2, etc.). Rather, it holds for any type belong to the `add_monoid` *type class*.\n\nA type class is merely a mechanism for dealing coherently with a collection of types that satsify\ncertain properties. To be an *instance* of the `add_monoid` type class, a type `G` must have a 'zero'\nelement and an operation called addition and denoted `+` which satisfiy the properties\nof additive associativity and additive identity (both left and right).\n-/\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\nnamespace pre_group -- hide\n\nopen myint -- hide\n\n/-\nHere, we show that `myint` is an intance of the `add_monoid` (short for 'additive monoid' type class.\nTo do this, we merely need to provide the apprioate 'fields' of the `add_monoid` structure.\n\nFor example, the line `zero_add := exlean.pre_group.zero_add,` fulfills the `zero_add`\nconstraint of the `add_monoid` type class by supplying our theorem `exlean.pre_group.zero_add`.\n\nIn fact, there are fields other than those shown, but Lean can generate these automatically from\nthe specified fields. This is what the `..` notation asks Lean to do.\n-/\n\ninstance : add_monoid myint :=\n{ add_assoc := exlean.pre_group.myint.add_assoc,\n  zero_add := exlean.pre_group.zero_add,\n  add_zero := exlean.pre_group.add_zero,\n  .. }\n\n/-\nAn instance of `add_comm_monoid` is an `add_monoid` for which the `+` operation is commutative.\nWe only need supply the `add_comm` field and let Lean generate the other fields by providing the\ninstance `myint.add_monoid`. Again, we use the `..` notation to do this.\n-/\n\ninstance : add_comm_monoid myint :=\n{ add_comm := exlean.myint.add_comm,\n  .. myint.add_monoid }\n\n/-\nAn `add_group` (addtive group) is an `add_monoid` that has an additive negation operator which\nsatisfies the `add_left_neg` property, namely that `(-a) + a = 0` for every `a`.\n-/\n\ninstance : add_group myint :=\n{ neg := exlean.myint.neg,\n  add_left_neg := exlean.pre_group.add_left_neg,\n  .. myint.add_monoid }\n\n\n/-\nFinally an `add_comm_group` (additive commutative group) is an additive group that is also\nan additive commutative monoid. All we need do is provide the required instances.\n-/\n\ninstance : add_comm_group myint :=\n{ .. myint.add_group, .. myint.add_comm_monoid }\n\nend pre_group -- hide\n\n/-\n### Levelled-up `simp`\n\nNow `simp` will automatically use `zero_add`, `add_zero`, `add_left_neg`, `add_right_comm`, etc.\nHere's an example.\n-/\n\nexample (x y : \u2124) : x + (-y) + y = x + 0 :=\nbegin\n  simp\nend\n\n/-\nNote that `add_assoc` and `add_comm` are *not* automatically applied by `simp`. Can you think why?\n-/\n\nexample (x y z : \u2124) : (y + x) + (0 + z + 0) + (0 + x + 0) = y + (z + (x + x)) :=\nbegin\n  simp [add_assoc, add_comm x z],\nend\n\n\n/-\nIn the example below, an ordinary `simp` would be useless as the target `\u22a2 x = y` cannot be\nsimplified further. However, using `simp at h` will simplify the hypothesis `h` using the \n`sub_right_inj` theorem. You haven't seen this theorem yet: suffice it to say that it does the \nobvious thing and `simp` finds it for you.\n\n-/\nexample (x y z : \u2124) (h : z - x = z - y) : x = y :=\nbegin\n  simp at h,\n  exact h,\nend\n\n/-\n### Congruence closure\n\nCongruence closure, or `cc`, is another powerful tactic. Don't worry about what the words\n'congruence' and 'closure' mean here\u2014they refer to concepts in computer science.\n\nRoughly speaking, `cc` can be used to prove equations where the proof depends on associativity,\ncommutativity, and (optionally) the use of hypotheses in the local context. Here's an example.\n-/\n\nexample (x y z : \u2124) (h : (z + x) + y = y + z * x) : y + z * x = y + (z + x) :=\nbegin\n  cc,\nend\n\n/- Tactic : cc\n`cc` can be used to prove equations where the proof depends on associativity,\ncommutativity, and (optionally) the use of hypotheses in the local context.\n-/\n\n/-\nUse `simp` (and whatever else you need) to prove the following result.\nThis *statement* is similar to a hard result you proved in a previous level, but the\n*proof* can be written in no more than two lines.\n-/\n\n/- Theorem : no-side-bar\nIf `y + x = x`, then `y = 0`.\n-/\ntheorem eq_zero_of_add_left_eq_self (x y z : \u2124) (h : y + x = x)\n  : y = 0 :=\nbegin [pure_maths]\n", "proof": "  simp at h,\n  exact h,\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide\n", "height": 3, "editorText": "sorry", "lineOffset": 163, "name": "eq_zero_of_add_left_eq_self", "statement": "(x y z : \u2124) (h : y + x = x)\n  : y = 0"}, {"type": "lean", "content": "228", "hidden": true}]}]}, {"name": "229", "levels": [{"name": "", "problemIndex": 7, "objects": [{"type": "lean", "content": "230", "hidden": true}, {"type": "text", "content": "231"}, {"type": "tactic", "content": "232", "name": "from", "sideBar": true}, {"type": "tactic", "content": "233", "name": "exact", "sideBar": true}, {"type": "lean", "content": "234", "hidden": false}, {"type": "lean", "content": "235", "hidden": true}, {"type": "text", "content": "236"}, {"type": "theorem", "text": "237", "lean": "theorem easy_proof (x y : \u2124) (h\u2081 : x + y = 3) (h\u2082 : x < 0)\n(h\u2083 : x * y = -10) : x + y = 3 :=\n", "sideBar": false, "firstProofLineNumber": 109, "lastProofLineNumber": 110, "textBefore": "import data.int.basic -- hide\n\n/-\n# Logic and Proof (And)\n\n## Level 1: Theorems and `from`\n\n### Theorem statements, hypotheses, targets, proofs\n\nAs a student of higher mathematics, your main task is to prove theorems.\n\nA theorem consists of two parts: (1) a statement of a mathematical result and (2) a proof of\nthat result.\n\nPythagoras' Theorem states: let  $T$ be a right-angled triangle, let $a$, $b$, $c$ be the\nside-lengths of $T$, and let $c$ be the length of the hypotenuse. Then  $a^2 + b^2 = c ^2$.\n\nIn this theorem statement, the *hypotheses* are:\n* $T$ is a right-angled triangle,\n* $a$, $b$, $c$ are the side lengths of $T$,\n* $c$ is the length of the hypotenuse.\n\nEvery theorem statement also has a *target*. In Pythagoras' Theorem, the target is:\n* $\\vdash a^2 + b^2 = c ^2$.\nThe symbol $\\vdash$ is read 'to prove'.\n\nAt every point in the proof, you have a *goal*. The goal is to prove the target in the context\nof the given hypotheses. The goal can change through the course of a proof.\n\n### Easy proofs\n\nIn the simplest of theorems, the target is one of the hypotheses.\n\n**Theorem**: Let $x$ be an integer. Suppose $h_1 : x > 0$ and $h_2 : x ^ 2 = 16$. Then $x ^ 2 = 16$.\n\nIn the theorem statement above, the target $\\vdash x ^ 2 = 16$ can be deduced immediately from the\nhypothesis I have labelled $h_2$. You can write the proof as follows:\n\n**Proof**: The result follows from $h_2$. \u220e\n\nThe symbol \u220e (read 'QED') indicates the end of a proof.\n\n### Easy proofs in Lean using `from`\n\nWe'll use the proof assistant Lean to write mathematical proofs. In the example below, the\nhypotheses are:\n* `x : \u2124`, that $x$ is an integer. Here, `\u2124` is typed `\\int`.\n* `h\u2081 : x > 0`, that $x > 0$. Note `h\u2081` is typed `h\\1`.\n* `h\u2082 : x ^ 2 = 16`, that $x^2 = 16$.\n\nThe target is to prove\n* `x ^ 2 = 16`.\n\nThe proof is the single line:\n* `from h\u2082,`\n\nThis corresponds to the handwritten proof, 'The result follows from $h_2$'. Here, `from` is\nan example of a Lean 'tactic'. Tactics are computer programmes that help in proving theorems.\nOn the left pane is a drop-down menu of all tactics seen so far in this game.\n-/\n\n/- Tactic : from\nIf one of the hypothesis `h` matches the target, then `from h` will close the goal.\n\n`from` is a synonym for the tactic `exact`.\n-/\n\n/- Tactic : exact\nIf one of the hypothesis `h` matches the target, then `exact h` will close the goal.\n-/\n\nexample (x : \u2124) (h\u2081 : x > 0) (h\u2082 : x ^ 2 = 16) : x ^ 2 = 16 :=\nbegin\n  from h\u2082,\nend\n\nnamespace exlean -- hide\n\n/-\n### Tasks\n\nNow it's your turn!\n\n1. If you see the text 'Lean is busy...' in the upper-right hand pane, please\nwait until Lean downloads.\n2. In the lower-right hand pane, you'll see a warning message,\n'declaration exlean.easy_proof uses `sorry`'. This is normal. It indicates that we haven't yet\nwritten a proper proof.\n3. Below, you'll see a theorem statement and (between the words `begin` and `end`), a `sorry` proof.\nWe use `sorry` to plug gaps in an incomplete proof.\n4. Delete the word `sorry`. You'll get an error message. Don't worry this just means we don't have\na proof.\n5. In the upper-right pane, you'll now see the *goal*. This consists of the hypotheses `x y : \u2124`,\n`h\u2081 : x + y = 3`, `h\u2082 : x < 0`, `h\u2083 : x * y = -10`, and the target, `\u22a2 x + y = 3`.\n6. **Write a one-line proof** of the target, adapting the proof above. Recall `h\u2082` is typed as `h\\2`.\nDon't forget the comma! On a piece of paper, state the theorem and give a 'handwritten' proof,\nfollowing the example above.\n7. If everything went well, you'll see the text 'Proof complete!' in the upper-right pane.\n8. Click 'Next level' in the top pane to proceed to the next level.\n-/\n\n/- Theorem : no-side-bar\nLet $x$ and $y$ be integers. Suppose $h_1 : x + y = 3$, $h_2 : x < 0$, and $h_3 : x y = -10$.\nThen $x + y = 3$.\n-/\ntheorem easy_proof (x y : \u2124) (h\u2081 : x + y = 3) (h\u2082 : x < 0)\n(h\u2083 : x * y = -10) : x + y = 3 :=\nbegin\n", "proof": "  from h\u2081,\n", "proof_hint": "sorry", "textAfter": "\nend\n\n\nend exlean -- hide", "height": 2, "editorText": "sorry", "lineOffset": 108, "name": "easy_proof", "statement": "(x y : \u2124) (h\u2081 : x + y = 3) (h\u2082 : x < 0)\n(h\u2083 : x * y = -10) : x + y = 3"}, {"type": "lean", "content": "238", "hidden": true}]}, {"name": "", "problemIndex": 9, "objects": [{"type": "lean", "content": "239", "hidden": true}, {"type": "text", "content": "240"}, {"type": "text", "content": "241"}, {"type": "lean", "content": "242", "hidden": false}, {"type": "tactic", "content": "243", "name": "cases", "sideBar": true}, {"type": "text", "content": "244"}, {"type": "lean", "content": "245", "hidden": false}, {"type": "lean", "content": "246", "hidden": true}, {"type": "text", "content": "247"}, {"type": "theorem", "text": "248", "lean": "theorem decomposing_and1 (x y : \u2124) (h : x + y = 3 \u2227 x < 0) :\nx + y = 3 :=\n", "sideBar": false, "firstProofLineNumber": 82, "lastProofLineNumber": 84, "textBefore": "import data.int.basic -- hide\n\n/-\n# Logic and Proof (And)\n## Level 2: Decomposing an 'and' hypothesis\n\n### And statements\n\nLet $p$ and $q$ be propositions (mathematical statements). The formal statement $p \\land q$\ncorresponds to the informal statement '$p$ and $q$'.\n\nSuppose you have given a hypothesis $h : p \\land q$. Decomposing this hypothesis replaces $h$ with\ntwo new hypotheses $h\u2081 : p$ and $h\u2082 : q$.\n\n**Theorem**: Let $x$ be an integer. Supose $h : (x > 0) \\land (x ^ 2 = 16)$. Then $x ^ 2 = 16$.\n\n**Proof**: Decomposing $h$ gives $h_1 : x > 0$ and $h_2 : x ^2 = 16$. The result follows from\n$h_2$. \u220e\n-/\n\n/-\n### Decomposing a hypothesis in Lean\n\nIn Lean, we use the `cases` tactic to decompose a compound hypothesis. In the example below, using\n`cases h with h\u2081 h\u2082` decomposes the original hypothesis `h : x > 0 \u2227 x * x = 16` into two\nnew hypotheses, `h\u2081 : x > 0` and `h\u2082 : x * x = 16`. The target, `\u22a2 x * x = 16` is proved using\nhypothesis `h\u2082`.\n\n*Notation*: the symbol `\u2227` in Lean is typed `\\and`.\n-/\n\nexample (x : \u2124) (h : (x > 0) \u2227 (x * x = 16)) : x * x = 16 :=\nbegin\n  cases h with h\u2081 h\u2082,\n  from h\u2082,\nend\n\n/- Tactic : cases\n`cases` is a general-purpose elimination tactic. It it used to 'decompose' a hypothesis into\nits constituent parts.\n\n### Examples\n\n* Given `h : \u2203 (x : \u2124), x + 5 = y`, typing `cases h with m h\u2082` replaces `h` with `m : \u2124` and\n`h\u2082 : m + 5 = y`.\n\n* Given `h : p \u2227 q`, typing `cases h with hp hq` replaces `h` with `hp : p` and `hq : q`.\n\n* Given `h : p \u2228 q`, typing `cases h with hp hq` replaces the current goal with two goals\n(1) in which `h` is replaced with `hp : p` and (2) in which `h` is replaced with `hq : q`.\n\n* Given `x : \u2115`, typing `cases x with k` replaces the goal with two new goals: (1) a goal in which\nevery occurence of `x` is replaced with `0` and (2) a goal with a new variable `k : \u2115` and in \nwhich every occurrence of `x` is replaced with `succ k`.\n-/\n\n/-\nThere is nothing special about the choice of hypothesis labels, as seen below.\n-/\n\nexample (x : \u2124) (Bob : (x > 0) \u2227 (x * x = 16)) : x * x = 16 :=\nbegin\n  cases Bob with alice sameera,\n  from sameera,\nend\n\nnamespace exlean -- hide\n\n/-\n### Tasks\n\n1. Replace `sorry` below with a Lean proof using `cases`. Adapt the proof of the example above.\n2. On a piece of paper, state and give a handwritten proof of this result.\n-/\n\n/- Theorem : no-side-bar\nLet $x$ and $y$ be integers. Suppose $h : (x + y = 3) \\land (x < 0)$. Then $x + y = 3$.\n-/\ntheorem decomposing_and1 (x y : \u2124) (h : x + y = 3 \u2227 x < 0) :\nx + y = 3 :=\nbegin\n", "proof": "  cases h with h\u2081 h\u2082,\n  from h\u2081,\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 3, "editorText": "sorry", "lineOffset": 81, "name": "decomposing_and1", "statement": "(x y : \u2124) (h : x + y = 3 \u2227 x < 0) :\nx + y = 3"}, {"type": "lean", "content": "249", "hidden": true}]}, {"name": "", "problemIndex": 10, "objects": [{"type": "lean", "content": "250", "hidden": true}, {"type": "text", "content": "251"}, {"type": "axiom", "content": "252", "name": "and.elim_right", "sideBar": true}, {"type": "axiom", "content": "253", "name": "and.elim_left", "sideBar": true}, {"type": "text", "content": "254"}, {"type": "lean", "content": "255", "hidden": false}, {"type": "text", "content": "256"}, {"type": "lean", "content": "257", "hidden": false}, {"type": "lean", "content": "258", "hidden": true}, {"type": "text", "content": "259"}, {"type": "theorem", "text": "260", "lean": "theorem and_elim1 (x y : \u2124) (h : x + y = 3 \u2227 x < 0) :\nx + y = 3 :=\n", "sideBar": false, "firstProofLineNumber": 59, "lastProofLineNumber": 59, "textBefore": "import data.int.basic -- hide\n\n/-\n# Logic and Proof (And)\n\n## Level 3: And elimination\n\nWhat I've called 'decomposition' of a hypothesis `h : p \u2227 q` is actually a combination of two\nmore fundamental principles: _left and elimination_ and _right and elimination_\n\n**Theorem**: Let $x$ be an integer. Supose $h : (x > 0) \\land (x ^ 2 = 16)$. Then $x ^ 2 = 16$.\n\n**Proof**: The result follows from right and elimination on $h$. \u220e\n-/\n\n/- Axiom: and.elim_right\n  (h : p \u2227 q) : q\n-/\n\n\n/- Axiom: and.elim_left\n  (h : p \u2227 q) : p\n-/\n\n\n/-\nIn Lean, if `h : p \u2227 q`, then `and.elim_right h` (also written `h.right`) is a proof of `q`.\nLikwise `and.elim_left h` (or `h.left`) is a proof of `p`.\n-/\n\nexample (x : \u2124) (h : (x > 0) \u2227 (x * x = 16)) : x * x = 16 :=\nbegin\n  exact and.elim_right h,\nend\n\n/-\nThe same proof can be given using an alternative notation.\n-/\nexample (x : \u2124) (h : (x > 0) \u2227 (x * x = 16)) : x * x = 16 :=\nbegin\n  exact h.right,\nend\n\nnamespace exlean -- hide\n\n/-\n### Tasks\n\n1. Replace `sorry` below with a one-line Lean proof, adapting either of the proofs above.\n2. On a piece of paper, state and give a handwritten proof of this result.\n-/\n\n/- Theorem : no-side-bar\nLet $x$ and $y$ be integers. Suppose $h : (x + y = 3) \\land (x < 0)$. Then $x + y = 3$.\n-/\ntheorem and_elim1 (x y : \u2124) (h : x + y = 3 \u2227 x < 0) :\nx + y = 3 :=\nbegin\n", "proof": "  exact h.left,", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 1, "editorText": "sorry", "lineOffset": 58, "name": "and_elim1", "statement": "(x y : \u2124) (h : x + y = 3 \u2227 x < 0) :\nx + y = 3"}, {"type": "lean", "content": "261", "hidden": true}]}, {"name": "", "problemIndex": 8, "objects": [{"type": "lean", "content": "262", "hidden": true}, {"type": "text", "content": "263"}, {"type": "text", "content": "264"}, {"type": "lean", "content": "265", "hidden": false}, {"type": "text", "content": "266"}, {"type": "lean", "content": "267", "hidden": false}, {"type": "lean", "content": "268", "hidden": true}, {"type": "text", "content": "269"}, {"type": "theorem", "text": "270", "lean": "theorem propositions (r s : Prop) (h : s \u2227 r) : s :=\n", "sideBar": false, "firstProofLineNumber": 71, "lastProofLineNumber": 74, "textBefore": "import data.int.basic -- hide\n\n/-\n# Logic and Proof (And)\n\n## Level 4: Propositions\n\n### Propositions\n\nIn previous levels, we saw that if $x$ is an integer and if $h : (x > 0) \\land (x ^ 2 = 16)$,\nthen $x^2 = 16$ follows. One proof is first to decompose $h$ as $h_1 : x > 0$ and\n$h_2 : x ^2 = 16$ and then to apply $h_2$.\n\nHere's another example.\n\n**Theorem**: Let $y$ be an integer. Supose $h : (y \\ne 2) \\land (10 y = 5)$. Then $10y = 5$.\n\n**Proof**: Decomposing $h$ gives $h_1 : y \\ne 2$ and $h_2 : 10y = 5$. The result follows from\n$h_2$. \u220e\n-/\n\n/-\nOther than the details of the hypotheses, the proofs are identitcal. We can generalise both\narguments by using symbols in place of particular statements. These symbols are called\n_propositional variables_.\n\nUsing propositional variables to stand for arbitrary propositions is similar to the use of\nvariables names (such as $x$) to stand for arbitrary numbers in high school algebra.\n\nWe now give a generalisation of the above proof.\n\n**Theorem**: Let $p$ and $q$ be propositions. Suppose $h : p \\land q$. Then $q$ follows.\n\n**Proof**: Decomposing $h$ gives $h_1 : p$ and $h_2 : q$. The result follows from $h_2$. \u220e\n\nThe same thing can be written in Lean.\n-/\n\nexample (p q : Prop) (h : p \u2227 q) : q :=\nbegin\n  cases h with h\u2081 h\u2082,\n  from h\u2082,\nend\n\n/-\nThe same theorem can be be proved via and elimination.\n\n**Proof**: The result follows by right and elimination on $h$. \u220e\n-/\n\nexample (p q : Prop) (h : p \u2227 q) : q :=\nbegin\n  from h.right,\nend\n\nnamespace exlean -- hide\n\n/-\n### Task\n\n1. Replace `sorry` below with a proof using `cases`.\n2. Delete your proof and write a one-line proof using and elimination.\n2. On a piece of paper, state and give handwritten proofs of this result.\n-/\n\n/- Theorem : no-side-bar\nLet $r$ and $s$ be propositions. Suppose $h : s \\land r$. Then $s$ follows.\n-/\ntheorem propositions (r s : Prop) (h : s \u2227 r) : s :=\nbegin\n", "proof": "  cases h with h\u2081 h\u2082,\n  from h\u2081,\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 4, "editorText": "sorry", "lineOffset": 70, "name": "propositions", "statement": "(r s : Prop) (h : s \u2227 r) : s"}, {"type": "lean", "content": "271", "hidden": true}]}, {"name": "", "problemIndex": 8, "objects": [{"type": "lean", "content": "272", "hidden": true}, {"type": "text", "content": "273"}, {"type": "lean", "content": "274", "hidden": false}, {"type": "text", "content": "275"}, {"type": "lean", "content": "276", "hidden": false}, {"type": "lean", "content": "277", "hidden": true}, {"type": "text", "content": "278"}, {"type": "lean", "content": "279", "hidden": false}, {"type": "theorem", "text": "280", "lean": "theorem decomposing_nested_and (h : p \u2227 (q \u2227 r)) : r :=\n", "sideBar": false, "firstProofLineNumber": 52, "lastProofLineNumber": 57, "textBefore": "import data.int.basic -- hide\n\n/-\n# Logic and Proof (And)\n\n## Level 5: Further 'and' decomposition\n\n### Nested and\n\n**Theorem**: Let $p$, $q$, and $r$ be propositions. Suppose $h : (p \\land q) \\land r$. Then $q$ follows.\n\n**Proof**: Decomposing $h$ gives $h_{pq} : p \\land q$ and $h_r : r$.\nDecomposing $h_{pq}$ gives $h_p : p$ and $h_q : q$. \u220e\n\nThe same proof can be written in Lean.\n-/\n\nexample (p q r : Prop) (h : (p \u2227 q) \u2227 r) : q :=\nbegin\n  cases h with hpq hr,\n  cases hpq with hp hq,\n  from hq,\nend\n\n/-\nAs before, note that the hypothesis names have no significance.\n-/\n\nexample (p q r : Prop) (h : (p \u2227 q) \u2227 r) : q :=\nbegin\n  cases h with h\u2081 h\u2082,\n  cases h\u2081 with h\u2083 h\u2084,\n  from h\u2084,\nend\n\nnamespace exlean -- hide\n\n/-\n### Tasks\n\n1. Replace `sorry` below with a Lean proof, adapting the proof of the example above.\n2. On a piece of paper, state and give a handwritten proof of this result.\n-/\n\nvariables (p q r : Prop)\n\n/- Theorem : no-side-bar\nLet $p$, $q$, $r$ be propostions. Suppose $h : p \\land (q \\land r)$. Then $r$ follows.\n-/\ntheorem decomposing_nested_and (h : p \u2227 (q \u2227 r)) : r :=\nbegin\n", "proof": "  cases h with hp hqr,\n  cases hqr with hq hr,\n  from hr, \n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 6, "editorText": "sorry", "lineOffset": 51, "name": "decomposing_nested_and", "statement": "(h : p \u2227 (q \u2227 r)) : r"}, {"type": "lean", "content": "281", "hidden": true}]}, {"name": "", "problemIndex": 12, "objects": [{"type": "lean", "content": "282", "hidden": true}, {"type": "text", "content": "283"}, {"type": "text", "content": "284"}, {"type": "lean", "content": "285", "hidden": false}, {"type": "text", "content": "286"}, {"type": "text", "content": "287"}, {"type": "lean", "content": "288", "hidden": false}, {"type": "text", "content": "289"}, {"type": "tactic", "content": "290", "name": "have", "sideBar": true}, {"type": "lean", "content": "291", "hidden": true}, {"type": "text", "content": "292"}, {"type": "lean", "content": "293", "hidden": false}, {"type": "theorem", "text": "294", "lean": "theorem have_nested_and (h : p \u2227 (q \u2227 r)) : q :=\n", "sideBar": false, "firstProofLineNumber": 95, "lastProofLineNumber": 98, "textBefore": "import data.int.basic -- hide\n\n/-\n# Logic and Proof (And)\n\n## Level 6: New hypotheses with `have`\n\n### The `have` tactic\n\nIn a long proof, it can help to introduce new hypotheses into the context for later use.\nThe next example isn't long, but illustrates the concept.\n\n**Theorem**: Let $p$ and $q$ be propositions. Suppose $h : p \\land q$. Then $q$ follows.\n\n**Proof**: We have $h_2 : q$ by right and elimination on $h$. The result follows from $h_2$. \u220e\n-/\n\n/-\nIn Lean, we accomplish this using the `have` tactic.\n-/\n\nexample (p q : Prop) (h : p \u2227 q) : q :=\nbegin\n  have h\u2082 : q, from h.right,\n  from h\u2082,\nend\n\n/-\nEqually, we could replace `h.right` with `and.elim_right h`.\n-/\n\n/-\nFor a more sophisticated example, we'll take a hypothesis that involves nesting `\u2227`s.\n-/\n\nexample (p r q : Prop) (h : (p \u2227 q) \u2227 r) : q :=\nbegin\n  have h\u2081 : p \u2227 q, from h.left,\n  from h\u2081.right,\nend\n\n\n/-\nImmediately after typing `have h\u2081 : p \u2227 q,` in the proof above, Lean would present you with \ntwo new goals:\n\n```\n2 goals\np r q : Prop,\nh : (p \u2227 q) \u2227 r\n\u22a2 p \u2227 q\n\np r q : Prop,\nh : (p \u2227 q) \u2227 r,\nh\u2081 : p \u2227 q\n\u22a2 q\n```\n\n\nThe first of these is the goal introduced by the `have` tactic, namely that of proving `p \u2227 q`\nin the original context. The Lean code `from h.left,` closes this goal.\n\nThe second goal is that of proving the original target, `q` in a context that includes the\nresult to be proved by the `have` tactic.\n-/\n\n/- Tactic : have\n`have` is used to introduce a new hypothesis into the context. It opens a new goal for the proof\nof the hypothesis.\n\n### Example\n`have h2 : x + y = y + x` introduces a new goal, to prove\n`x + y = y + x` while adding the hypothesis `h2 : x + y = y + x` to the context of the old goal.\n-/\n\nnamespace exlean -- hide\n\n/-\n### Task\n\n1. Replace `sorry` below with a Lean proof, adapting the proof of the example above. Remember that\n`\u2227` is typed `\\and`.\n2. On a piece of paper, state and give a handwritten proof of this result.\n3. (Bonus) you should be able to write a one-line proof of this result, using only the `from`\ntactic and elimination rules. Try this!\n-/\n\nvariables (p q r : Prop)\n\n/- Theorem : no-side-bar\nLet $p$, $q$, $r$ be propostions. Suppose $h : p \\land (q \\land r)$. Then $q$ follows.\n-/\ntheorem have_nested_and (h : p \u2227 (q \u2227 r)) : q :=\nbegin\n", "proof": "  have h\u2081 : q \u2227 r, from h.right,\n  from h\u2081.left,\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 4, "editorText": "sorry", "lineOffset": 94, "name": "have_nested_and", "statement": "(h : p \u2227 (q \u2227 r)) : q"}, {"type": "lean", "content": "295", "hidden": true}]}, {"name": "", "problemIndex": 18, "objects": [{"type": "lean", "content": "296", "hidden": true}, {"type": "text", "content": "297"}, {"type": "text", "content": "298"}, {"type": "lean", "content": "299", "hidden": false}, {"type": "text", "content": "300"}, {"type": "tactic", "content": "301", "name": "split", "sideBar": true}, {"type": "text", "content": "302"}, {"type": "lean", "content": "303", "hidden": false}, {"type": "text", "content": "304"}, {"type": "lean", "content": "305", "hidden": false}, {"type": "text", "content": "306"}, {"type": "lean", "content": "307", "hidden": false}, {"type": "tactic", "content": "308", "name": "show", "sideBar": true}, {"type": "text", "content": "309"}, {"type": "lean", "content": "310", "hidden": false}, {"type": "lean", "content": "311", "hidden": true}, {"type": "text", "content": "312"}, {"type": "lean", "content": "313", "hidden": false}, {"type": "theorem", "text": "314", "lean": "theorem split_and1 (h\u2081 : p) (h\u2082 : q) (h\u2083 : r) : r \u2227 q :=\n", "sideBar": false, "firstProofLineNumber": 164, "lastProofLineNumber": 167, "textBefore": "import data.int.basic -- hide\n\n/-\n# Logic and Proof (And)\n\n## Level 7: Splitting an 'and' target\n\n### Splitting a goal\n\nTo prove a target $\\vdash (x > 0) \\land (x + y = 5)$ is to prove both\n$x > 0$ and $x + y = 5$. That is, the original goal is split into two new goals.\n\n**Theorem**: Let $x$ and $y$ be integers. Suppose $h_1 : x > 0$ and $h_2 : x + y = 5$. Then\n$(x > 0) \\land (x + y = 5)$.\n\n**Proof**: It suffices to prove (1) $x > 0$ and (2) $x + y = 5$.\n1. The target $x > 0$ follows from $h_1$.\n2. The target $x + y = 5$ follows from $h_2$. \u220e\n-/\n\n\n/-\nThe Lean tactic `split` can be used to split an 'and' goal. In the proof below, the text following\neach `--` is a _comment_. Lean ignores comments. Add comments to your Lean proofs to help explain\nyour proof to the reader.\n-/\n\nexample (x y : \u2124) (h\u2081 : x > 0) (h\u2082 : x + y = 5) : (x > 0) \u2227 (x + y = 5) :=\nbegin\n  split,\n  from h\u2081,  -- Proof of x > 0\n  from h\u2082,  -- Proof of x + y = 5\nend\n\n\n/-\nImmediately after typing `split,` in the proof above, Lean creates two new goals:\n```\n2 goals\nx y : \u2124,\nh\u2081 : x > 0,\nh\u2082 : x + y = 5\n\u22a2 x > 0\n\nx y : \u2124,\nh\u2081 : x > 0,\nh\u2082 : x + y = 5\n\u22a2 x + y = 5\n```\n\nThe _context_ of both goals (the list of hypotheses) is identical. The only difference is\nthe target. The line `from h\u2081,` closes the first goal, leaving only one goal.\n```\n1 goal\nx y : \u2124,\nh\u2081 : x > 0,\nh\u2082 : x + y = 5\n\u22a2 x + y = 5\n```\nWe close this final goal with `from h\u2082,`\n-/\n\n/- Tactic : split\n\nThe `split` tactic splits a 'compound' target into multiple goals. \n\n### Examples\n\n`split` turns the target `\u22a2 p \u2227 q` into two goals: (1) `\u22a2 p` and (2)  `\u22a2 q`.\n\nEqually, if the target is `\u22a2 p \u2194 q`, split creates the goals (1) to prove\n`p \u2192 q` and (2) to prove `q \u2192 p`.\n-/\n\n/-\n### The `show` tactic\n\nProofs with many goals (espeically nested goals) can become complicated. One way to make clear\nwhat is being proved is to use the `show` tactic.\n\nHere's a simple proof that `q` follows from the assumptions `h\u2081 : p` and `h\u2082 : q`.\n-/\n\nexample (p q: Prop) (h\u2081 : p) (h\u2082 : q) : q :=\nbegin\n  from h\u2082,\nend\n\n/-\nUsing the `show` tactic, we make clear that the line `from h\u2082` is a proof of `q`.\n-/\n\nexample (p q: Prop) (h\u2081 : p) (h\u2082 : q) : q :=\nbegin\n  show q, from h\u2082,\nend\n\n/-\nMore usefully, `show` can be used to clarify the target of the goals that arise after splitting\nan 'and' target.\n-/\n\nexample (x y : \u2124) (h\u2081 : x > 0) (h\u2082 : x + y = 5) : (x > 0) \u2227 (x + y = 5) :=\nbegin\n  split,\n  show x > 0, from h\u2081,\n  show x + y = 5, from h\u2082, \nend\n\n/- Tactic : show\n`show` is used to clarify what is being proved.\n\n### Example\nIf the target is to prove `p \u2227 q` and the hypothesis `h` is a proof of `p \u2227 q`, then\n`show p \u2227 q, from h` indicates the target to Lean (and the human reader!) and closes the goal.\n-/\n\n/-\n### Focussing with braces\n\nDealing with many goals at once can be confusing. Braces can be used to separate goals.\nIf you place your cursor within a brace, only the current goal is shown. It's good practice to\ncreate a `sorry` proof for each new goal and fill in each `sorry` in turn.\n\n```\nexample (x y : \u2124) (h\u2081 : x > 0) (h\u2082 : x + y = 5) : (x > 0) \u2227 (x + y = 5) :=\nbegin\n  split,\n  { sorry, },\n  { sorry, },\nend\n```\n\nFilling in each `sorry` above leads to the following proof.\n-/\n\nexample (x y : \u2124) (h\u2081 : x > 0) (h\u2082 : x + y = 5) :\n(x > 0) \u2227 (x + y = 5) :=\nbegin\n  split,\n  { show x > 0, from h\u2081, },\n  { show x + y = 5, from h\u2082, },\nend\n\n\nnamespace exlean -- hide\n\n/-\n### Task\n\n1. Complete the Lean proof below. Use `split`, `show`, and braces, as in the example above. Start\nby writing `sorry` within each brace.\n2. On a piece of paper, state and give a handwritten proof of this result.\n-/\n\nvariables (p q r : Prop)\n\n/- Theorem : no-side-bar\nLet $p$, $q$, $r$ be propostions. Suppose $h_1 : p$, $h_2 : q$, and $h_3 : r$. Then $r \\land q$ \nfollows.\n-/\ntheorem split_and1 (h\u2081 : p) (h\u2082 : q) (h\u2083 : r) : r \u2227 q :=\nbegin\n", "proof": "  split,\n  { show r, from h\u2083, },\n  { show q, from h\u2082, },\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 4, "editorText": "sorry", "lineOffset": 163, "name": "split_and1", "statement": "(h\u2081 : p) (h\u2082 : q) (h\u2083 : r) : r \u2227 q"}, {"type": "lean", "content": "315", "hidden": true}]}, {"name": "", "problemIndex": 8, "objects": [{"type": "lean", "content": "316", "hidden": true}, {"type": "text", "content": "317"}, {"type": "text", "content": "318"}, {"type": "axiom", "content": "319", "name": "and.intro", "sideBar": true}, {"type": "lean", "content": "320", "hidden": false}, {"type": "lean", "content": "321", "hidden": true}, {"type": "text", "content": "322"}, {"type": "lean", "content": "323", "hidden": false}, {"type": "theorem", "text": "324", "lean": "theorem and_intro1 (h\u2081 : p) (h\u2082 : q) (h\u2083 : r) : r \u2227 q :=\n", "sideBar": false, "firstProofLineNumber": 54, "lastProofLineNumber": 55, "textBefore": "import data.int.basic -- hide\n\n/-\n# Logic and Proof (And)\n\n## Level 8: And introduction\n\n### An introduction principle\n\nThe `split` tactic is useful when each of the constituents of a compound target are complicated.\nVia split, we create two new goals and work on each goal separately.\n\nAn alternative approach to proving a statement of the form `p \u2227 q` is to use the 'and introduction'\nprinciple. This principle combines a proof of `p` with a proof of `q` to give a proof of `p \u2227 q`.\n\n**Theorem**: Let $x$ and $y$ be integers. Suppose $h_1 : x > 0$ and $h_2 : x + y = 5$. Then\n$(x > 0) \\land (x + y = 5)$.\n\n**Proof**: The result follows by and introduction on $h_1$ and $h_2$. \u220e\n-/\n\n/-\nIn Lean, if `h\u2081 : p` and `h\u2082 : q` then `and.intro h\u2081 h\u2082` is a proof of `p \u2227 q`.\n-/\n\n\n/- Axiom: and.intro\n  (h\u2081 : p) (h\u2082 : q) : p \u2227 q\n-/\n\nexample (x y : \u2124) (h\u2081 : x > 0) (h\u2082 : x + y = 5) : (x > 0) \u2227 (x + y = 5) :=\nbegin\n  from and.intro h\u2081 h\u2082,\nend\n\nnamespace exlean -- hide\n\n/-\n### Tasks\n\n1. Replace `sorry` below with a one-line Lean proof, adapting the proof of the example above. Your proof\nshould use `and.intro` and the `from` tactic.\n2. On a piece of paper, state and give a handwritten proof of this result.\n-/\n\nvariables (p q r : Prop)\n\n/- Theorem : no-side-bar\nLet $p$, $q$, $r$ be propostions. Suppose $h_1 : p$, $h_2 : q$, and $h_3 : r$. Then $r \\land q$ \nfollows.\n-/\ntheorem and_intro1 (h\u2081 : p) (h\u2082 : q) (h\u2083 : r) : r \u2227 q :=\nbegin\n", "proof": "  from and.intro h\u2083 h\u2082,\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 2, "editorText": "sorry", "lineOffset": 53, "name": "and_intro1", "statement": "(h\u2081 : p) (h\u2082 : q) (h\u2083 : r) : r \u2227 q"}, {"type": "lean", "content": "325", "hidden": true}]}, {"name": "", "problemIndex": 13, "objects": [{"type": "lean", "content": "326", "hidden": true}, {"type": "text", "content": "327"}, {"type": "text", "content": "328"}, {"type": "lean", "content": "329", "hidden": false}, {"type": "text", "content": "330"}, {"type": "lean", "content": "331", "hidden": false}, {"type": "text", "content": "332"}, {"type": "lean", "content": "333", "hidden": false}, {"type": "text", "content": "334"}, {"type": "lean", "content": "335", "hidden": false}, {"type": "tactic", "content": "336", "name": "apply", "sideBar": true}, {"type": "lean", "content": "337", "hidden": true}, {"type": "text", "content": "338"}, {"type": "theorem", "text": "339", "lean": "theorem and_intro2 (h\u2081 : p) (h\u2082 : q) (h\u2083 : r) : (p \u2227 (q \u2227 r)) \u2227 p :=\n", "sideBar": false, "firstProofLineNumber": 123, "lastProofLineNumber": 126, "textBefore": "import data.int.basic -- hide\n\n/-\n# Logic and Proof (And)\n\n## Level 9: Backward proof and `apply`\n\n### Mixed forward and backward proofs\n\nWe've seen two ways to prove $p \\land q$.\n\n1. First prove $h_1 : p$ and $h_2 : q$. Applying and introduction to $h_1$ and $h_2$ gives \nthe result. In Lean, `and.intro h\u2081 h\u2082` is a proof of `p \u2227 q` from `h\u2081` and `h\u2082`. We use this proof\nin `from and.intro h\u2081 h\u2082,` to close a goal `p \u2227 q`.\n2. Apply and introduction immediately to create two new goals: (1) to prove `p` and (2) to prove\n`q`. In Lean, we do this via the `split` tactic.\n\nThe second approach above is called 'backward' proof.\n\nA third approach is to combine both proof styles.\n\n**Theorem**: Let $p$, $q$, and $r$ be propositions. Suppose $h_1 : p$, $h_2 : q$, and $h_3 : r$.\nThen $p \\land (q \\land r)$.\n\n**Proof**: Applying and introduction with $h_1$, it suffices to prove $q \\land r$.\nThis follows by and introduction on $h_2$ and $h_3$. \u220e\n\n\nThe first line of the proof above involves a partial application of and introduction. We provide\nand introduction with the first 'argument', $h_1 : p$ and leave, as a new goal, the proof of\n$q \\land r$.\n\n### The `apply` tactic\n-/\n\n/-\nThe `and.intro` rule takes two arguments: `h\u2081 : p` and `h\u2082 : q` and returns a proof of `p \u2227 q`.\n\nThe `apply` tactic takes any theorem and any number of arguments to that theorem and generates\nenough goals to fill in the remaining arguments.\n\nHere is a Lean version of the above proof. We use `apply`, giving `and.intro` the single argument\n`h\u2081`. It remains to prove `q \u2227 r`.\n-/\n\nvariables (p q r : Prop)\n\n\nexample (h\u2081 : p) (h\u2082 : q) (h\u2083 : r) : p \u2227 (q \u2227 r) :=\nbegin\n  apply and.intro h\u2081,\n  show q \u2227 r, from and.intro h\u2082 h\u2083,\nend\n\n/-\nAlternatively, we could provide `apply and.intro` with *no* arguments. We would then\nhave to prove both goals, much like a `split` proof.\n-/\n\nexample (h\u2081 : p) (h\u2082 : q) (h\u2083 : r) : p \u2227 (q \u2227 r) :=\nbegin\n  apply and.intro,\n  show p, from h\u2081,\n  show q \u2227 r, from and.intro h\u2082 h\u2083,\nend\n\n\n/-\nIf we `apply and.intro` with both arguments, we are effectively doing a `from` proof.\n-/\n\nexample (h\u2081 : p) (h\u2082 : q) (h\u2083 : r) : p \u2227 (q \u2227 r) :=\nbegin\n  have h\u2084 : q \u2227 r, from and.intro h\u2082 h\u2083,\n  apply and.intro h\u2081 h\u2084,\nend\n\n/-\nConsider the following result and its (handwritten) proof.\n\n**Theorem**: Let $p$, $q$, $r$ be propositions. Suppose $h_1 : p$, $h_2 : q$, and $h_3 : r$.\nThen $(p \\land q) \\land r$.\n\n**Proof**: Applying and introduction to $h_3$, it suffices to prove $p \\land q$. This follows from\nand introduction on $h_1$ and $h_2$. \u220e\n\n\nAs a human, you are clever enough to realise that $h_3$ in the proof above is meant to be the\nsecond argument to and introduction.\n\nComputers must be given more precise instructions. Any missing arguments at the front or middle\nof an `apply` are indicated with a `_` 'wildcard character.\n-/\n\nexample (h\u2081 : p) (h\u2082 : q) (h\u2083 : r) : (p \u2227 q) \u2227 r :=\nbegin\n  apply and.intro _ h\u2083,\n  show p \u2227 q, from and.intro h\u2081 h\u2082,\nend\n\n/- Tactic : apply\n`apply`, provided with a theorem name and any number of conditions of the theorem,\nopens as many new goals are necessary to fill in proofs of the remaining conditions\nof the theorem.\n-/\n\nnamespace exlean -- hide\n\n/-\n### Tasks\n\n1. Replace `sorry` below with a Lean proof, adapting the proof of the example above. Your proof\nshould use `and.intro` and the `apply` tactic. Use `show` to indicate changes of the goal.\n2. On a piece of paper, state and give a handwritten proof of this result.\n-/\n\n/- Theorem : no-side-bar\nLet $p$, $q$, $r$ be propostions. Suppose $h_1 : p$, $h_2 : q$, and $h_3 : r$. Then\n$(p \\land (q \\land r)) \\land p$ follows.\n-/\ntheorem and_intro2 (h\u2081 : p) (h\u2082 : q) (h\u2083 : r) : (p \u2227 (q \u2227 r)) \u2227 p :=\nbegin\n", "proof": "  apply and.intro _ h\u2081,\n  show p \u2227 (q \u2227 r), apply and.intro h\u2081,\n  show q \u2227 r, from and.intro h\u2082 h\u2083,\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 4, "editorText": "sorry", "lineOffset": 122, "name": "and_intro2", "statement": "(h\u2081 : p) (h\u2082 : q) (h\u2083 : r) : (p \u2227 (q \u2227 r)) \u2227 p"}, {"type": "lean", "content": "340", "hidden": true}]}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "341", "hidden": true}, {"type": "text", "content": "342"}, {"type": "text", "content": "343"}, {"type": "lean", "content": "344", "hidden": true}, {"type": "text", "content": "345"}, {"type": "lean", "content": "346", "hidden": false}, {"type": "theorem", "text": "347", "lean": "theorem and_summary (h : p \u2227 (q \u2227 r)) : p \u2227 q :=\n", "sideBar": false, "firstProofLineNumber": 68, "lastProofLineNumber": 78, "textBefore": "import data.int.basic -- hide\n\n/-\n# Logic and Proof (And)\n\n## Level 10: And summary\n\n### Elimination and introduction\n\nIn logic, the entire meaning of $\\land$ is encapsulated by two principles.\n\n1. And introduction. Given $h_1 : p$ and $h_2 : q$, and introduction on $h_1$ and $h_2$ gives a \nproof of $p \\land q$.\n2. And elimination. Given $h : p \\land q$,\n    * Left and elimination on `h` gives a proof of `p`.\n    * Right and elimination on `h` gives a proof of `q`.\n\n\nIn Lean, the principles are as follows.\n\n1. And introduction. Given `h\u2081 : p` and `h\u2082 : q`, `and.intro h\u2081 h\u2082` is a proof of `p \u2227 q`.\n2. And elimination. Given `h : p \u2227 q`,\n    * `h.left` or `and.elim_left h` gives a proof of `p`.\n    * `h.right` or `and.elim_right h` gives a proof of `q`.\n\n### `cases` and `split`, backward proof\n\nLean provides the mechanism `cases` for doing left and right and elimination simultaneously.\nIf `h : p \u2227 q`, then `cases h with h\u2081 h\u2082` replaces `h` with two new hypotheses, `h\u2081 : p` and\n`h\u2082 : q`.\n\nThe `split` tactic is used for 'backward' and introduction. If the target is `p \u2227 q`, a forward\napplication of and introduction requires having proved first `h\u2081 : p` and `h\u2082 : q`. \nVia `split`, Lean creates two new goals, one for each of the conditions of and introduction.\n-/\n\n/-\n### `from`, `have`, and `show`\n\n* `from` is used to give a hypothesis or other proof term that closes the goal.\n* `have` allows you to create an auxiliary goal. The result of the goal is added to the context.\n* `show` is used to indicate what you're trying to prove.\n\n### `apply` and mixed forward / backward proofs\nThe `apply` tactic permits writing mixed forward / backward proofs, depending on the number\nof arguments given to the applied theorem.\n-/\n\nnamespace exlean -- hide\n\n/-\n### Task\n\n1. Prove the Lean result below. Try as many different proof methods as you can. Which method\ndo you like the best?\n2. On a piece of paper, state and give a handwritten proof of this result.\n3. (Bonus) Give a one-line Lean proof of the result.\n-/\n\nvariables (p q r : Prop)\n\n/- Theorem : no-side-bar\nLet $p$, $q$, $r$ be propostions. Suppose $h : p \\land (q \\land r)$. Then $p \\land q$ \nfollows.\n-/\ntheorem and_summary (h : p \u2227 (q \u2227 r)) : p \u2227 q :=\nbegin\n", "proof": "  cases h with hp hqr,\n  cases hqr with hq hr,\n  exact and.intro hp hq,\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 11, "editorText": "sorry", "lineOffset": 67, "name": "and_summary", "statement": "(h : p \u2227 (q \u2227 r)) : p \u2227 q"}, {"type": "lean", "content": "348", "hidden": true}]}]}, {"name": "349", "levels": [{"name": "", "problemIndex": 12, "objects": [{"type": "lean", "content": "350", "hidden": true}, {"type": "text", "content": "351"}, {"type": "text", "content": "352"}, {"type": "text", "content": "353"}, {"type": "axiom", "content": "354", "name": "or.inl", "sideBar": true}, {"type": "axiom", "content": "355", "name": "or.inr", "sideBar": true}, {"type": "lean", "content": "356", "hidden": false}, {"type": "text", "content": "357"}, {"type": "lean", "content": "358", "hidden": false}, {"type": "lean", "content": "359", "hidden": true}, {"type": "text", "content": "360"}, {"type": "lean", "content": "361", "hidden": false}, {"type": "theorem", "text": "362", "lean": "theorem or_intro1 (h\u2081 : p) (h\u2082 : s) (h\u2083 : r) : r \u2228 q :=\n", "sideBar": false, "firstProofLineNumber": 81, "lastProofLineNumber": 82, "textBefore": "import data.int.basic -- hide\n\n/-\n# Logic and Proof (Or)\n\n## Level 1: Proving or statements\n\n### Left and right or introduction\n-/\n\n/-\nLet $p$ and $q$ be propositions. The formal statement $p \\lor q$\ncorresponds to the informal statement '$p$ or $q$'.\n\nThus, $(x > y) \\lor (x + y = 5)$ corresponds to '$x > y$ or $x + y = 5$'.\n\nTo *prove* an or statement $p \\lor q$ is either (1) to prove $p$ or (2) to prove $q$.\n\nThese are the two _introduction rules_ for $\\lor$. They can be stated more formally.\n\nLet $p$ and $q$ be propositions.\n1. Let $h : p$. 'Left or introduction' on $h$ gives a proof of $p \\lor q$.\n2. Let $h : q$. 'Right or introduction' on $h$ gives a proof of $p \\lor q$.\n\n**Theorem**: Let $x$ and $y$ be integers. Suppose $h : x + y = 5$. Then $(x > y) \\lor (x + y = 5)$.\n\n**Proof**: The result follows by right or introduction on $h$. \u220e\n-/\n\n/-\n### Or introduction in Lean\n\nThe Lean names for left and right or introduction are `or.inl` and `or.inr` respectively.\n\nSuppose `p` and `q` are propositions.\n1. Let `h : p`. Then `or.inl h` gives a proof of `p \u2228 q`.\n2. Let `h : q`. Then `or.inr h` gives a proof of `p \u2228 q`.\n\nBelow, we have a Lean proof of the previous theorem. The symbol `\u2228` is typed `\\or`.\n-/\n\n/- Axiom: or.inl\n  (h : p) : p \u2228 q\n-/\n\n/- Axiom: or.inr\n  (h : q) : p \u2228 q\n-/\n\nexample (x y : \u2124) (h : x + y = 5) : (x > y) \u2228 (x + y = 5) :=\nbegin\n  from or.inr h,\nend\n\n/-\nProofs by left or introduction proceed as you might expect.\n-/\n\nexample (x y : \u2124) (h : x > y) : (x > y) \u2228 (x + y = 5) :=\nbegin\n  from or.inl h,\nend\n\nnamespace exlean -- hide\n\n/-\n### Tasks\n\n1. Replace `sorry` below with a one-line Lean proof, adapting the proof of the example above.\n2. On a piece of paper, state and give a handwritten proof of this result.\n-/\n\nvariables (p q r s : Prop)\n\n/- Theorem : no-side-bar\nLet $p$, $q$, $r$, and $s$ be propostions. Suppose $h_1 : p$, $h_2 : s$, and $h_3 : r$. Then $r \\lor q$ \nfollows.\n-/\ntheorem or_intro1 (h\u2081 : p) (h\u2082 : s) (h\u2083 : r) : r \u2228 q :=\nbegin\n", "proof": "  from or.inl h\u2083,\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 2, "editorText": "sorry", "lineOffset": 80, "name": "or_intro1", "statement": "(h\u2081 : p) (h\u2082 : s) (h\u2083 : r) : r \u2228 q"}, {"type": "lean", "content": "363", "hidden": true}]}, {"name": "", "problemIndex": 10, "objects": [{"type": "lean", "content": "364", "hidden": true}, {"type": "text", "content": "365"}, {"type": "text", "content": "366"}, {"type": "text", "content": "367"}, {"type": "lean", "content": "368", "hidden": false}, {"type": "text", "content": "369"}, {"type": "lean", "content": "370", "hidden": false}, {"type": "lean", "content": "371", "hidden": true}, {"type": "text", "content": "372"}, {"type": "lean", "content": "373", "hidden": false}, {"type": "theorem", "text": "374", "lean": "theorem nested_or1 (h : q) : (p \u2228 q) \u2228 p :=\n", "sideBar": false, "firstProofLineNumber": 61, "lastProofLineNumber": 64, "textBefore": "import data.int.basic -- hide\n\n/-\n# Logic and Proof (Or)\n\n## Level 2: Nested or introduction\n-/\n\n/-\n**Theorem**: Let $a$ and $b$ be integers. Suppose $h : a = b$. Then\n$(a = 5) \\lor ((a=b) \\lor (a=7))$.\n\n**Proof**: We have $h_2 : (a=b)\\lor (a=7)$ from left or introduction on $h$.\nWe show $(a = 5) \\lor ((a=b) \\lor (a=7))$ from right or introduction on $h_2$. \u220e\n-/\n\n/-\nThe same proof is represented in Lean below.\n-/\n\nexample (a b : \u2124) (h : a = b) : (a = 5) \u2228 ((a = b) \u2228 (a = 7)) :=\nbegin\n  have h\u2082 : (a = b) \u2228 (a = 7), from or.inl h,\n  show (a = 5) \u2228 ((a = b) \u2228 (a = 7)), from or.inr h\u2082,\nend\n\n/-\nFor a more succinct proof, we can skip the intermediate derivation of $(a=b) \\lor (a=7)$.\n\n**Proof**: The result follows by right or introduction applied to the result of\nleft or introduction on $h$. \u220e\n\nThis proof is shorter, but less readable. Here it is in Lean.\n-/\n\nexample (a b : \u2124) (h : a = b) : (a = 5) \u2228 ((a = b) \u2228 (a = 7)) :=\nbegin\n  from or.inr (or.inl h)\nend\n\n\n\nnamespace exlean -- hide\n\n/-\n### Tasks\n\n1. Replace `sorry` below with a Lean proof, using `have` to produce an intermediate proof. Recall\nthat `\u2228` is typed `\\or`.\n2. On a piece of paper, state and give a handwritten proof of this result.\n3. (Bonus) Give a one-line proof of the result.\n-/\n\nvariables (p q : Prop)\n\n/- Theorem : no-side-bar\nLet $p$ and $q$ be propostions. Suppose $h : q$. Then $(p \\lor q) \\lor p$ follows.\n-/\ntheorem nested_or1 (h : q) : (p \u2228 q) \u2228 p :=\nbegin\n", "proof": "  have h\u2081 : p \u2228 q, from or.inr h,\n  from or.inl h\u2081,\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 4, "editorText": "sorry", "lineOffset": 60, "name": "nested_or1", "statement": "(h : q) : (p \u2228 q) \u2228 p"}, {"type": "lean", "content": "375", "hidden": true}]}, {"name": "", "problemIndex": 16, "objects": [{"type": "lean", "content": "376", "hidden": true}, {"type": "text", "content": "377"}, {"type": "text", "content": "378"}, {"type": "lean", "content": "379", "hidden": false}, {"type": "text", "content": "380"}, {"type": "lean", "content": "381", "hidden": false}, {"type": "text", "content": "382"}, {"type": "text", "content": "383"}, {"type": "lean", "content": "384", "hidden": false}, {"type": "text", "content": "385"}, {"type": "lean", "content": "386", "hidden": false}, {"type": "tactic", "content": "387", "name": "left", "sideBar": true}, {"type": "tactic", "content": "388", "name": "right", "sideBar": true}, {"type": "lean", "content": "389", "hidden": true}, {"type": "text", "content": "390"}, {"type": "lean", "content": "391", "hidden": false}, {"type": "theorem", "text": "392", "lean": "theorem nested_or1 (h : q) : (p \u2228 (q \u2228 r)) \u2228 p :=\n", "sideBar": false, "firstProofLineNumber": 97, "lastProofLineNumber": 107, "textBefore": "import data.int.basic -- hide\n\n/-\n# Logic and Proof (Or)\n\n## Level 3: Backward or introduction\n-/\n\n/-\nIn the last level, we saw this rather terse proof.\n-/\n\nexample (a b : \u2124) (h : a = b) : (a = 5) \u2228 ((a = b) \u2228 (a = 7)) :=\nbegin\n  from or.inr (or.inl h)\nend\n\n/-\nWe also so a more readable version that requires the introduction of an additional hypothesis.\n-/\n\nexample (a b : \u2124) (h : a = b) : (a = 5) \u2228 ((a = b) \u2228 (a = 7)) :=\nbegin\n  have h\u2081 : (a = b) \u2228 (a = 7), from or.inl h,\n  show (a = 5) \u2228 ((a = b) \u2228 (a = 7)), from or.inr h\u2081,\nend\n\n/-\n### Backward or introduction\n\nA 'backward proof' of the above result avoids the introduction of additional hypotheses while\nremaining readable.\n\n**Proof**: It suffices, by right or introduction, to prove $(a = b)\\lor (a = 7)$.\nThis follows from left or introduction on $h$. \u220e\n\nRecall right or introduction takes $h : q$ and gives a proof of $p \\lor q$. When we use \nright or introduction backward, we replace the goal of proving $p \\lor q$ with the goal of\nproving $q$ (in the same context as the original goal).\n\nIn this backward proof, we write 'it suffices to prove' to indicate that the old goal is being\nreplaced with a new goal.\n-/\n\n/-\n### Backward or introduction in Lean\n\nIf the target is `\u22a2 p \u2228 q`, the tactic `right` replaces the goal with one of proving `q`.\nLikewise, the tactic `left` replaces the goal with that of proving `p`.\n-/\n\nexample (a b : \u2124) (h : a = b) : (a = 5) \u2228 ((a = b) \u2228 (a = 7)) :=\nbegin\n  right,\n  show (a = b) \u2228 (a = 7), from or.inl h,\nend\n\n/-\nWe can prove the same theorem entirely through backward applications of or introduction.\n-/\n\nexample (a b : \u2124) (h : a = b) : (a = 5) \u2228 ((a = b) \u2228 (a = 7)) :=\nbegin\n  right,\n  show (a = b) \u2228 (a = 7),\n  left,\n  show a = b, from h,\nend\n\n/- Tactic : left\n`left` changes a goal of proving `p \u2228 q` into a goal of proving `p`.\n-/\n\n/- Tactic : right\n`right` changes a goal of proving `p \u2228 q` into a goal or proving `q`.\n-/\n\nnamespace exlean -- hide\n\n/-\n### Task\n\n1. Replace `sorry` below with a backward Lean proof via the `left` and `right` tactics. Make your\nproof more readable by using the `show` tactic each time the goal changes.\n2. On a piece of paper, state and give a handwritten proof of this result.\n3. (Bonus) Write a one-line proof that uses only `from` and forward or introduction.\n-/\n\nvariables (p q r : Prop)\n\n/- Theorem : no-side-bar\nLet $p$, $q$, $r$ be propostions. Suppose $h : q$. Then $(p \\lor (q \\lor r)) \\lor p$\nfollows.\n-/\ntheorem nested_or1 (h : q) : (p \u2228 (q \u2228 r)) \u2228 p :=\nbegin\n", "proof": "  left,\n  show p \u2228 (q \u2228 r),\n  right,\n  show q \u2228 r,\n  left,\n  from h,\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 11, "editorText": "sorry", "lineOffset": 96, "name": "nested_or1", "statement": "(h : q) : (p \u2228 (q \u2228 r)) \u2228 p"}, {"type": "lean", "content": "393", "hidden": true}]}, {"name": "", "problemIndex": 16, "objects": [{"type": "lean", "content": "394", "hidden": true}, {"type": "text", "content": "395"}, {"type": "text", "content": "396"}, {"type": "text", "content": "397"}, {"type": "lean", "content": "398", "hidden": false}, {"type": "text", "content": "399"}, {"type": "text", "content": "400"}, {"type": "lean", "content": "401", "hidden": false}, {"type": "tactic", "content": "402", "name": "rw", "sideBar": true}, {"type": "tactic", "content": "403", "name": "norm_num", "sideBar": true}, {"type": "text", "content": "404"}, {"type": "lean", "content": "405", "hidden": true}, {"type": "text", "content": "406"}, {"type": "hint", "content": "407", "title": "408"}, {"type": "hint", "content": "409", "title": "410"}, {"type": "lean", "content": "411", "hidden": false}, {"type": "theorem", "text": "412", "lean": "theorem or_elim_cases (h : (x = 1) \u2228 ((x = 3) \u2227 (x > 0))) :\nx ^ 2 + 3 = 4 * x :=\n", "sideBar": false, "firstProofLineNumber": 145, "lastProofLineNumber": 155, "textBefore": "import data.int.basic tactic -- hide\n\n/-\n# Logic and Proof (Or)\n\n## Level 4: Decomposing or statements\n-/\n\n\n\n/-\nLet $x$ be a natural number (a non-negative integer). Suppose you are given the hypothesis\n$h : (x = 2) \\lor (x = 3)$. What can you prove?\n\nYou know *either* that $x = 2$ *or* you know $x = 3$ but you don't know which one holds.\nLet's label the two possibilities. Either $h_1 : x = 2$ or $h_2 : x = 3$.\n\n* On the assumption $h_1 : x = 2$, you know $x ^ 2 + 6 = 2 ^ 2 + 6 = 10 = 5x$.\n* On the assumption $h_2 : x = 3$, you know $x ^ 2 + 6 = 3 ^ 2 + 6 = 5x$.\n\nIn either case, you deduced $x ^ 2 + 6 = 5x$. Thus, it seems logical to say that\n$x ^ 2 + 6 = 5x$ follows from the original assumption $h : (x = 2) \\lor (x = 3)$.\n-/\n\n/-\n### Or elimination\n\nLet $p$, $q$, and $r$ be propositions. Let $h : p \\lor q$. The or elimination rule applied to $h$\nstates that if (1) $r$ can be deduced from the assumption of $p$ and (2) if $r$ can be deduced from\nthe assumption of $q$, then $r$ follows.\n\n### The `cases` tactic for decomposing an or statement\n\nIn Lean, one way to decompose an or statement is to use the `cases` tactic, as in the example below.\nWe'll soon discuss the the new tactics `rw` and `norm_num`.\n-/\n\nexample (x : \u2115) (h : (x = 2) \u2228 (x = 3)) : x ^ 2 + 6 = 5 * x :=\nbegin\n  cases h with h\u2081 h\u2082,\n  { rw (h\u2081 : x = 2),  -- The case h\u2081 : x = 2.\n    show 2 ^ 2 + 6 = 5 * 2, norm_num, }, \n  { rw (h\u2082 : x = 3),  -- The case h\u2082 : x = 3.\n    show 3 ^ 2 + 6 = 5 * 3, norm_num, },\nend\n\n/-\nIn the proof above, we start with two hypotheses, `x : \u2115` and `h : (x = 2) \u2228 (x = 3)`.\nThe target is `\u22a2 x ^ 2 + 6 = 5 * x`.\n\nThe effect of `cases h with h\u2081 h\u2082` here is to create two new goals. In the first goal, the original \n'or' hypothesis `h` is replaced with its left side, `h\u2081 : x = 2`. IN the second goal, `h` is\nreplaced with its right side, `h\u2082 : x = 3`.\n```\n 2 goals\n case or.inl\n x : \u2124,\n h\u2081 : x = 2\n \u22a2 x ^ 2 - 5 * x + 6 = 0\n \n case or.inr\n x : \u2124,\n h\u2082 : x = 3\n \u22a2 x ^ 2 - 5 * x + 6 = 0\n\n ```\n\nWhen we prove the first goal, we use the rewrite tactic, `rw` in the form `rw h\u2081` to replace\n`x` in the target with `2`. This leaves the goal of proving `2 ^ 2 + 6 = 5 * 2`.\nWe close this goal with the Lean tactic `norm_num`, suitable for proving various numerical\ngoals.\n-/\n\n/-\nThe proof above can be written more briefly by removing instances of `show` and the type annotations\nto `rw`. However, the resulting proof is harder to read.\n-/\n\nexample (x : \u2115) (h : (x = 2) \u2228 (x = 3)) : x ^ 2 + 6 = 5 * x :=\nbegin\n  cases h with h\u2081 h\u2082,\n  { rw h\u2081,\n    norm_num, }, \n  { rw h\u2082,\n    norm_num, },\nend\n\n\n\n/- Tactic : rw\nIf `h` is an equation of the form `p = q`, `rw h` rewrites replaces `p` in the target with `q`.\n\nIf `k` is in the context, `rw h at k` performs the rewrite at `k` instead of at the target.\n\n`rw \u2190h` will rewrite backward: every occurrence of `q` is replaced with `p`. Type `\\l` to produce `\u2190`.\n\n`rw [h1, h2, h3]` rewrites with multiple hypotheses (you aren't limited to three)!\n-/\n\n/- Tactic : norm_num\n\nThe `norm_num` tactic proves numerical goals. For example, it will close the goal\n`\u22a2 10 * 3 + 5 = 37 - 7`\n-/\n\n/-\nIf you were to write the proof 'by hand', you might write the following:\n\n> By definition, it suffices to show there exists an integer `m` such that `10 = 5 * m`.\n> Take `2` for `m`. Then we must show `10 = 5 * 2`.\n> This is true by arithmetic.\n-/\n\nnamespace exlean -- hide\n\n\n/-\n\n### Tasks\n\n1. Replace `sorry` below with a Lean proof, adapting the proof above.\n2. On a piece of paper, state and give a handwritten proof of this result.\n-/\n\n/- Hint: Starting the proof\nAs in the example, you can use `cases h with h\u2081 h\u2082` to decompose the 'or' statement `h`.\nAt later steps, you'll need to use the `rw` and `norm_num` tactics.\n-/\n\n/- Hint: Dealing with 'and'\nIf you followed the hint above, in the second goal, you'll have an 'and' hypothesis\n`h\u2082 : (x = 3) \u2227 (x > 0)` in the second goal. You can decompose this hypothesis using something like\n`cases h\u2082 with h\u2083 h\u2084`. Here, `h\u2083 : x = 3` and `h\u2084 : x > 0`.\n-/\n\nvariable (x : \u2115)\n\n/- Theorem : no-side-bar\nLet $x$ be a natural number. Suppose\n$h : (x = 1) \\lor ((x= 3) \\land (x > 0))$, then $x ^2 + 3 = 4 x$.\n-/\ntheorem or_elim_cases (h : (x = 1) \u2228 ((x = 3) \u2227 (x > 0))) :\nx ^ 2 + 3 = 4 * x :=\nbegin\n", "proof": "  cases h with h\u2081 h\u2082,\n  { rw h\u2081,\n    show 1 ^ 2 + 3 = 4 * 1, norm_num, },\n  { cases h\u2082 with h\u2083 h\u2084,\n    rw h\u2083,\n    show 3 ^ 2 + 3 = 4 * 3, norm_num, },\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n\nend exlean -- hide", "height": 11, "editorText": "sorry", "lineOffset": 144, "name": "or_elim_cases", "statement": "(h : (x = 1) \u2228 ((x = 3) \u2227 (x > 0))) :\nx ^ 2 + 3 = 4 * x"}, {"type": "lean", "content": "413", "hidden": true}]}, {"name": "", "problemIndex": 9, "objects": [{"type": "lean", "content": "414", "hidden": true}, {"type": "text", "content": "415"}, {"type": "text", "content": "416"}, {"type": "lean", "content": "417", "hidden": false}, {"type": "tactic", "content": "418", "name": "assume", "sideBar": true}, {"type": "lean", "content": "419", "hidden": true}, {"type": "text", "content": "420"}, {"type": "hint", "content": "421", "title": "422"}, {"type": "lean", "content": "423", "hidden": false}, {"type": "theorem", "text": "424", "lean": "theorem impl_intro1 : (a = b) \u2192 ((a = 5) \u2228 ((a = b) \u2228 (a = 7))) :=\n", "sideBar": false, "firstProofLineNumber": 66, "lastProofLineNumber": 73, "textBefore": "import data.int.basic tactic -- hide\n\n/-\n# Logic and Proof (Or)\n\n## Level 5: Implication\n-/\n\n/-\nBefore continuing or study of $\\lor$, we examine how to prove an implication.\n\n### Implication\n\nThe statement $(x = 2) \\to x ^ 2 = 4$ is an example of implication. It can be read, 'if $x = 2$, then $x^2 = 4$'.\n\nTo *prove* an implication $p \\to q$ is to assume $p$ and derive $q$.\n\n**Theorem**: $(x = 2) \\to (x ^2 = 4)$.\n\n**Proof**: Assume $h : x = 2$. We must prove $x ^ 2 = 4$. Rewriting with $h$, we must prove\n$2 ^ 2 = 4$. This follows by numerical calculation. \u220e\n\n### Proving implications in Lean\n\nTo prove `p \u2192 q` in Lean, start with `assume h : p` (replacing `h` with any other name). \nYou then need to prove `q`. The symbol `\u2192` is typed `\\r`.\n-/\n\nexample (x : \u2115) : (x = 2) \u2192 (x ^ 2 = 4) :=\nbegin\n  assume h : x = 2,\n  show x ^ 2 = 4,\n  rw (h : x = 2),\n  show 2 ^ 2 = 4, norm_num,\nend\n\n\n/- Tactic: assume\nIf the target is `\u22a2 p \u2192 q`, then `assume h : p` replaces the goal with one in which the target\nis `\u22a2 q` and in which the context contains the hypothesis `h : p`.\n-/\n\nnamespace exlean -- hide\n\n/-\n\n### Tasks\n\n1. Replace `sorry` below with a Lean proof.\n2. On a piece of paper, state and give a handwritten proof of this result.\n-/\n\n/- Hint: Starting the proof\nStart with `assume h : a = b,`\n\nThe remainder of the proof is identical to that of an example from an earlier level in this world.\n-/\n\nvariables (a b : \u2124)\n\n/- Theorem : no-side-bar\nLet $a$ and $b$ be integers. Then $(a = b) \\to ((a = 5) \\lor ((a = b) \\lor (a = 7)))$.\n-/\ntheorem impl_intro1 : (a = b) \u2192 ((a = 5) \u2228 ((a = b) \u2228 (a = 7))) :=\nbegin\n", "proof": "  assume h : a = b,\n  right,\n  left,\n  from h,\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 8, "editorText": "sorry", "lineOffset": 65, "name": "impl_intro1", "statement": "(a = b) \u2192 ((a = 5) \u2228 ((a = b) \u2228 (a = 7)))"}, {"type": "lean", "content": "425", "hidden": true}]}, {"name": "", "problemIndex": 11, "objects": [{"type": "lean", "content": "426", "hidden": true}, {"type": "text", "content": "427"}, {"type": "text", "content": "428"}, {"type": "axiom", "content": "429", "name": "or.elim", "sideBar": true}, {"type": "lean", "content": "430", "hidden": false}, {"type": "text", "content": "431"}, {"type": "lean", "content": "432", "hidden": false}, {"type": "text", "content": "433"}, {"type": "lean", "content": "434", "hidden": true}, {"type": "text", "content": "435"}, {"type": "lean", "content": "436", "hidden": false}, {"type": "theorem", "text": "437", "lean": "theorem or_elim_example (h : p \u2228 q) : q \u2228 p :=\n", "sideBar": false, "firstProofLineNumber": 117, "lastProofLineNumber": 128, "textBefore": "import data.int.basic tactic -- hide\n\n/-\n# Logic and Proof (Or)\n\n## Level 6: Or elimination (again)\n-/\n\n/-\n### Or elimination\n\nWe'll restate the or elimination rule from a previous level.\n\nLet $p$, $q$, and $r$ be propositions. Let $h : p \\lor q$. Let $h_1$ be a proof that $p$ implies $r$.\nLet $h_2$ be a proof that $q$ implies $r$.\n\nThe or elimination rule applied to $h$, $h_1$, and $h_2$ produces a proof of $r$.\n\n### A forward or elimination proof\n\n\n**Theorem**: Let $x$ be a natural number. Suppose $h : (x = 2) \\lor (x = 3)$. Then\n$x ^ 2 + 6 = 5x$.\n\n**Proof**: We have $h_1 : (x = 2) \\to x ^ 2 + 6 = 5x$:\n\n> Assume $H_2 : x = 2$. We must show $x ^ 2 + 6 = 5x$. Rewriting with $H_2$,\n> $\\vdash 2 ^ 2 + 6 = 5 \\times 2$, which holds by numerical calculation.\n \nWe have $h_2 : (x = 3) \\to x ^ 2 + 6 = 5x$:\n\n> Assume $H_3 : x = 3$. We must show $x ^ 2 + 6 = 5x$. Rewriting with $H_3$,\n> $\\vdash 3 ^ 2 + 6 = 5 \\times 3$, which holds by numerical calculation.\n\nThe result follows by or elimination on $h$, $h_1$, and $h_2$. \u220e\n\n### Or elimination in lean\n\nThe Lean or elimination theorem is called `or.elim`. For propositions, `p`, `q`, and `r`, if\n`h : p \u2228 q`, `h\u2081 : p \u2192 r`, and `h\u2082 : q \u2192 r`, then `or.elim h h\u2081 h\u2082` is a proof of `r`.\n\n-/\n\n/- Axiom: or.elim\n  (h : p \u2228 q) (h\u2081 : p \u2192 r) (h\u2082 : q \u2192 r) : r\n-/\n\nexample (x : \u2115) (h : (x = 2) \u2228 (x = 3)) : x ^ 2 + 6 = 5 * x :=\nbegin\n  have h\u2081 : (x = 2) \u2192 (x ^ 2 + 6 = 5 * x),\n  { assume H\u2082 : x = 2,\n    show x ^ 2 + 6 = 5 * x,\n    rw H\u2082,\n    show 2 ^ 2 + 6 = 5 * 2, norm_num, },\n\n  have h\u2082 : (x = 3) \u2192 (x ^ 2 + 6 = 5 * x),\n  { assume H\u2083 : x = 3,\n    show x ^ 2 + 6 = 5 * x,\n    rw H\u2083,\n    show 3 ^ 2 + 6 = 5 * 3, norm_num, },\n  from or.elim h h\u2081 h\u2082,\nend\n\n/-\nThis forward proof is somewhat long-winded and requires introducing intermediate hypotheses.\nAn alternative approach is to have a mixed forward / backward proof using `apply or.elim`:\n-/\n\nexample (x : \u2115) (h : (x = 2) \u2228 (x = 3)) : x ^ 2 + 6 = 5 * x :=\nbegin\n  apply or.elim h,\n  { assume h\u2081 : x = 2,\n    rw h\u2081,\n    show 2 ^ 2 + 6 = 5 * 2, refl, }, \n  { assume h\u2082 : x = 3,\n    rw h\u2082,\n    show 3 ^ 2 + 6 = 5 * 3,\n    refl, }, -- The case h\u2082 : x = 3\nend\n\n/-\nAfter typing `apply or.elim h` in the proof above, we are left with two goals, each an implication.\n```\n 2 goals\n x : \u2115,\n h : x = 2 \u2228 x = 3\n \u22a2 x = 2 \u2192 x ^ 2 + 6 = 5 * x\n \n x : \u2115,\n h : x = 2 \u2228 x = 3\n \u22a2 x = 3 \u2192 x ^ 2 + 6 = 5 * x\n  ```\n\nThe approach shares features with the use of `cases` to decompose an `\u2228` statement.\n-/\n\n\nnamespace exlean -- hide\n\n/-\n\n### Tasks\n\n1. Replace `sorry` below with a Lean proof, using `cases` to decompose `h`\n2. Delete your proof and write a proof using `apply or.elim h`.\n3. Delete this proof and write a forward proof that else with `from or.elim h h\u2081 h\u2082`.\n4. On a piece of paper, state and give handwritten proofs of this result.\n-/\n\nvariables (p q : Prop)\n\n/- Theorem : no-side-bar\nLet $p$ and $q$. Suppose $h : p \\lor q$. Then $q \\lor p$ follows.\n-/\ntheorem or_elim_example (h : p \u2228 q) : q \u2228 p :=\nbegin\n", "proof": "/-   cases h with h\u2081 h\u2082,\n  { from or.inr h\u2081, },\n  { from or.inl h\u2082, }, -/\n  apply or.elim h,\n  { assume hp : p,\n    from or.inr hp, },\n  { assume hq : q,\n    from or.inl hq, },\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 12, "editorText": "sorry", "lineOffset": 116, "name": "or_elim_example", "statement": "(h : p \u2228 q) : q \u2228 p"}, {"type": "lean", "content": "438", "hidden": true}]}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "439", "hidden": true}, {"type": "text", "content": "440"}, {"type": "text", "content": "441"}, {"type": "lean", "content": "442", "hidden": true}, {"type": "text", "content": "443"}, {"type": "lean", "content": "444", "hidden": false}, {"type": "theorem", "text": "445", "lean": "theorem or_and_mastery : p \u2227 (q \u2228 r) \u2192 (p \u2227 q) \u2228 (p \u2227 r) :=\n", "sideBar": false, "firstProofLineNumber": 75, "lastProofLineNumber": 92, "textBefore": "import data.int.basic tactic -- hide\n\n/-\n# Logic and Proof (Or)\n\n## Level 7: Or summary\n-/\n\n/-\n### Introduction and elimination\n\nThe $\\lor$ symbol is defined by two principles.\n\n1. Or introduction. Let $p$ and $q$ be propostions.\n    * Left or introduction on $h : p$ gives a proof of $p \\lor q$.\n    * Right or introduction on $h : q$ gives a proof of $p \\lor q$.\n2. Or elimination. Let $p$, $q$, and $r$ be propositions. Let $h : p \\lor q$, $h_1 : p$, and\n$h_2 : q$. Then or elimination on $h$, $h_1$, and $h_2$ gives a proof of $r$.\n\nIn Lean, the principles are as follows.\n\n1. Or introduction. Let `p` and `q` be propositions.\n    * Let `h : p`. Then `or.inl h` is a proof of `p \u2228 q`.\n    * Let `h : q`. Then `or.inr h` is a proof of `p \u2228 q`.\n2. Or elimination. Let `p`, `q`, and `r` be propositions. Let `h : p \u2228 q`, `h\u2081 : p \u2192 r`, and\n`h\u2082 : q \u2192 r`. Then `or.elim h h\u2081 h\u2082` is a proof of `r`.\n\n### Or tactics\n\nUsing the `left`, `right`, and `cases` tactics, we can write backward proofs involving `\u2228`.\n\n1. Or introduction. Let `p` and `q` be propositions. Suppose `\u22a2 p \u2228 q` is the target.\n    * `left` changes the goal to `\u22a2 p`.\n    * `right` changes to goal to `\u22a2 q`.\n2. Let `p`, `q`, `r` be propositions. Suppose `h : p \u2228 q`. If the target is `\u22a2 r`, then\n`cases h with h\u2081 h\u2082` replaces the current goal with two new goals:\n    a. A goal in which `h` has been replaced with `h\u2081 : p` and\n    b. a goal in which `h` has been replaced with `h\u2082 : q`.\nIn both cases the target remains as `\u22a2 r`.\n\n### `apply`, `rw`, `norm_num`, `assume`\n\n* `apply` is a general-purpose tactic for writing mixed forward / backward proofs. Supply\n`apply` with the name of a theorem, some conditions for the theorem, and a suitable number of\nwildcards. Lean will either close the goal or open enough new goals to account for the missing\nconditions.\n* `rw` is used for substitutions. For example, if `h : x = 5` and `\u22a2 x + y = 6`, then\n`rw h` will change the target to `\u22a2 5 + y = 6`.\n* `norm_num` proves numerical goals, such as `5 * 7 + 4 = 39`.\n* `assume` is used in proving implications. To prove `p \u2192 q` is to first `assume h : p` and then\nderive `q` on this assumption.\n-/\n\nnamespace exlean -- hide\n\n/-\nWe end this world with a challenge question that will test your understanding of all the rules\nof introduction and elimination for `\u2227` and `\u2228`.\n\n### Tasks\n\n1. Replace `sorry` below with a Lean proof.\n2. On a piece of paper, state and give a handwritten proof of this result.\n3. (Bonus) What's the shortest Lean proof you can write? What proof is most readable? Can you\nexplain your proof to your friends?\n-/\n\nvariables (p q r : Prop)\n\n/- Theorem : no-side-bar\nLet $p$ and $q$. Suppose $h : p \\lor q$. Then $q \\lor p$ follows.\n-/\ntheorem or_and_mastery : p \u2227 (q \u2228 r) \u2192 (p \u2227 q) \u2228 (p \u2227 r) :=\nbegin\n", "proof": "/-   assume h : p \u2227 (q \u2228 r),\n  cases h with hp hqr,\n  cases hqr with hq hr,\n  { left,\n    from and.intro hp hq, },\n  { right,\n    from and.intro hp hr, }, -/\n\n/-   assume h : p \u2227 (q \u2228 r),\n  cases h.right with hq hr,\n  { from or.inl (and.intro h.left hq), },\n  { from or.inr (and.intro h.left hr), }, -/\n\n  \n  from assume h, or.elim h.right (assume hq, or.inl (and.intro h.left hq)) (assume hr, or.inr (and.intro h.left hr)),\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 18, "editorText": "sorry", "lineOffset": 74, "name": "or_and_mastery", "statement": "p \u2227 (q \u2228 r) \u2192 (p \u2227 q) \u2228 (p \u2227 r)"}, {"type": "lean", "content": "446", "hidden": true}]}], "parents": [1]}, {"name": "447", "levels": [{"name": "", "problemIndex": 11, "objects": [{"type": "lean", "content": "448", "hidden": true}, {"type": "text", "content": "449"}, {"type": "text", "content": "450"}, {"type": "text", "content": "451"}, {"type": "lean", "content": "452", "hidden": false}, {"type": "text", "content": "453"}, {"type": "lean", "content": "454", "hidden": false}, {"type": "text", "content": "455"}, {"type": "hint", "content": "456", "title": "457"}, {"type": "hint", "content": "458", "title": "459"}, {"type": "lean", "content": "460", "hidden": true}, {"type": "theorem", "text": "461", "lean": "theorem all_elim1 (h : \u2200 x, f(x + 2) = f(x)) :\n(f(2) = f(0)) \u2227 (f(5) = f(1)) :=\n", "sideBar": false, "firstProofLineNumber": 125, "lastProofLineNumber": 135, "textBefore": "import tactic -- hide\n\n/-\n# Variables\n\n## Level 1: Introduction to variables; for all elimination\n-/\n\n\n\n/-\nLet $x$ be an integer variable. Consider the following equations:\n\n* $(x - 1) ^ 2 = x ^2 - 2x + 1$,\n* $x ^ 2 + x - 6 = 0$,\n* $x ^ 2 + 1 = 0$.\n\nOne of them holds for every $x$, one only for certain $x$, and one for no $x$.\n\nNone of the equations, by itself, is a full mathematical statement. The following *are* complete\nmathematical statements, each of which can be proved.\n\n* For every $x : \\mathbb Z$, we have $(x - 1)^2 = x^2 - 2x + 1$.\n* It's not the case that for every $x : \\mathbb Z$, we have $x^2 + x - 6 = 0$.\n* There exists an $x : \\mathbb Z$ such that $x ^ 2 + x - 6 = 0$.\n* There does not exist and $x : \\mathbb Z$ such that $x^2 + 1 = 0$.\n-/\n\n/-\n### For all statements\n\nThe symbol $\\forall$ is read 'for all' or 'for every'. Thus,\n$\\forall (x : \\mathbb Z), (x - 1) ^ 2 = x ^2 - 2x + 1$ is a short way of writing, 'for every\ninteger $x$, $(x-1)^2 = x^2 - 2x + 1$'.\n\nIn Lean, we write `\u2200` as `\\all`, so the mathematical statement above is written in Lean as\n```\n\u2200 (x : \u2124), (x - 1) ^ 2 = x ^ 2 - 2x + 1\n```\n\n### For all elimination\n\nLet $h$ be a proof of $\\forall (x : \\mathbb Z), (x - 1) ^ 2 = x ^2 - 2x + 1$. Part of the meaning\nof $h$ is that $(x - 1) ^ 2 = x ^2 - 2x + 1$ holds no matter what *particular* integer value is\nsubsituted for $x$.\n\nWith the above definitions, for all elimination with $h$ and $3$ gives a proof of\n$(3-1)^2 = 3 ^ 2 - 2 \\times 3 + 1$.\n\n\n### For all elimination in Lean\n\nLet `h` be a proof of a 'for all' statement (such as `\u2200 (x : \u2115), x ^ 2 \u2265 0`) and let `a` be a\nparticular quantity (such as `4`). Then `h a` is a proof of the specialised statement\n(in this case, `4 ^ 2 \u2265 0`).\n-/\n\nexample (h : \u2200 (x : \u2115), x ^ 2 \u2265 0) : 4 ^ 2 \u2265 0 :=\nbegin\n  from h 4,\nend\n\n/-\n### A fun example\n\n**Theorem**: Let $f$ be a function from the natural numbers to the\nnatural numbers. Let $h$ be the assumption that for every $x$, $f(x) > x^2$. Then\n$f(2) > 4$ and $f(3) > 9$.\n\nThis theorem can be stated more formally.\n\n**Theorem**: Let $f : \\mathbb N \\to \\mathbb N$, let $h : \\forall x, f(x) > x ^2$. Then \n$(f(2) > 4) \\land (f(3) > 9)$.\n\n**Proof**: By and introduction, it suffices to prove (1) $f(2) > 4$ and (2) $f(3) > 9$.\n1. We show $f(2) > 4$ by for all elimination with $h$ and $2$.\n2. We show $f(3) > 9$ by for all elimination with $h$ and $3$. \u220e\n\nThe same result is proved in Lean as follows.\n-/\n\nvariable (f : \u2115 \u2192 \u2115)\n\nexample (h : \u2200 (x : \u2115), f(x) > x ^ 2) : (f(2) > 4) \u2227 (f(3) > 9) :=\nbegin\n  split,\n  { show f(2) > 4, from h 2, },\n  { show f(3) > 9, from h 3, },\nend\n\n\n/-\n\n### Tasks\n\n1. Replace `sorry` below with a Lean proof, adapting the proof above.\n2. On a piece of paper, state and give a handwritten proof of this result.\n-/\n\n\n/- Hint : Starting the proof\nAs the target is an `\u2227` statement, you can start with a `split`, creating new goals for the\nleft side and right side of the `\u2227`.\n\nYou can close the first goal in a similar manner to the proof above\n-/\n\n/- Hint : The second goal\nProving the second goal requires a bit more thought. A single application of for all\nelimination won't suffice. Instead, you can close the second goal with two `rw`s (rewrites).\nProvide each `rw` with an equation of the form `f(a + 2) = f(a)` for an appropriate choice of `a`,\nby for all elimination.\n-/\n\nnamespace exlean -- hide\n\n\n/- Theorem : no-side-bar\nLet $f : \\mathbb N \\to \\mathbb N$ be a function. Let $h$ be the assumption that \n$\\forall x, f(x + 2) = f(x)$. Then $f(2) = f(0)$ and $f(5) = f(1)$.\n-/\ntheorem all_elim1 (h : \u2200 x, f(x + 2) = f(x)) :\n(f(2) = f(0)) \u2227 (f(5) = f(1)) :=\nbegin\n", "proof": "  split,\n  { show f(2) = f(0), from h 0 },\n  { rw h 3,\n    rw h 1, }  \n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n\nend exlean -- hide", "height": 11, "editorText": "sorry", "lineOffset": 124, "name": "all_elim1", "statement": "(h : \u2200 x, f(x + 2) = f(x)) :\n(f(2) = f(0)) \u2227 (f(5) = f(1))"}, {"type": "lean", "content": "462", "hidden": true}]}, {"name": "", "problemIndex": 7, "objects": [{"type": "lean", "content": "463", "hidden": true}, {"type": "text", "content": "464"}, {"type": "text", "content": "465"}, {"type": "lean", "content": "466", "hidden": false}, {"type": "text", "content": "467"}, {"type": "hint", "content": "468", "title": "469"}, {"type": "lean", "content": "470", "hidden": true}, {"type": "theorem", "text": "471", "lean": "theorem all_intro1 (h : \u2200 x, f(x + 1) = f(x)) :\n\u2200 y, (f(y + 1) = f(y)) \u2228 (f(y) = 0) :=\n", "sideBar": false, "firstProofLineNumber": 57, "lastProofLineNumber": 65, "textBefore": "import tactic -- hide\n\n/-\n# Variables\n\n## Level 2: For all introduction\n-/\n\n/-\nWe've seen how to *apply* for all statements. How do you *prove* a for all statement?\n\n**Theorem**: Let $f : \\mathbb Z \\to \\mathbb Z$ be a function. Let $h$ be the assumption that\nfor every $x$, $-5 < f(x)$ and $f(x) < 5$. Then, for every integer $y$, $f(y) < 5$.\n\n**Proof**: Assume $y$ is an integer. We must show $f(y) < 5$. \nWe have $h\u2081 : -5 < f(y) \\land f(y) < 5$ from for all elimination on $h$ and $y$.\nThe result follows from right and elimination on $h_1$. \u220e\n\nAs illustrated above, to prove something happens for every $x$ is to assume $y$ is a variable\nquantity and then to demonstrate that the desired property holds for that $y$.\n-/\n\nvariable (f : \u2124 \u2192 \u2124)\n\nexample (h : \u2200 x, -5 < f(x) \u2227 f(x) < 5) : \u2200 y, f(y) < 5 :=\nbegin\n  assume y : \u2124,\n  show f(y) < 5,\n  have h\u2081 : -5 < f(y) \u2227 f(y) < 5, from h y,\n  from and.elim_right h\u2081,\nend\n\n\n\n/-\n\n### Tasks\n\n1. Replace `sorry` below with a Lean proof.\n2. On a piece of paper, state and give a handwritten proof of this result.\n-/\n\n/- Hint: Starting the proof\nBegin with `assume y : \u2124`. This changes the goal to one of showing `f(y + 1) = f(y) \u2228 f(y) = 0`.\n-/\n\nnamespace exlean -- hide\n\n\n/- Theorem : no-side-bar\nLet $f : \\mathbb Z \\to \\mathbb Z$ be a function. Let $h$ be the assumption that for every\ninteger $x$, $f(x+1)=f(x)$. Then, for every integer $y$, $f(y+1) = f(y)$ or $f(y) = 0$.\n-/\ntheorem all_intro1 (h : \u2200 x, f(x + 1) = f(x)) :\n\u2200 y, (f(y + 1) = f(y)) \u2228 (f(y) = 0) :=\nbegin\n", "proof": "  assume y : \u2124,\n  show f(y + 1) = f(y) \u2228 f(y) = 0,\n  left,\n  from h y,\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n\nend exlean -- hide", "height": 9, "editorText": "sorry", "lineOffset": 56, "name": "all_intro1", "statement": "(h : \u2200 x, f(x + 1) = f(x)) :\n\u2200 y, (f(y + 1) = f(y)) \u2228 (f(y) = 0)"}, {"type": "lean", "content": "472", "hidden": true}]}, {"name": "", "problemIndex": 8, "objects": [{"type": "lean", "content": "473", "hidden": true}, {"type": "text", "content": "474"}, {"type": "text", "content": "475"}, {"type": "lean", "content": "476", "hidden": false}, {"type": "tactic", "content": "477", "name": "use", "sideBar": true}, {"type": "text", "content": "478"}, {"type": "hint", "content": "479", "title": "480"}, {"type": "lean", "content": "481", "hidden": true}, {"type": "theorem", "text": "482", "lean": "theorem use_1 : \u2203 (x : \u2115), 2 * x ^ 2 + 5 * x - 30 = 22 :=\n", "sideBar": false, "firstProofLineNumber": 69, "lastProofLineNumber": 75, "textBefore": "import tactic -- hide\n\n/-\n# Variables\n\n## Level 3: Proving 'there exists' statements with `use`\n-/\n\n/-\n### There exist statements\n\nIn this level, you'll see how to prove 'there exists' statements. A 'there exists' statement\nasserts that there exists $x$ for which a property, depending on $x$, holds.\n\nTo prove a 'there exists' statement is to provide (1) a particular value $m$ and (2) a proof that\nthe property holds for $m$.\n\nHere is an example.\n\n**Theorem**: There exists a natural number $x$ such that $x ^ 2 + x = 6$.\n\n**Proof**: Take $2$ for $x$. We must show $2 ^ 2 + 2 = 6$. This holds by numerical\ncalculation. \u220e\n\nWe use the notation $\\exists$ for 'there exists. With this notation, the statement of the above\ntheorem is $\\exists (x : \\mathbb N), x ^ 2 + x = 6$.\n\nLean uses the notation `\u2203` for 'there exists'. The symbol `\u2203` is typed `\\ex`.\nBelow, we use the tactic `use` in the proof of the 'there exists' statement. The effect of\n`use 2` is to replace the goal `\u2203 (x : \u2115), x ^ 2 + x = 6` with the goal of proving `2 ^ 2 + 2 = 6`.\n-/\n\nexample : \u2203 (x : \u2115), x ^ 2 + x = 6 :=\nbegin\n  use 2,\n  show 2 ^ 2 + 2 = 6, norm_num,\nend\n\n/- Tactic : use\nIf the goal is `\u22a2 \u2203 (x : \u03b1), P x` and if `y : \u03b1`, then `use y` changes the goal to\n`\u22a2 P y`.\n\n### Example\nWith a goal `\u22a2 \u2203 (x : \u2124), x + 5 = 23`, typing `use 18` changes the goal to `\u22a2 18 + 5 = 23`.\n-/\n\n\n/-\n\n### Tasks\n\n1. Replace `sorry` below with a Lean proof.\n2. On a piece of paper, state and give a handwritten proof of this result.\n-/\n\n/- Hint: Starting the proof\nDo some work on paper to determine what value $m$ you should take for `x`. Then try\n`use `$m$\n-/\n\nnamespace exlean -- hide\n\n\n/- Theorem : no-side-bar\nThere exists a natural number $x$ such that $2x^2 + 5x - 30 = 22$.\n-/\ntheorem use_1 : \u2203 (x : \u2115), 2 * x ^ 2 + 5 * x - 30 = 22 :=\nbegin\n", "proof": "  use 4,\n  show 2 * 4 ^ 2 + 5 * 4 - 30 = 22,\n  norm_num,\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n\nend exlean -- hide", "height": 7, "editorText": "sorry", "lineOffset": 68, "name": "use_1", "statement": "\u2203 (x : \u2115), 2 * x ^ 2 + 5 * x - 30 = 22"}, {"type": "lean", "content": "483", "hidden": true}]}, {"name": "", "problemIndex": 8, "objects": [{"type": "lean", "content": "484", "hidden": true}, {"type": "text", "content": "485"}, {"type": "text", "content": "486"}, {"type": "text", "content": "487"}, {"type": "axiom", "content": "488", "name": "exists.intro", "sideBar": true}, {"type": "lean", "content": "489", "hidden": false}, {"type": "text", "content": "490"}, {"type": "lean", "content": "491", "hidden": true}, {"type": "theorem", "text": "492", "lean": "theorem exists_intro11 : \u2203 (x : \u2115), 2 * x ^ 2 + 5 * x - 30 = 22 :=\n", "sideBar": false, "firstProofLineNumber": 58, "lastProofLineNumber": 63, "textBefore": "import tactic -- hide\n\n/-\n# Variables\n\n## Level 4: Exists introduction\n-/\n\n/-\n### Exists introduction\n\nIn the last level, we saw backward proofs of 'there exist' statements. For example, in our\nproof that there exists a natural number $x$ such that $x ^ 2 + x = 6$, we started by taking\n$2$ for $x$. This left us with the goal of proving $2 ^ 2 + 2 = 6$.\n\nThe more fundamental principle is *exists introduction*: given (1) a term $m$ and (2) a proof\n$h$ that $m$ satisfies some property, exists introduction produces a proof that there exists $x$\nsuch that the property holds for $x$.\n\n**Theorem**: There exists a natural number $x$ such that $x ^ 2 + x = 6$.\n\n**Proof**: By numerical calculation, we have $h : 2 ^ 2 + x = 6$. The result follows from exists\nintroduction with $2$ and $h$. \u220e\n-/\n\n/-\n### Exists introduction in Lean\n\nThe exists introduction rule is called `exists.intro` in Lean.\n-/\n\n/- Axiom: exists.intro\n  (m : \u03b1) (h : P m) : \u2203 (x : \u03b1), P x\n-/\n\nexample : \u2203 (x : \u2115), x ^ 2 + x = 6 :=\nbegin\n  have h : 2 ^ 2 + 2 = 6, norm_num,\n  from exists.intro 2 h,\nend\n\n/-\n\n### Tasks\n\n1. Replace `sorry` below with a Lean proof, adapting the proof above. Use `exists.intro` instead of\n`use`.\n2. On a piece of paper, state and give a handwritten proof of this result.\n-/\n\nnamespace exlean -- hide\n\n/- Theorem : no-side-bar\nThere exists a natural number $x$ such that $2x^2 + 5x - 30 = 22$.\n-/\ntheorem exists_intro11 : \u2203 (x : \u2115), 2 * x ^ 2 + 5 * x - 30 = 22 :=\nbegin\n", "proof": "  have h : 2 * 4 ^ 2 + 5 * 4 - 30 = 22, norm_num,\n  from exists.intro 4 h,\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n\nend exlean -- hide", "height": 6, "editorText": "sorry", "lineOffset": 57, "name": "exists_intro11", "statement": "\u2203 (x : \u2115), 2 * x ^ 2 + 5 * x - 30 = 22"}, {"type": "lean", "content": "493", "hidden": true}]}, {"name": "", "problemIndex": 10, "objects": [{"type": "lean", "content": "494", "hidden": true}, {"type": "text", "content": "495"}, {"type": "text", "content": "496"}, {"type": "text", "content": "497"}, {"type": "lean", "content": "498", "hidden": false}, {"type": "text", "content": "499"}, {"type": "tactic", "content": "500", "name": "linarith", "sideBar": true}, {"type": "lean", "content": "501", "hidden": false}, {"type": "text", "content": "502"}, {"type": "lean", "content": "503", "hidden": true}, {"type": "theorem", "text": "504", "lean": "theorem exists_elim1 (h : \u2203 (x : \u2124), f(2 * x) > 5) :\n\u2203 (y : \u2124), f(2 * y - 10) > 5 :=\n", "sideBar": false, "firstProofLineNumber": 99, "lastProofLineNumber": 108, "textBefore": "import tactic -- hide\n\n/-\n# Variables\n\n## Level 5: Decomposing an exists statement with `cases`\n-/\n\n/-\n### Decomposing exists statements\n\nIn the last level, we saw how to *prove* an exists statment. What if you're given an \nexists statement? What can you *do* with it?\n\n**Theorem**: Let $f : \\mathbb Z \\to \\mathbb Z$. Let $h$ be the assumption that there exists\nan integer $x$ such that $f(x + 2) > 5$. Then there exists an integer $y$ such that $f(y) > 5$.\n\n**Proof**: Decomposing $h$ gives an integer $m$ and the hypothesis $h_2 : f(m + 2) > 5$. \nTake $m + 2$ for $y$. We must show $f(m + 2) > 5$. This follows from $h_2$. \u220e\n\nMore formally, the statement of the theorem is: suppose $f : \\mathbb Z \\to \\mathbb Z$ and suppose\n$h : \\exists (x : \\mathbb Z), f(x) > 5$. Then $\\exists (y : \\mathbb Z), f(y + 2) > 5$.\n\nAn important observation about the proof above is that the assumption\n$h : \\exists (x : \\mathbb Z), f(x) > 5$ is *not the same* as asserting that $x$ *is* an integer\nfor which $f(x) > 5$.\n\nThe $x$ in the statement $h$ is to be thought of as a 'potential' quantity. We can replace it with\nany other variable name. Thus $h$ is *the same* as the assumption \n$\\exists (t : \\mathbb Z), f(t) > 5$.\n\nWhen we decompose $h$, we commit to a name for this potential variable (in the proof above, $m$) and\nwe commit to assertion about $m$ (in the proof above, $h_2 : f(m) > 5$).\n-/\n\n/-\n### The `cases` tactic\n\nThe `cases` tactic performs this decomposition in Lean. Below, `cases h with m h\u2082` \nreplaces `h : \u2203 (x : \u2124), f(x + 2) > 5` with `m : \u2124` and `h\u2082 : f(m + 2) > 5`.\n-/\n\nvariable (f : \u2124 \u2192 \u2124)\n\nexample (h : \u2203 (x : \u2124), f(x + 2) > 5) : \u2203 (y : \u2124), f(y) > 5 :=\nbegin\n  cases h with m h\u2082,\n  use m + 2,\n  show f(m + 2) > 5, from h\u2082,\nend\n\n\n/-\n### Doing linear arithmetic in Lean\n\n**Theorem**: Let $f : \\mathbb Z \\to \\mathbb Z$. Let $z$ be an integer. Let $h$ be the assumption\nthat there exists an integer $x$ such that $f(x) > 5$. Then there exists an integer $y$ such that\n$f(y + z) > 5$.\n\n**Proof**: Decomposing $h$ gives an integer $m$ and the hypothesis $h_2 : f(m) > 5$. \nTake $m - z$ for $y$. We must show $f((m - z) + z) > 5$. We rewrite this goal, by arithmetic,\nto one of showing $f(m) > 5$. This follows from $h_2$.\n\nNote that though one can prove $f((m-z) + z) > 5$ is equivalent to $f(m) > 5$, these two statements\nare not identical. It's for this reason that we need to perform arithmetic to show the former\nstatement can be rewritten as the former.\n\nLean proves arithmetic results using the tactic `linarith`.\n-/\n\n/- Tactic: linarith\n`linarith` can prove linear equations and inequalities.\n-/\n\nvariable (z : \u2124)\n\nexample (h : \u2203 (x : \u2124), f(x) > 5) : \u2203 (y : \u2124), f(y + z) > 5 :=\nbegin\n  cases h with m h\u2082,\n  use m - z,\n  rw (show (m - z) + z = m, by linarith),\n  from h\u2082,\nend\n/-\n\n### Tasks\n\n1. Replace `sorry` below with a Lean proof, adapting the proof above. \n2. On a piece of paper, state and give a handwritten proof of this result.\n-/\n\nnamespace exlean -- hide\n\n/- Theorem : no-side-bar\n-/\ntheorem exists_elim1 (h : \u2203 (x : \u2124), f(2 * x) > 5) :\n\u2203 (y : \u2124), f(2 * y - 10) > 5 :=\nbegin\n", "proof": "  cases h with m h\u2082,\n  use m + 5,\n  rw (show 2 * (m + 5) - 10 = 2 * m, by linarith),\n  from h\u2082,\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n\nend exlean -- hide", "height": 10, "editorText": "sorry", "lineOffset": 98, "name": "exists_elim1", "statement": "(h : \u2203 (x : \u2124), f(2 * x) > 5) :\n\u2203 (y : \u2124), f(2 * y - 10) > 5"}, {"type": "lean", "content": "505", "hidden": true}]}, {"name": "", "problemIndex": 8, "objects": [{"type": "lean", "content": "506", "hidden": true}, {"type": "text", "content": "507"}, {"type": "text", "content": "508"}, {"type": "lean", "content": "509", "hidden": true}, {"type": "lean", "content": "510", "hidden": false}, {"type": "text", "content": "511"}, {"type": "lean", "content": "512", "hidden": false}, {"type": "text", "content": "513"}, {"type": "theorem", "text": "514", "lean": "theorem all_intro_elim2 (h : \u2200 (x : X), P(x)) :\n\u2200 (z : X), Q(z) \u2228 P(z) :=\n", "sideBar": false, "firstProofLineNumber": 101, "lastProofLineNumber": 109, "textBefore": "import tactic -- hide\n\n/-\n# Variables\n\n## Level 6: Predicates\n-/\n\n/-\nWe've informally described 'for all' elimination. We said that if a property holds for every $x$,\nthen that property holds if a particular value is substituted for $x$.\n\nMore concisely, we can use notation to describe the dependence of a property on a variable.\n\n### Predicates\nA *predicate* is a function that returns a proposition. \nFor example, let $P$ be the predicate on the integers defined by $P(x) := x > 5$. Then $P(10)$ is the proposition\n$10 > 5$. Likewise, $P(2)$ is the proposition $2 > 5$.\n\nAs another example let $S$ be the predicate on people defined by\n$S(x) := x \\text{ has red hair}$. Then $S(\\text{Prince Harry})$ states that\nPrince Harry has red hair.\n\nBy using predicate notation, we can state general results about proof.\n\n### For all statements and predicates\n\nLet $Q$ be the predicate defined by $Q(x) := (x - 1) ^ 2 = x ^2 - 2x + 1$.\nThe statement $\\forall (x : \\mathbb Z), (x - 1) ^ 2 = x ^2 - 2x + 1$ can be written\nconcisely as $\\forall (x : \\mathbb Z), Q(x)$. Suppose $h$ is a proof of\n$\\forall (x : \\mathbb Z), Q(x)$. For all elimination on $h$ and $3$ gives a proof of $Q(3)$, namely\nthe statement $(3 - 1) ^ 2 = 3 ^ 2 - 2\\times3 + 1$.\n\n### For all elimination\n\nMore generally, let $X$ be any type of quantity, let $P$ be a predicate on $X$. Let $h$ be a\nproof of $\\forall (x : X), P(x)$. Let $a$ be a term of type $X$. For all elimination on $h$ and $a$\ngives a proof of $P(a)$.\n\n### Predicates and for all elimination in Lean\n\nIn Lean `P : X \u2192 Prop` indicates that `P` is a predicate on a type `X`.\nGiven the 'for all' statement `h : \u2200 (x : X), P(x)`, given that `a` is a term of type `X`,\nwe deduce `P(a)`. The proof of this in Lean is simply `h a`.\n-/\n\nnamespace exlean -- hide\n\nvariables (X : Type*) (P Q : X \u2192 Prop)\n\nexample (h : \u2200 (x : X), P(x)) (a : X) : P(a) :=\nbegin\n  from h a,\nend\n\n/-\n### For all introduction\n\nLet $X$ be a type and let $P$ be a predicate on $X$. The 'for all introduction' rule asserts that\nto prove $\\forall (x : X), P(x)$ is to assume $x : X$ and derive $P(x)$.\n\n### Combining for all introduction and for all elimination\n\n**Theorem**: Let $P$ and $Q$ be predicates on a type $X$.\nLet $h$ be the assumption $\\forall (x : X), P(x) \\land Q(x)$.\nThen $\\forall (y : X), Q(y) \\land P(y)$.\n\n**Proof**: Assume $y : X$. We must show $Q(y) \\land P(y)$.\nBy for all elimination on $h$ and $y$, we have $P(y) \\land Q(y)$.\nDecomposing this gives $h_1 : P(y)$ and $h_2 : Q(y)$.\n\nWe show $Q(y) \\land P(y)$ by and introduction on $h_2$ and $h_1$. \u220e\n\nLet's do this in Lean.\n\nThe line `have : P(y) \u2227 Q(y), from h y` introduces a hypothesis\ncalled `this` into the context, where `this : P(y) \u2227 Q(y)`.\n-/\n\nexample (h : \u2200 (x : X), P(x) \u2227 Q(x)) : \u2200 (y : X), Q(y) \u2227 P(y) :=\nbegin\n  assume y : X,\n  have : P(y) \u2227 Q(y), from h y,\n  cases this with h\u2081 h\u2082,\n  show Q(y) \u2227 P(y), from and.intro h\u2082 h\u2081,\nend\n\n/-\n\n### Tasks\n\n1. Replace `sorry` below with a Lean proof, adapting the proof above. \n2. On a piece of paper, state and give a handwritten proof of this result.\n-/\n\n/- Theorem : no-side-bar\n-/\ntheorem all_intro_elim2 (h : \u2200 (x : X), P(x)) :\n\u2200 (z : X), Q(z) \u2228 P(z) :=\nbegin\n", "proof": "  assume z : X,\n  have : P(z), from h z,\n  from or.inr this,\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n\nend exlean -- hide", "height": 9, "editorText": "sorry", "lineOffset": 100, "name": "all_intro_elim2", "statement": "(h : \u2200 (x : X), P(x)) :\n\u2200 (z : X), Q(z) \u2228 P(z)"}, {"type": "lean", "content": "515", "hidden": true}]}], "parents": [2]}, {"name": "516", "levels": [{"name": "", "problemIndex": 19, "objects": [{"type": "lean", "content": "517", "hidden": true}, {"type": "text", "content": "518"}, {"type": "text", "content": "519"}, {"type": "text", "content": "520"}, {"type": "lean", "content": "521", "hidden": true}, {"type": "lean", "content": "522", "hidden": true}, {"type": "lean", "content": "523", "hidden": true}, {"type": "axiom", "content": "524", "name": "mul_one", "sideBar": true}, {"type": "axiom", "content": "525", "name": "one_mul", "sideBar": true}, {"type": "axiom", "content": "526", "name": "mul_assoc", "sideBar": true}, {"type": "axiom", "content": "527", "name": "mul_left_inv", "sideBar": true}, {"type": "lean", "content": "528", "hidden": false}, {"type": "text", "content": "529"}, {"type": "text", "content": "530"}, {"type": "text", "content": "531"}, {"type": "axiom", "content": "532", "name": "eq_one_of_self_mul_eq", "sideBar": true}, {"type": "lean", "content": "533", "hidden": false}, {"type": "text", "content": "534"}, {"type": "text", "content": "535"}, {"type": "theorem", "text": "536", "lean": "theorem inv_inv : (a\u207b\u00b9)\u207b\u00b9 = a :=\n", "sideBar": true, "firstProofLineNumber": 144, "firstProofHintLineNumber": 145, "lastProofHintLineNumber": 146, "lastProofLineNumber": 152, "textBefore": "import  group.basic -- hide\n\n/-\n# Groups\n\n## Level 1: The group axioms; the inverse of an inverse\n-/\n\n/-\nA group $(G, \\ast)$ is a type (or set) $G$ together with a binary operation $\\ast : G \\times G \\to G$\nand a special element $e_G \\in G$ satisfying the following properties (called the _group axioms_):\n* [identity] for every $a : G$, $a \\ast e_G = a$ and $e_G \\ast a = a$.\n* [associativity] for all $a, b, c : G$, $(a \\ast b) \\ast c = a \\ast (b \\ast c)$\n* [inverse] for every $a : G$, there exists $b : G$ such that $a \\ast b = e_G$ and $b \\ast a = e_G$.\n-/\n\n/-\n### Groups in Lean\n\nIn Lean, we write $1$ for the identity element $e_G$ of a group. The symbol `1` here isn't \n(necessarily) the same as the ordinary number $1$.\n\nThe group axioms in Lean are the following:\n* `mul_one : \u2200 (a : G), a * 1 = a`\n* `one_mul : \u2200 (a : G), 1 * a`\n* `mul_assoc : \u2200 (a b c : G), (a * b) * c = a * (b * c)`\n* `mul_left_inv : \u2200 (a : G), a\u207b\u00b9 * a = 1` (note `a\u207b\u00b9` is typed `a\\-1`)\n\nIf you forget them, you can refresh your memory using the 'Groups' drop-down in the\n'Theorem statements' drop-down menu on the left \n\nHere are the group axioms in practice.\n-/\n\nnamespace exlean -- hide\n\nopen group -- hide\n\nvariables {G : Type*} [group G] (a b c : G) -- hide\n\n/- Axiom : mul_one\n(a : G) : a * 1 = a\n-/\n\n/- Axiom : one_mul\n(a : G) : 1 * a = a\n-/\n\n/- Axiom : mul_assoc\n(a b c : G) : a * (b * c) = (a * b) * c\n-/\n\n/- Axiom : mul_left_inv\n(a : G) : a\u207b\u00b9 * a = 1\n-/\n\nexample : a * 1 = a := mul_one a\n\nexample : 1 * a = a := one_mul a\n\nexample : (a * b) * c = a * (b * c) := mul_assoc a b c\n\nexample : a\u207b\u00b9 * a = 1 := mul_left_inv a\n\n/-\nTogether, `mul_one` and `one_mul` are equivalent to the 'normal' group identity axiom; `mul_assoc`\nis the same as the normal associativity axiom. The odd-one-out is `mul_left_inv`.\n\nRather than merely asserting the existence of an inverse of `g`, we name the inverse `g\u207b\u00b9`.\nMoreover, the `mul_left_inv` axiom only seems to suggest that `g\u207b\u00b9` is a left inverse of `g`.\nAs we'll soon see, the right inverse property can be proved from the other properties.\n\n-/\n\n/-\n### Uniqueness of identity\n\n**Theorem**:\nSuppose $b$ is an element of $G$ such that for every $a : G, b \\ast a = a$,\nthen $b = 1$.\n\nWe'll give a proof 'by calculation'. This is a series of equations, each with its own proof, \nstarting with the left-side and ending with the right-side of the desired equation $b = 1$.\n\n**Proof**:\n$$\n\\begin{align}\nb &= b \\ast 1 && \\text{[by identity axiom (mul one)]}\\\\\\\\\n&= b \\ast (b^{-1} \\ast b) && \\text{[by left inverse]} \\\\\\\\\n& = (b \\ast b^{-1}) \\ast b && \\text{[by associativity]} \\\\\\\\\n& = b^{-1} \\ast b && \\text{[by the hypothesis]} \\\\\\\\\n& = 1. && \\text{[by left inverse]}\n\\end{align}\n$$\n\u220e\n-/\n\n/-\nThe Lean proof of this result is remarkably similar to the handwritten proof:\n-/\n\n/- Axiom : eq_one_of_self_mul_eq\n(h : \u2200 (a : G), b * a = a) : b = 1\n-/\nlemma eq_one_of_self_mul_eq (h : \u2200 (a : G), b * a = a) : b = 1 :=\nbegin\n  calc b = b * 1      : by rw mul_one\n  ... = b * (b\u207b\u00b9 * b) : by rw mul_left_inv\n  ... = (b * b\u207b\u00b9) * b : by rw mul_assoc\n  ... = b\u207b\u00b9 * b       : by rw h\n  ... = 1             : by rw mul_left_inv\nend\n\n/-\nAbove, `calc` indicates that we are starting a proof by calculation. The\nproof for each line of calculation is shown after the colon.\n\nConsider the following two lines from the proof.\n```\n  ... = b * (b\u207b\u00b9 * b) : by rw mul_left_inv\n  ... = (b * b\u207b\u00b9) * b : by rw mul_assoc\n```\nThe second line asserts `b = (b\u207b\u00b9 * b) = (b * b\u207b\u00b9) * b`, the proof of which is: `by rw mul_assoc`\n-/\n\n/-\n### Tasks\n\n* By hand, write a proof that if $a$ is an element of a group $G$, then $(a^{-1})^{-1} = a$. Use\nonly the group axoims from Lean (in particular, you may not use the 'right inverse' property).\n\n* Complete the Lean 'proof by calculation' below. I've started you off with a suggested first\nline of the proof. You'll need to add intermediate lines and replace all\n`sorry`s with proofs. I suggest working from top to bottom, one line at a time. That way, you\ncan check if your proof is 'structurally correct' as you'll have only a `sorry` warning rather\nthan an error message after each line.\n-/\n\n/- Theorem : \nThe inverse of the inverse of $a$ is $a$.\n-/\ntheorem inv_inv : (a\u207b\u00b9)\u207b\u00b9 = a :=\nbegin\n", "proof": "/- hint\n  calc (a\u207b\u00b9)\u207b\u00b9 = (a\u207b\u00b9)\u207b\u00b9 * 1  : by sorry\n  ... = a                     : by sorry\n-/\n  calc (a\u207b\u00b9)\u207b\u00b9 = (a\u207b\u00b9)\u207b\u00b9 * 1  : by rw mul_one\n  ... = (a\u207b\u00b9)\u207b\u00b9 * (a\u207b\u00b9 * a)   : by rw mul_left_inv\n  ... = ((a\u207b\u00b9)\u207b\u00b9 * a\u207b\u00b9) * a   : by rw mul_assoc\n  ... = 1 * a                 : by rw mul_left_inv\n  ... = a                     : by rw one_mul", "proof_hint": "  calc (a\u207b\u00b9)\u207b\u00b9 = (a\u207b\u00b9)\u207b\u00b9 * 1  : by sorry\n  ... = a                     : by sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 9, "editorText": "  calc (a\u207b\u00b9)\u207b\u00b9 = (a\u207b\u00b9)\u207b\u00b9 * 1  : by sorry\n  ... = a                     : by sorry", "lineOffset": 143, "name": "inv_inv", "statement": "(a\u207b\u00b9)\u207b\u00b9 = a"}, {"type": "lean", "content": "537", "hidden": true}]}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "538", "hidden": true}, {"type": "text", "content": "539"}, {"type": "lean", "content": "540", "hidden": true}, {"type": "lean", "content": "541", "hidden": true}, {"type": "lean", "content": "542", "hidden": true}, {"type": "text", "content": "543"}, {"type": "theorem", "text": "544", "lean": "theorem mul_right_inv : b * b\u207b\u00b9 = 1 :=\n", "sideBar": true, "firstProofLineNumber": 36, "firstProofHintLineNumber": 37, "lastProofHintLineNumber": 38, "lastProofLineNumber": 41, "textBefore": "import  group.inv_inv -- hide\n\n/-\n# Groups\n\n## Level 2: Right inverse\n-/\n\n\n\nnamespace exlean -- hide\n\nopen group -- hide\n\nvariables {G : Type*} [group G] (a b c : G) -- hide\n\n\n/-\nIn the previous level, we introduced the left inverse axiom for groups. In this level, you'll\n*prove* that the right inverse property follows from the other group axioms.\n\n\n### Tasks\n\n* By hand, write a proof that if $b$ is an element of a group $G$, then $b * b^{-1} = 1$. You may\nuse any axioms or theorems proved in the previous level.\n\n* Complete the Lean 'proof by calculation' below.\n-/\n\n/- Theorem : \n$b \\ast b^{-1} = 1$.\n-/\ntheorem mul_right_inv : b * b\u207b\u00b9 = 1 :=\nbegin\n", "proof": "/- hint\n  calc b * b\u207b\u00b9 = sorry : by sorry\n  ... = 1              : by sorry\n-/\n  calc b * b\u207b\u00b9 = (b\u207b\u00b9)\u207b\u00b9 * b\u207b\u00b9 : by rw inv_inv\n  ... = 1                      : by rw mul_left_inv", "proof_hint": "  calc b * b\u207b\u00b9 = sorry : by sorry\n  ... = 1              : by sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 6, "editorText": "  calc b * b\u207b\u00b9 = sorry : by sorry\n  ... = 1              : by sorry", "lineOffset": 35, "name": "mul_right_inv", "statement": "b * b\u207b\u00b9 = 1"}, {"type": "lean", "content": "545", "hidden": true}]}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "546", "hidden": true}, {"type": "text", "content": "547"}, {"type": "lean", "content": "548", "hidden": true}, {"type": "lean", "content": "549", "hidden": true}, {"type": "lean", "content": "550", "hidden": true}, {"type": "text", "content": "551"}, {"type": "theorem", "text": "552", "lean": "lemma inv_eq_of_mul_eq_one (h : a * b = 1) : a\u207b\u00b9 = b :=\n", "sideBar": true, "firstProofLineNumber": 35, "lastProofLineNumber": 39, "textBefore": "import group.mul_right_inv -- hide\n\n/-\n# Groups\n\n## Level 3: Uniqueness of inverse\n-/\n\n\nnamespace exlean -- hide\n\nopen group -- hide\n\nvariables {G : Type*} [group G] {a b c : G} -- hide\n\n\n/-\nIn the first level of this world, you saw the 'uniqueness of identity' result. In this level,\nyou'll prove an equivalent 'uniqueness of inverse' result.\n\n\n### Tasks\n\n* By hand, write a proof that if $a, b$ are elements of a group $G$ and if $a \\ast b = 1$, then\n$a^{-1}$ equals $b$. You will only need the group axioms.\n\n* Write a Lean proof by calculation, using only the group axioms.\n-/\n\n/- Theorem : \nIf $a \\ast b = 1$, then $a^{-1} = b$.\n-/\nlemma inv_eq_of_mul_eq_one (h : a * b = 1) : a\u207b\u00b9 = b :=\nbegin\n", "proof": "  calc a\u207b\u00b9 = a\u207b\u00b9 * 1    : by rw mul_one\n  ... = a\u207b\u00b9 * (a * b)   : by rw h\n  ... = (a\u207b\u00b9 * a) * b   : by rw mul_assoc\n  ... = 1 * b           : by rw mul_left_inv\n  ... = b               : by rw one_mul", "proof_hint": "sorry", "textAfter": "\nend \n\nend exlean -- hide", "height": 5, "editorText": "sorry", "lineOffset": 34, "name": "inv_eq_of_mul_eq_one", "statement": "(h : a * b = 1) : a\u207b\u00b9 = b"}, {"type": "lean", "content": "553", "hidden": true}]}, {"name": "", "problemIndex": 7, "objects": [{"type": "lean", "content": "554", "hidden": true}, {"type": "text", "content": "555"}, {"type": "lean", "content": "556", "hidden": true}, {"type": "lean", "content": "557", "hidden": true}, {"type": "lean", "content": "558", "hidden": true}, {"type": "text", "content": "559"}, {"type": "hint", "content": "560", "title": "561"}, {"type": "theorem", "text": "562", "lean": "theorem mul_inv_rev : (a * b)\u207b\u00b9 = b\u207b\u00b9 * a\u207b\u00b9 :=\n", "sideBar": true, "firstProofLineNumber": 39, "lastProofLineNumber": 45, "textBefore": "import group.unique_inverse -- hide\n\n/-\n# Groups\n\n## Level 4: The inverse of a product\n-/\n\n\nnamespace exlean -- hide\n\nopen group -- hide\n\nvariables {G : Type*} [group G] (a b c : G) -- hide\n\n\n/-\n### Tasks\n\n* By hand, write a proof that if $a, b$ are elements of a group $G$, then\n$(a \\ast b)^{-1} = b^{-1} \\ast a^{-1}$.\n\n* Complete the Lean proof below.\n-/\n\n/- Hint : A helpful result\nYou've seen `inv_eq_of_mul_eq_one`. This result states that if `s * t = 1`, then `s\u207b\u00b9 = t`.\nHere, you can apply this result, via `apply inv_eq_of_mul_eq_one` to change the\ngoal to one of proving `(a * b) * (b\u207b\u00b9 * a\u207b\u00b9) = 1`.\n\nThis latter goal can be proved by calculation.\n-/\n\n/- Theorem : \n$(a \\ast b)^{-1} = b^{-1} \\ast a^{-1}$.\n-/\ntheorem mul_inv_rev : (a * b)\u207b\u00b9 = b\u207b\u00b9 * a\u207b\u00b9 :=\nbegin\n", "proof": "  apply inv_eq_of_mul_eq_one,\n  calc (a * b) * (b\u207b\u00b9 * a\u207b\u00b9)\n      = a * (b * (b\u207b\u00b9 * a\u207b\u00b9))   : by rw mul_assoc\n  ... = a * ((b * b\u207b\u00b9) * a\u207b\u00b9)   : by rw mul_assoc\n  ... = a * (1 * a\u207b\u00b9)           : by rw mul_right_inv\n  ... = a * a\u207b\u00b9                 : by rw one_mul\n  ... = 1                       : by rw mul_right_inv", "proof_hint": "sorry", "textAfter": "\nend \n\nend exlean -- hide", "height": 7, "editorText": "sorry", "lineOffset": 38, "name": "mul_inv_rev", "statement": "(a * b)\u207b\u00b9 = b\u207b\u00b9 * a\u207b\u00b9"}, {"type": "lean", "content": "563", "hidden": true}]}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "564", "hidden": true}, {"type": "text", "content": "565"}, {"type": "lean", "content": "566", "hidden": true}, {"type": "lean", "content": "567", "hidden": true}, {"type": "lean", "content": "568", "hidden": true}, {"type": "text", "content": "569"}, {"type": "lemma", "text": "570", "lean": "lemma mul_left_cancel (h : a * b = a * c) : b = c:=\n", "sideBar": true, "firstProofLineNumber": 33, "lastProofLineNumber": 39, "textBefore": "import  group.mul_inv_rev -- hide\n\n/-\n# Groups\n\n## Level 5: Left cancellation\n-/\n\n\nnamespace exlean -- hide\n\nopen group -- hide\n\nvariables {G: Type* } [group G] {a b c : G}  -- hide\n\n/-\nJust as with 'ordinary' multiplication, we can cancel the same factor on the left of\nboth sides of an equation.\n\n### Tasks\n\n* Give a handwritten proof that if $a \\ast b = a \\ast c$, then $b = c$.\n\n* Give a Lean 'proof by calculation' below.\n-/\n\n\n/- Lemma :\nIf $a \\ast b = a \\ast c$, then $b = c$.\n-/\nlemma mul_left_cancel (h : a * b = a * c) : b = c:=\nbegin\n", "proof": "  calc b = 1 * b      : by rw one_mul\n  ... = (a\u207b\u00b9 * a) * b : by rw mul_left_inv\n  ... = a\u207b\u00b9 * (a * b) : by rw mul_assoc\n  ... = a\u207b\u00b9 * (a * c) : by rw h\n  ... = (a\u207b\u00b9 * a) * c : by rw mul_assoc\n  ... = 1 * c         : by rw mul_left_inv\n  ... = c             : by rw one_mul", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 7, "editorText": "sorry", "lineOffset": 32, "name": "mul_left_cancel", "statement": "(h : a * b = a * c) : b = c"}, {"type": "lean", "content": "571", "hidden": true}]}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "572", "hidden": true}, {"type": "text", "content": "573"}, {"type": "lean", "content": "574", "hidden": true}, {"type": "lean", "content": "575", "hidden": true}, {"type": "lean", "content": "576", "hidden": true}, {"type": "text", "content": "577"}, {"type": "lemma", "text": "578", "lean": "lemma inv_inj : a\u207b\u00b9 = b\u207b\u00b9 \u2194 a = b :=\n", "sideBar": true, "firstProofLineNumber": 34, "lastProofLineNumber": 40, "textBefore": "import  group.left_cancellation -- hide\n\n/-\n# Groups\n\n## Level 6: Injectivity of inverse\n-/\n\n\nnamespace exlean -- hide\n\nopen group -- hide\n\nvariables {G: Type* } [group G] (a b c : G)  -- hide\n\n/-\nOne way to prove two group elements are equal is to show that their inverses are equal.\n\n### Tasks\n\n* Give a handwritten proof that if $a$ and $b$ are group elements, then\n$a^{-1} = b^{-1} \\leftrightarrow a = b$.\n\n* Give a Lean proof of this result.\n-/\n\n\n/- Lemma :\nLet $a$ and $b$ be elements of a group $G$. We have\n$a^{-1} = b^{-1} \\leftrightarrow a = b$.\n-/\nlemma inv_inj : a\u207b\u00b9 = b\u207b\u00b9 \u2194 a = b :=\nbegin\n", "proof": "  split,\n  { assume h : a\u207b\u00b9 = b\u207b\u00b9,\n    calc a = a\u207b\u00b9\u207b\u00b9  : by rw inv_inv\n    ... = b\u207b\u00b9\u207b\u00b9     : by rw h\n    ... = b         : by rw inv_inv },\n  { assume h : a = b,\n    show a\u207b\u00b9 = b\u207b\u00b9, rw h,}", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 7, "editorText": "sorry", "lineOffset": 33, "name": "inv_inj", "statement": "a\u207b\u00b9 = b\u207b\u00b9 \u2194 a = b"}, {"type": "lean", "content": "579", "hidden": true}]}, {"name": "", "problemIndex": 10, "objects": [{"type": "lean", "content": "580", "hidden": true}, {"type": "text", "content": "581"}, {"type": "lean", "content": "582", "hidden": true}, {"type": "lean", "content": "583", "hidden": true}, {"type": "lean", "content": "584", "hidden": true}, {"type": "text", "content": "585"}, {"type": "axiom", "content": "586", "name": "mul_left_cancel_iff", "sideBar": true}, {"type": "lean", "content": "587", "hidden": false}, {"type": "text", "content": "588"}, {"type": "hint", "content": "589", "title": "590"}, {"type": "lemma", "text": "591", "lean": "lemma mul_right_cancel_iff : b * a = c * a \u2194 b = c :=\n", "sideBar": true, "firstProofLineNumber": 54, "lastProofLineNumber": 66, "textBefore": "import  group.injectivity_of_inverse -- hide\n\n/-\n# Groups\n\n## Level 7: Right cancellation\n-/\n\n\nnamespace exlean -- hide\n\nopen group -- hide\n\nvariables {G: Type* } [group G] (a b c : G)  -- hide\n\n/-\nFrom the left cancellation result, we cheaply prove an iff result.\n-/\n\n/- Axiom : mul_left_cancel_iff\n(a b c : G) : a * b = a * c \u2194 a = b\n-/\nlemma mul_left_cancel_iff : a * b = a * c \u2194 b = c :=\nbegin\n  split,\n  { assume h : a * b = a * c,\n    show b = c, exact mul_left_cancel h, },\n  { assume h : b = c,\n    show a * b = a * c, rw h,\n  }\nend\n\n/-\n### Tasks\n\n* Give a handwritten proof of the right cancellation result, that\n$b \\ast a = c \\ast a \\leftrightarrow b = c$. \n\n* Give a Lean proof of this result.\n-/\n\n\n/- Hint : A one-line proof\nYou can prove this result in a single line of `rw`s. Start with\n`rw [\u2190inv_inj]`.\n-/\n\n/- Lemma :\nLet $a$ and $b$ be elements of a group $G$. We have\n$b \\ast a = c \\ast a \\leftrightarrow b = c$.\n-/\nlemma mul_right_cancel_iff : b * a = c * a \u2194 b = c :=\nbegin\n", "proof": "  rw [\u2190inv_inj, mul_inv_rev, mul_inv_rev, mul_left_cancel_iff, inv_inj],\n\n\n\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 13, "editorText": "sorry", "lineOffset": 53, "name": "mul_right_cancel_iff", "statement": "b * a = c * a \u2194 b = c"}, {"type": "lean", "content": "592", "hidden": true}]}, {"name": "", "problemIndex": 16, "objects": [{"type": "lean", "content": "593", "hidden": true}, {"type": "text", "content": "594"}, {"type": "lean", "content": "595", "hidden": true}, {"type": "lean", "content": "596", "hidden": true}, {"type": "lean", "content": "597", "hidden": true}, {"type": "text", "content": "598"}, {"type": "text", "content": "599"}, {"type": "axiom", "content": "600", "name": "pow_zero", "sideBar": true}, {"type": "axiom", "content": "601", "name": "pow_one", "sideBar": true}, {"type": "axiom", "content": "602", "name": "one_pow", "sideBar": true}, {"type": "axiom", "content": "603", "name": "pow_add", "sideBar": true}, {"type": "axiom", "content": "604", "name": "pow_mul", "sideBar": true}, {"type": "lean", "content": "605", "hidden": false}, {"type": "text", "content": "606"}, {"type": "lean", "content": "607", "hidden": false}, {"type": "text", "content": "608"}, {"type": "lemma", "text": "609", "lean": "lemma exists_pow_eq_of_poq_eq_one (h : a ^ 8 = 1) :\n\u2203 (q r : \u2115), a ^ 39 = a ^ r \u2227 (0 \u2264 r) \u2227 (r < 8) :=\n", "sideBar": false, "firstProofLineNumber": 129, "lastProofLineNumber": 135, "textBefore": "import  group.right_cancellation -- hide\n\n/-\n# Groups\n\n## Level 8: Powers\n-/\n\n\nnamespace exlean -- hide\n\nopen group -- hide\n\nvariables {G: Type* } [group G] {a b c : G} {n m : \u2115} -- hide\n\n/-\nExponentiation is defined to be repeated multiplication. That is, if $a$ is an element of a group\n$G$, then $a^0 := 1$ and $a^{n + 1} := a \\ast a^n$, for a natural number $n$.\n\nThe normal 'laws of indices' apply. That is, if $a : G$ and $n, m : \\mathbb N$, then:\n* $a ^ 0 = 1$,\n* $a ^ 1 = a$,\n* $1 ^ n = 1$,\n* $a ^{n + m} = a ^ n \\ast a*m$,\n* $a^{nm} = (a ^ n) ^ m$.\n-/\n\n/-\n### Laws of indices in Lean\n\nHere are the laws of indices in Lean.\n* `pow_zero a : a ^ 0 = 1`\n* `pow_one a : a ^ 1 = a`\n* `one_pow n : 1 ^ n = 1`\n* `pow_add a n m : a ^ (n + m) = (a ^ n) * (a ^ m)`\n* `pow_mul a n m : a ^ (n * m) = (a ^ n) ^ m`\n\nThey can be applied as follows.\n-/\n\n/- Axiom : pow_zero\n(a : G) : a ^ 0 = 1\n-/\n\n/- Axiom : pow_one\n(a : G) : a ^ 1 = a\n-/\n\n/- Axiom : one_pow\n(n : \u2115) : 1 ^ n = 1\n-/\n\n/- Axiom : pow_add\n(a : G) (n m : \u2115) : a ^ (n + m) = a ^ n * a ^ m\n-/\n\n/- Axiom : pow_mul\n(a : G) (n m : \u2115) : a ^ (n * m) = (a ^ n) ^ m\n-/\n\n\n\nexample : a ^ 0 = 1 := pow_zero a\n\nexample : a ^ 1 = a := pow_one a\n\nexample : (1 : G) ^ n = 1 := one_pow n\n\nexample : a ^ (n + m) = a ^ n * a ^ m := pow_add a n m\n\nexample : a ^ (n * m) = (a ^ n) ^ m := pow_mul a n m\n\n\n/-\nAs an example, we'll suppose $a^7 = 1$ and find $q$ and $r$ such that $a^26 = a^{7q + r}$ and\nsuch that $0 \\le r < 7$.\n\n**Theorem**: Let $a$ be an element of a group $G$. Suppose $h : a ^ 7 = 1$. Then there exist\nnatural numbers $q$ and $r$ such that $a ^ {26} = a ^r$, where $0 \\le r < 7$.\n\n**Proof**: Take $q$ to be 3 and $r$ to be $5$. We must show both that $a^{26} = a^{7\\times 3 + 5}$\nand that $0 \\le 5 < 7$.\n\nThe first part is proved by calculation.\n$$\n\\begin{align}\na^{26} &= a ^ {7 \\times 3 + 5} && \\text{[trivially]} \\\\\\\\\n&= (a ^ 7) ^ 3 \\ast a ^ 5 && \\text{[by laws of indices]} \\\\\\\\\n&= 1 ^ 3 \\ast a ^ 5  && \\text{[by $h$]} \\\\\\\\\n& = a ^ 5. && \\text{[by laws of indices and the identity axiom]}\n\\end{align}\n$$\nThe second part is easily proved.\n\n\nThe same argument can be written in Lean. The `tidy` tactic here proves `0 \u2264 5 \u2227 5 < 7`.\n-/\n\nexample (h : a ^ 7 = 1) :\n\u2203 (q r : \u2115), a ^ 26 = a ^ r \u2227 (0 \u2264 r) \u2227 (r < 7) :=\nbegin\n  use [3, 5],\n  split,\n  { calc a ^ 26\n        = a ^ (7 * 3 + 5)     : by trivial\n    ... = (a ^ 7) ^ 3 * a ^ 5 : by rw [pow_add, pow_mul]\n    ... = (1 ^ 3) * a ^ 5     : by rw h \n    ... = a ^ 5               : by rw [one_pow, one_mul] },\n  { tidy, },\nend\n\n/-\n### Tasks\n\n* Complete the Lean proof below, closely following the proof above.\n\n* Write a proof of the same result by hand.\n\n-/\n\n\n/- Lemma : no-side-bar\nIf $a ^ 8 = 1$, then there exist natural numbers $q$ and $r$ such that $a ^ {39} = a ^ r$ and\n$0 \\le r < 8$.\n-/\nlemma exists_pow_eq_of_poq_eq_one (h : a ^ 8 = 1) :\n\u2203 (q r : \u2115), a ^ 39 = a ^ r \u2227 (0 \u2264 r) \u2227 (r < 8) :=\nbegin\n", "proof": "  use [4, 7],\n  split,\n  { calc a ^ 39 = a ^ (8 * 4 + 7) : by trivial\n    ... = (a ^ 8) ^ 4 * a ^ 7     : by rw [pow_add, pow_mul]\n    ... = 1 ^ 4 * a ^ 7           : by rw [h]\n    ... = a ^ 7                   : by rw [one_pow, one_mul]  },\n  { tidy, },", "proof_hint": "sorry", "textAfter": "\nend \n\nend exlean -- hide", "height": 7, "editorText": "sorry", "lineOffset": 128, "name": "exists_pow_eq_of_poq_eq_one", "statement": "(h : a ^ 8 = 1) :\n\u2203 (q r : \u2115), a ^ 39 = a ^ r \u2227 (0 \u2264 r) \u2227 (r < 8)"}, {"type": "lean", "content": "610", "hidden": true}]}, {"name": "", "problemIndex": 14, "objects": [{"type": "lean", "content": "611", "hidden": true}, {"type": "text", "content": "612"}, {"type": "lean", "content": "613", "hidden": true}, {"type": "lean", "content": "614", "hidden": true}, {"type": "lean", "content": "615", "hidden": true}, {"type": "text", "content": "616"}, {"type": "axiom", "content": "617", "name": "one_gpow", "sideBar": true}, {"type": "axiom", "content": "618", "name": "gpow_add", "sideBar": true}, {"type": "axiom", "content": "619", "name": "gpow_mul", "sideBar": true}, {"type": "lean", "content": "620", "hidden": false}, {"type": "text", "content": "621"}, {"type": "lean", "content": "622", "hidden": false}, {"type": "text", "content": "623"}, {"type": "text", "content": "624"}, {"type": "lemma", "text": "625", "lean": "lemma exists_pow_eq_of_poq_eq_one2 (h : a ^ (8 : \u2124) = 1) :\n\u2203 (q r : \u2124), a ^ (-70 : \u2124) = a ^ r \u2227 (0 \u2264 r) \u2227 (r < 8) :=\n", "sideBar": false, "firstProofLineNumber": 120, "lastProofLineNumber": 125, "textBefore": "import group.powers -- hide\n\n/-\n# Groups\n\n## Level 9: Negative powers\n-/\n\n\nnamespace exlean -- hide\n\nopen group -- hide\n\nvariables {G: Type* } [group G] {a b c : G} {n m : \u2124} -- hide\n\n/-\nWe've seen how to define $a ^ n$ where $a$ is a group element and $n$ is a natural number.\nWe can extend the definition to consider $a ^ m$, where $m$ is an integer.\n\nThere are two possibilities:\n* $m = n$ for a natural number $n$. We then take $a ^ m := a ^ n$.\n* $m = -(n + 1)$ for a natural number $n$. We define $a ^ m = (a ^ (n + 1))^{-1}$.\n\n\n### Laws of indices in Lean\n\nThe laws of indices for integers powers are virtually the same as laws of indices for natural\nnumber powers. Only the names of the results are different.\n\nTaking `n` and `m` to be integers, the laws of indices in Lean are as follows.\n* `one_gpow n : 1 ^ n = 1`\n* `gpow_add a n m : a ^ (n + m) = (a ^ n) * (a ^ m)`\n* `gpow_mul a n m : a ^ (n * m) = (a ^ n) ^ m`\n\nHere they are in action!\n-/\n\n/- Axiom : one_gpow\n(n : \u2124) : 1 ^ n = 1\n-/\n\n/- Axiom : gpow_add\n(a : G) (n m : \u2124) : a ^ (n + m) = a ^ n * a ^ m\n-/\n\n/- Axiom : gpow_mul\n(a : G) (n m : \u2124) : a ^ (n * m) = (a ^ n) ^ m\n-/\n\nexample : (1 : G) ^ n = 1 := one_gpow n\n\nexample : a ^ (n + m) = a ^ n * a ^ m := gpow_add a n m\n\nexample : a ^ (n * m) = (a ^ n) ^ m := gpow_mul a n m\n\n\n\n/-\nAs an example, we'll suppose $a^7 = 1$ and find $q$ and $r$ such that $a^{-22} = a^{7q + r}$ and\nsuch that $0 \\le r < 7$.\n\n**Theorem**: Let $a$ be an element of a group $G$. Suppose $h : a ^ 7 = 1$. Then there exist\nintegers $q$ and $r$ such that $a ^ {-20} = a^ {7q + r}$, where $0 \\le r < 7$.\n\n**Proof**: Take $q$ to be $-4$ and $r$ to be $6$. We must show both that $a^{-20} = a^{7\\times (-4) + 6}$\nand that $0 \\le 6 < 7$.\n\nThe first part is proved by calculation.\n$$\n\\begin{align}\na^{-22} &= a ^ {7 \\times (-4) + 6} && \\text{[trivially]} \\\\\\\\\n&= (a ^ 7) ^ (-4) \\ast a ^ 6 && \\text{[by laws of indices]} \\\\\\\\\n& = a ^ 6. && \\text{[by laws of indices, $h$, and the identity axiom]}\n\\end{align}\n$$\nThe second part is easily proved.\n\n\nThe same argument can be written in Lean. The `tidy` tactic here proves `0 \u2264 5 \u2227 5 < 7`.\n-/\n\nexample (h : a ^ (7 : \u2124) = 1) :\n\u2203 (q r : \u2124), a ^ (-22 : \u2124) = a ^ r \u2227 (0 \u2264 r) \u2227 (r < 7) :=\nbegin\n  use [-4, 6],\n  split,\n  { calc a ^ (-22 : \u2124) = a ^ ((7 : \u2124) * -4 + 6) : by trivial\n    ... = a ^ ((7 : \u2124) * -4) * a ^ (6 : \u2124) : by rw gpow_add\n    ... = a ^ (6 : \u2124) : by rw [gpow_mul, h, one_gpow, one_mul], },\n  { tidy, },\nend\n\n\n/-\nIn the proof above, note that we need to specify, on occassion, that the quantities we are\npresenting to Lean are integers, not natural numbers. We do this with a type annotation. \nFor example, `(-22 : \u2124)` is the integer `-22`. If you just type `-22`, Lean will complain that\nyou can't take negatives of natural numbers!\n-/\n\n\n/-\n### Tasks\n\n* Complete the Lean proof below, closely following the proof above. I suggest you copy-and-paste\nthe proof and make adjustments as necessary.\n\n* Write a proof of the same result by hand.\n\n-/\n\n\n/- Lemma : no-side-bar\nIf $a ^ 8 = 1$, then there exist natural numbers $q$ and $r$ such that $a ^ {39} = a ^ r$ and\n$0 \\le r < 8$.\n-/\nlemma exists_pow_eq_of_poq_eq_one2 (h : a ^ (8 : \u2124) = 1) :\n\u2203 (q r : \u2124), a ^ (-70 : \u2124) = a ^ r \u2227 (0 \u2264 r) \u2227 (r < 8) :=\nbegin\n", "proof": "  use [-9, 2],\n  split,\n  { calc a ^ (-70 : \u2124) = a ^ ((8 : \u2124) * (-9) + 2) : by trivial\n    ... = a ^ ((8 : \u2124) * -9) * a ^ (2 : \u2124) : by rw gpow_add\n    ... = a ^ (2 : \u2124) : by rw [gpow_mul, h, one_gpow, one_mul],  },\n  { tidy, },", "proof_hint": "sorry", "textAfter": "\nend \n\nend exlean -- hide", "height": 6, "editorText": "sorry", "lineOffset": 119, "name": "exists_pow_eq_of_poq_eq_one2", "statement": "(h : a ^ (8 : \u2124) = 1) :\n\u2203 (q r : \u2124), a ^ (-70 : \u2124) = a ^ r \u2227 (0 \u2264 r) \u2227 (r < 8)"}, {"type": "lean", "content": "626", "hidden": true}]}], "parents": [3]}, {"name": "627", "levels": [{"name": "", "problemIndex": 15, "objects": [{"type": "lean", "content": "628", "hidden": true}, {"type": "text", "content": "629"}, {"type": "lean", "content": "630", "hidden": true}, {"type": "lean", "content": "631", "hidden": true}, {"type": "axiom", "content": "632", "name": "strong_induction {P : \u2115 \u2192 Prop}", "sideBar": true}, {"type": "lean", "content": "633", "hidden": true}, {"type": "text", "content": "634"}, {"type": "text", "content": "635"}, {"type": "lean", "content": "636", "hidden": true}, {"type": "lean", "content": "637", "hidden": false}, {"type": "text", "content": "638"}, {"type": "lean", "content": "639", "hidden": false}, {"type": "text", "content": "640"}, {"type": "text", "content": "641"}, {"type": "lean", "content": "642", "hidden": false}, {"type": "theorem", "text": "643", "lean": "theorem formula_for_g (n : \u2115) : g(n) = 4 * 3 ^ n + 7 * 2 ^ n :=\n", "sideBar": false, "firstProofLineNumber": 107, "lastProofLineNumber": 131, "textBefore": "import tactic.linarith tactic.ring_exp strong_induction.basic -- hide\n\n/-\n# Strong Induction\n\n## Level 1: Strong induction\n\n-/\n\nnamespace exlean -- hide\n\nopen_locale classical -- hide\n\n/- Axiom : strong_induction {P : \u2115 \u2192 Prop}\n(h\u2081 : P(0))\n(h\u2082 : \u2200 (k : \u2115), (\u2200 m : \u2115, m \u2264 k \u2192 P(m)) \u2192 P (k + 1)) :\n\u2200 (n : \u2115), P(n)\n-/\n\nopen nat -- hide\n\n/-\nStrong induction is used to prove that a predicate $P$ holds for every natural number $n$.\nTo apply strong induction you need to prove:\n* [Base case] $P(0)$\n* [Inductive step] For all $k : \u2115$, $P(k + 1)$ follows from the inductive hypothesis\nthat for all $m : \u2115$, if $m \\le k$, then $P(m)$ holds.\n-/\n\n/-\n### Strong induction example\n\nA sequence $f : \u2115 \u2192 \u2124$ is defined by $f(0) \u2254 2$, $f(1) \u2254 8$, and\n$f (n + 2) \u2254 8 f(n + 1) - 15 f(n)$.\n-/\n\nnamespace strong_sequence -- hide\n\ndef f : \u2115 \u2192 \u2124 \n| 0 := 2\n| 1 := 8\n| (n + 2) := 8 * f(n + 1) - 15 * f(n)\n\n/-\nBy strong induction, we'll prove that $f(n) = 3^n + 5^n$, for every natural number $n$.\n-/\n\nexample (n : \u2115) : f(n) = 3 ^ n + 5 ^ n :=\nbegin\n  let P := \u03bb x, f(x) = 3 ^ x + 5 ^ x, -- The predicate.\n  have base : P 0,\n  { dsimp [P, f], -- Use the definitions of `P` and `f`.\n    norm_num, },\n  have ind_step : \u2200 (k : \u2115), (\u2200 (m : \u2115), m \u2264 k \u2192 P m) \u2192 P (k + 1),\n  { dsimp [P],\n    assume k : \u2115,\n    assume ih : \u2200 (m : \u2115), m \u2264 k \u2192 P m,\n    cases k with p,\n    { refl, },\n    { dsimp [f], -- use the recursive definition of `f`.\n      simp only [succ_eq_add_one] at *, -- replace `succ p` with `p + 1` everywhere.\n      rw ih (p + 1) (by linarith),\n      rw ih p (by linarith),\n      ring_exp, }, }, -- the `ring_exp` proves equations involving variable exponents.\n  apply strong_induction base ind_step,\nend\n\n/-\nIn the proof above, we start by definining the predicate `P` as an anonymous (or 'lambda') function.\nFor example `\u03bb x, x ^ 2` is the function that sends `x` to `x ^ 2`. We define `P` to be the predicate\nthat takes `x` to the proposition `f(x) = 3 ^ x + 5 ^ x`. Note `\u03bb` is typed `\\la` in Lean.\n\nHaving defined `P`, we prove both the base case (which I've called `base`) and the inductive step\n(which I've called `ind_step`). To conlude, we apply strong induction to these two hypotheses.\n\nIn the inductive step, we introduce the induction variable `k` and the induction hypothesis `ih`.\nNext, in a procedure common to proofs by induction, we consider cases for `k`.\n\nAs `k` is a natural number, either `k = 0` or `k` is the successor of some natural number `p`.\nIn the later case, we make things easy for ourselves by replacing `succ p` with `p + 1`.\n\nNote that we apply the induction hypothesis twice: once to `p + 1` and again to `p`.\n-/\n\n\n/-\n### Task\n\nA sequence $g : \\mathbb{N} \\to \\mathbb{Z}$ is defined by $g(0) \u2254 11$, $g(1) \u2254 26$, and\n$g(n + 2) \u2254 5g(n + 1) - 6g(n)$.\n\n* By adapting the proof above, prove that $g(n) = 4 \\times 3 ^ n + 7 \\times 2 ^ n$, for each natural number $n$.\n* Do the same thing by hand.\n-/\n\ndef g : \u2115 \u2192 \u2124 \n| 0 := 11\n| 1 := 26\n| (n + 2) := 5 * g(n + 1) - 6 * g(n)\n\n\n/- Theorem : no-side-bar\n$g(n) = 4 \\times 3 ^ n + 7 \\times 2 ^ n$, for each natural number $n$.\n-/\ntheorem formula_for_g (n : \u2115) : g(n) = 4 * 3 ^ n + 7 * 2 ^ n :=\nbegin\n", "proof": "  let P := \u03bb x, g(x) = 4 * 3 ^ x + 7 * 2 ^ x,\n  have base : P 0,\n  { dsimp [P],\n    refl, },\n  have ind_step : \u2200 (k : \u2115), (\u2200 (m : \u2115), m \u2264 k \u2192 P m) \u2192 P (k + 1),\n  { dsimp [P],\n    assume k : \u2115,\n    assume ih : \u2200 (m : \u2115), m \u2264 k \u2192 P m,\n    cases k with p,\n    { refl, },\n    { dsimp [g],\n      simp only [succ_eq_add_one] at *,\n      rw ih (p + 1) (by linarith),\n      rw ih p (by linarith),\n      ring_exp, }, },\n  apply strong_induction base ind_step,\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend strong_sequence -- hide\n\n\n\nend exlean", "height": 25, "editorText": "sorry", "lineOffset": 106, "name": "formula_for_g", "statement": "(n : \u2115) : g(n) = 4 * 3 ^ n + 7 * 2 ^ n"}, {"type": "lean", "content": "644", "hidden": true}, {"type": "lean", "content": "645", "hidden": false}]}, {"name": "", "problemIndex": 9, "objects": [{"type": "lean", "content": "646", "hidden": true}, {"type": "text", "content": "647"}, {"type": "lean", "content": "648", "hidden": true}, {"type": "lean", "content": "649", "hidden": true}, {"type": "lean", "content": "650", "hidden": true}, {"type": "text", "content": "651"}, {"type": "lean", "content": "652", "hidden": false}, {"type": "text", "content": "653"}, {"type": "lean", "content": "654", "hidden": false}, {"type": "theorem", "text": "655", "lean": "theorem three_mul_add_five_mul (n : \u2115) (h : 8 \u2264 n) : \u2203 (s t : \u2115), n = 3 * s + 5 * t :=\n", "sideBar": false, "firstProofLineNumber": 70, "lastProofLineNumber": 95, "textBefore": "import tactic.linarith tactic.ring_exp strong_induction.basic -- hide\n\n/-\n# Strong Induction\n\n## Level 2: Strong induction with a different base case\n-/\n\nnamespace exlean -- hide\n\nopen_locale classical -- hide\n\nopen nat -- hide\n\n/-\nOften we want to prove that a predicate holds for all sufficiently large natural numbers. Here,\nwe'll demonstrate that every natural number $n \\ge 2$ can be expressed in the form $n = 2 s + 3 t$\nfor natural numbers $s$ and $t$.\n\nOne approach to this is to think of the proof as involving strong induction with a base case of 2.\nThis approach requires creating a new and more general version of strong induction.\n\nInstead, our approach is to use the ordinary version of strong induction, but where the predicate\nasserts $n + 2 = 2 s + 3 t$. Clearly, to prove the result is to prove that this predicate holds\nfor *every* natural number.\n\nTo translate between the original formulation and the new one, we use the result `le_iff_exists_add`.\nThis asserts `a \u2264 n` if and only if `\u2203 (c : \u2115), n = a + c`.\n-/\n\nexample (n a: \u2115) : a \u2264 n \u2194 \u2203 (c : \u2115), n = a + c := le_iff_exists_add\n\n\n/- \nCombining these ideas gives our proof.\n-/\nexample (n : \u2115) (h : 2 \u2264 n) : \u2203 (s t : \u2115), n = 2 * s + 3 * t :=\nbegin\n  rw le_iff_exists_add at h, -- These two lines adjust the predicate\n  rcases h with \u27e8c, rfl\u27e9,     -- for the different base case.\n  \n  let P := \u03bb x, \u2203 (s t : \u2115), 2 + x = 2 * s + 3 * t,\n  have base : P 0,\n  { use [1, 0],\n    norm_num, },\n  have ind_step : \u2200 (k : \u2115), (\u2200 (m : \u2115), m \u2264 k \u2192 P m) \u2192 P (k + 1),\n  { assume k : \u2115,\n    assume ih : \u2200 (m : \u2115), m \u2264 k \u2192 P m,\n\n    cases k with p,\n    { use [0, 1],\n      norm_num, },\n    have hPp : P p,\n    { apply ih p,\n      simp only [succ_eq_add_one], \n      linarith, },\n    rcases hPp with \u27e8s, t, hst\u27e9,\n    use [s + 1, t],\n    simp only [succ_eq_add_one, \u2190add_assoc, hst],\n    ring, },\n  apply strong_induction base ind_step,\nend\n\n/- Theorem : no-side-bar\nEvery natural number $n$ at least 8 can be expressed as $n = 3s + 5t$ for natural numbers $s$\nand $t$.\n-/\ntheorem three_mul_add_five_mul (n : \u2115) (h : 8 \u2264 n) : \u2203 (s t : \u2115), n = 3 * s + 5 * t :=\nbegin\n", "proof": "  rw le_iff_exists_add at h, -- These two lines adjust for\n  rcases h with \u27e8c, rfl\u27e9,     -- the different base case.\n\n  let P := \u03bb x, \u2203 (s t : \u2115), 8 + x = 3 * s + 5 * t,\n  have base : P 0,\n  { use [1, 1],\n    norm_num, },\n  have ind_step : \u2200 (k : \u2115), (\u2200 (m : \u2115), m \u2264 k \u2192 P m) \u2192 P (k + 1),\n  { assume k : \u2115,\n    assume ih : \u2200 (m : \u2115), m \u2264 k \u2192 P m,\n\n    cases k with p,\n    { use [3, 0],\n      norm_num, },\n    cases p with y,\n    { use [0, 2],\n      norm_num, },\n    have hPy : P y,\n    { apply ih y,\n      simp only [succ_eq_add_one],\n      linarith, },\n    rcases hPy with \u27e8s, t, hst\u27e9,\n    use [s + 1, t],\n    simp only [succ_eq_add_one, \u2190add_assoc, hst],\n    ring, },\n  apply strong_induction base ind_step,", "proof_hint": "sorry", "textAfter": "\nend\n\n\nend exlean -- hide", "height": 26, "editorText": "sorry", "lineOffset": 69, "name": "three_mul_add_five_mul", "statement": "(n : \u2115) (h : 8 \u2264 n) : \u2203 (s t : \u2115), n = 3 * s + 5 * t"}, {"type": "lean", "content": "656", "hidden": true}]}, {"name": "", "problemIndex": 14, "objects": [{"type": "lean", "content": "657", "hidden": true}, {"type": "text", "content": "658"}, {"type": "lean", "content": "659", "hidden": true}, {"type": "text", "content": "660"}, {"type": "lean", "content": "661", "hidden": false}, {"type": "lean", "content": "662", "hidden": true}, {"type": "text", "content": "663"}, {"type": "lean", "content": "664", "hidden": false}, {"type": "text", "content": "665"}, {"type": "lean", "content": "666", "hidden": false}, {"type": "lean", "content": "667", "hidden": true}, {"type": "lean", "content": "668", "hidden": true}, {"type": "text", "content": "669"}, {"type": "hint", "content": "670", "title": "671"}, {"type": "theorem", "text": "672", "lean": "lemma min_element_unique (h\u2081 : min_element x S) (h\u2082 : min_element y S) : x = y :=\n", "sideBar": true, "firstProofLineNumber": 66, "lastProofLineNumber": 79, "textBefore": "import data.set.basic strong_induction.basic tactic.linarith -- hide\n\n/-\n# Strong Induction\n\n## Level 3: Minimal elements\n-/\n\nnamespace exlean -- hide\n\n/-\nLet $S$ be a set of natural numbers. A natural number $n$ is said to be a _minimal element_ of $S$\nif $n \\in S$ and for every every $m \\in S$, $n \\le m$.\n-/\n\nexample (n : \u2115) (S : set \u2115) (h : min_element n S ) :\nn \u2208 S \u2227 (\u2200 (m : \u2115), m \u2208 S \u2192 n \u2264 m) := h\n\nnamespace min_element_example -- hide\n\n/-\nLet the function $f : \\mathbb N \\to \\mathbb N$ be given by $f(x) = 5 x + 7$ and let $T$ be the set\nof natural numbers $x$ for which $f(x) \\ge 400$.\n-/\n\ndef f (x : \u2115) := 5 * x + 7\n\ndef T : set \u2115 := {x : \u2115 | f x \u2265 400}\n\n/-\nWe'll show that $79$ is a minimal element of $T$. To do this, we split the target into two goals:\n1. to prove $79 \\in T$ and\n2. to prove that every element of $T$ is at least $79$.\n-/\n\nexample : min_element 79 T :=\nbegin\n  split, \n  { dsimp [T, f], -- We must show `5 * 79 + 7 \u2265 400`.\n    norm_num, }, -- This follows by arithmetic.\n  { dsimp [T, f], -- `\u22a2 \u2200 (m : \u2115), 5 * m + 5 \u2265 400 \u2192 79 \u2264 m`.\n    assume m : \u2115,\n    assume h : m \u2208 T,\n    linarith, },\nend\n\nend min_element_example -- hide\n\nvariables {S : set \u2115} {x y : \u2115} -- hide\n\n/-\n### Task\n\nProve uniquenss of minimal element. For this level, you won't need induction.\n-/\n\n/- Hint : A useful lemma on inequalities\nThe Lean lemma `le_antisymm` asserts that `x = y` follows given `x \u2264 y` and `y \u2264 x`.\n-/\n\n/- Theorem : \nIf a set $S$ of natural numbers has a minimal element, then that element is unique.\n-/\nlemma min_element_unique (h\u2081 : min_element x S) (h\u2082 : min_element y S) : x = y :=\nbegin\n", "proof": "  cases h\u2081 with hxin hxmin,\n  cases h\u2082 with hyin hymin,\n  apply le_antisymm,\n  { exact hxmin y hyin, },\n  { exact hymin x hxin, },\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n\n\nend exlean -- hide", "height": 14, "editorText": "sorry", "lineOffset": 65, "name": "min_element_unique", "statement": "(h\u2081 : min_element x S) (h\u2082 : min_element y S) : x = y"}, {"type": "lean", "content": "673", "hidden": true}]}, {"name": "", "problemIndex": 12, "objects": [{"type": "lean", "content": "674", "hidden": true}, {"type": "text", "content": "675"}, {"type": "lean", "content": "676", "hidden": true}, {"type": "lean", "content": "677", "hidden": true}, {"type": "lean", "content": "678", "hidden": true}, {"type": "text", "content": "679"}, {"type": "text", "content": "680"}, {"type": "lean", "content": "681", "hidden": false}, {"type": "hint", "content": "682", "title": "683"}, {"type": "hint", "content": "684", "title": "685"}, {"type": "tactic", "content": "686", "name": "`tidy`", "sideBar": true}, {"type": "hint", "content": "687", "title": "688"}, {"type": "theorem", "text": "689", "lean": "lemma well_ordering_principle {S : set \u2115} (h : S.nonempty) : \u2203 (n : \u2115), min_element n S :=\n", "sideBar": true, "firstProofLineNumber": 73, "lastProofLineNumber": 103, "textBefore": "import data.set.basic strong_induction.basic -- hide\n\n/-\n# Strong Induction\n\n## Level 4: The Well Ordering Principle\n-/\n\nnamespace exlean -- hide\n\nopen_locale classical -- hide\n\nopen set nat --hide\n\n/-\nIn the previous level, we show that if a set $S$ of natural numbers has a minimal element, then\nthat element is unique.\n\nIn this level, you'll show that every non-empty set of natural numbers has a minimal element. The\n(challenging) proof requires strong induction.\n-/\n\n/-\n### Nonempty sets\n\nIn Lean, a set `S` is nonempty if `\u2203 x, x \u2208 S`.\n\nAs an example, consider the set $\\\\{x : \\mathbb N \\mid x ^ 2 + 2x + 15 = 0\\\\}$. We'll show this set\nis nonempty.\n-/\n\n\nexample : set.nonempty {x : \u2115 | x * x + 2 * x = 15} :=\nbegin\n  use 3,  -- `\u22a2 3 \u2208 {x : \u2115 | x ^ 2 + 2 * x = 15}`\n  rw mem_set_of_eq, -- `\u22a2 3 ^ 2 + 2 * 3 = 15`\n  refl,\nend\n\n\n/- Hint : How to start!\nStart with proof by contradiction. Type `by_contra h\u2081`.\nThen push the negation through the quantifiers with `push_neg at h\u2081`.\n-/\n\n/- Hint : How to introduce strong induction\nIf you've taken the hint above, your goal now will be to prove `false`. This isn't evidently \nsomething amenable to strong induction!\n\nHowever, you can show that it suffices to prove `\u2200 (x : \u2115), x \u2209 S` by filling in the sorry below.\n```\nsuffices hs : \u2200 (x : \u2115), x \u2209 S,\n{ sorry, },\n```\nThis leaves you with the goal of proving, by strong induction, that `\u2200 (x : \u2115), x \u2209 S`.\n-/\n\n/- Tactic: `tidy`\nIf a goal can be proved in a fairly straightforward manner from the assumptions, the `tidy` tactic\ncan sometimes find a proof.\n-/\n\n/- Hint : A crucial inequality result\nAt some point in your proof you may need to use the fact that `m < (succ n) \u2194 m \u2264 n`. This result\nis called `lt_succ_iff`.\n-/\n\n/- Theorem :\nEvery nonempty set of natural numbers has a minimal element.\n-/\nlemma well_ordering_principle {S : set \u2115} (h : S.nonempty) : \u2203 (n : \u2115), min_element n S :=\nbegin\n", "proof": "  by_contra h\u2081,\n  push_neg at h\u2081,\n  suffices hs : \u2200 (x : \u2115), x \u2209 S,\n  { cases h with m hm,\n    specialize hs m,\n    contradiction, },\n  let P := \u03bb x, x \u2209 S,\n  have base : P 0,\n  { intro h\u2082,\n    apply h\u2081 0,\n    tidy, },\n  have ind_step : \u2200 (k : \u2115), (\u2200 (m : \u2115), m \u2264 k \u2192 P m) \u2192 P (k + 1),\n  { assume k : \u2115,\n    assume ih : \u2200 (m : \u2115), m \u2264 k \u2192 P m,\n    dsimp [min_element] at h\u2081,\n    push_neg at h\u2081, \n    assume h\u2082 : k + 1 \u2208 S,\n    rcases (h\u2081 (k.succ)) h\u2082 with \u27e8m, h\u2083, h\u2084\u27e9,\n    specialize ih m (nat.le_of_succ_le_succ h\u2084),\n    contradiction, },\n  apply strong_induction base ind_step,\n\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n\nend exlean -- hide", "height": 31, "editorText": "sorry", "lineOffset": 72, "name": "well_ordering_principle", "statement": "{S : set \u2115} (h : S.nonempty) : \u2203 (n : \u2115), min_element n S"}, {"type": "lean", "content": "690", "hidden": true}]}], "parents": [0, 3]}, {"name": "691", "levels": [{"name": "", "problemIndex": 14, "objects": [{"type": "lean", "content": "692", "hidden": true}, {"type": "text", "content": "693"}, {"type": "lean", "content": "694", "hidden": true}, {"type": "lean", "content": "695", "hidden": true}, {"type": "text", "content": "696"}, {"type": "lean", "content": "697", "hidden": true}, {"type": "axiom", "content": "698", "name": "dvd_def (x y : \u2124)", "sideBar": true}, {"type": "lean", "content": "699", "hidden": true}, {"type": "text", "content": "700"}, {"type": "tactic", "content": "701", "name": "use", "sideBar": true}, {"type": "lean", "content": "702", "hidden": false}, {"type": "tactic", "content": "703", "name": "norm_num", "sideBar": true}, {"type": "text", "content": "704"}, {"type": "text", "content": "705"}, {"type": "theorem", "text": "706", "lean": "theorem six_dvd_seventy_two : (6 : \u2124) \u2223 72 :=\n", "sideBar": false, "firstProofLineNumber": 77, "lastProofLineNumber": 81, "textBefore": "import tactic.ring -- hide\n\n/-\n#  Divisibility\n\n## Level 1: The definition of divisibility\n\nThe notation `x \u2223 y` means `\u2203 (m : \u2124), y = x * m`. Here, the symbol, `\u2223` is typed `\\|` or `\\mid`.\n-/\n\n\nnamespace exlean -- hide\n\ndef myint_dvd : \u2124 \u2192 \u2124 \u2192 Prop := \u03bb (x y : \u2124), \u2203 (m : \u2124), y = x * m -- hide\n\n/-\nIf you forget this definition or ever want to replace `x \u2223 y` with the definition in a proof, use\nthe result `dvd_def`.\n-/\n\nvariables {x y : \u2124} -- hide\n\n/- Axiom : dvd_def (x y : \u2124)\nx \u2223 y \u2194 \u2203 (m : \u2124), y = x * m\n-/\nlemma dvd_def : x \u2223 y \u2194 \u2203 (m : \u2124), y = x * m := by refl -- hide\n\n/-\nFor example, we will prove that `5 \u2223 10`. In the (unecessary) first line of the proof, we rewrite\n`5 \u2223 10` using the definition of divisibility to give `\u2203 (m : \u2124), 10 = 5 * m`. \n\nIt remains to *find* an `m` that works. Let's use `2`. After that, we must prove `10 = 5 * 2`. But\nthis follows by definition of multiplication. A `norm_num` proof works.\n-/\n\n/- Tactic : use\nIf the goal is `\u22a2 \u2203 (x : \u03b1), P x` and if `y : \u03b1`, then `use y` changes the goal to\n`\u22a2 P y`.\n\n### Example\nWith a goal `\u22a2 \u2203 (x : \u2124), x + 5 = 23`, typing `use 18` changes the goal to `\u22a2 18 + 5 = 23`.\n-/\n\nexample : (5 : \u2124) \u2223 10 :=\nbegin\n  rw dvd_def,\n  use 2,\n  norm_num,\nend\n\n/- Tactic : norm_num\n\nThe `norm_num` tactic proves numerical goals. For example, it will close the goal\n`\u22a2 10 * 3 + 5 = 37 - 7`\n-/\n\n/-\nIf you were to write the proof 'by hand', you might write the following:\n\n> By definition, it suffices to show there exists an integer `m` such that `10 = 5 * m`.\n> Take `2` for `m`. Then we must show `10 = 5 * 2`.\n> This is true by arithmetic.\n-/\n\n/-\n### Tasks\n* By making a minor variation to the proof above, show that `6 \u2223 72`.\n\n* Write the same proof by hand.\n-/\n\n/- Theorem : no-side-bar\n`6 divides 72`\n-/\ntheorem six_dvd_seventy_two : (6 : \u2124) \u2223 72 :=\nbegin\n", "proof": "  rw dvd_def,\n  use 12,\n  norm_num,\n\n  ", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 5, "editorText": "sorry", "lineOffset": 76, "name": "six_dvd_seventy_two", "statement": "(6 : \u2124) \u2223 72"}, {"type": "lean", "content": "707", "hidden": true}]}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "708", "hidden": true}, {"type": "text", "content": "709"}, {"type": "lean", "content": "710", "hidden": true}, {"type": "text", "content": "711"}, {"type": "hint", "content": "712", "title": "713"}, {"type": "theorem", "text": "714", "lean": "theorem dvd_refl (a : \u2124) : a \u2223 a :=\n", "sideBar": true, "firstProofLineNumber": 25, "lastProofLineNumber": 30, "textBefore": "import tactic.linarith divisibility.dvd_definition -- hide\n\n/-\n#  Divisibility\n\n## Level 2: Reflexivity of divisibility\n-/\n\nnamespace exlean --hide\n\n/-\nIn this short level, your task is to prove reflexvity of the divisiblity relation.\n-/\n\n/- Hint : Using the definition of divisibility\nYou can use `rw dvd_def` to replace `x \u2223 y` with its definition.\n-/\n\n\n/- Theorem :\n`a \u2223 a`, for every integer `a`.\n-/\ntheorem dvd_refl (a : \u2124) : a \u2223 a :=\nbegin\n", "proof": "  use 1,\n  norm_num,\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 6, "editorText": "sorry", "lineOffset": 24, "name": "dvd_refl", "statement": "(a : \u2124) : a \u2223 a"}, {"type": "lean", "content": "715", "hidden": true}]}, {"name": "", "problemIndex": 4, "objects": [{"type": "lean", "content": "716", "hidden": true}, {"type": "text", "content": "717"}, {"type": "lean", "content": "718", "hidden": true}, {"type": "text", "content": "719"}, {"type": "theorem", "text": "720", "lean": "theorem dvd_zero (a : \u2124) : a \u2223 0 :=\n", "sideBar": true, "firstProofLineNumber": 23, "lastProofLineNumber": 29, "textBefore": "import tactic.linarith divisibility.dvd_refl -- hide\n\n/-\n#  Divisibility\n\n## Level 3: Every number is a factor of zero\n-/\n\nnamespace exlean --hide\n\n\n\n/-\n### Task\nProve that every number is a factor of zero.\n-/\n\n/- Theorem :\nLet `a` be an integer. Then `a \u2223 0`.\n-/\ntheorem dvd_zero (a : \u2124) : a \u2223 0 :=\nbegin\n", "proof": "  rw dvd_def,\n  use 0,\n  norm_num,\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 7, "editorText": "sorry", "lineOffset": 22, "name": "dvd_zero", "statement": "(a : \u2124) : a \u2223 0"}, {"type": "lean", "content": "721", "hidden": true}]}, {"name": "", "problemIndex": 12, "objects": [{"type": "lean", "content": "722", "hidden": true}, {"type": "text", "content": "723"}, {"type": "lean", "content": "724", "hidden": true}, {"type": "text", "content": "725"}, {"type": "text", "content": "726"}, {"type": "lean", "content": "727", "hidden": true}, {"type": "axiom", "content": "728", "name": "dvd_add (a b c : \u2124)", "sideBar": true}, {"type": "lean", "content": "729", "hidden": false}, {"type": "tactic", "content": "730", "name": "cases", "sideBar": true}, {"type": "tactic", "content": "731", "name": "linarith", "sideBar": true}, {"type": "text", "content": "732"}, {"type": "text", "content": "733"}, {"type": "theorem", "text": "734", "lean": "theorem dvd_mul_of_dvd_left (h : a \u2223 b) (c : \u2124) : a \u2223 b * c :=\n", "sideBar": true, "firstProofLineNumber": 98, "lastProofLineNumber": 104, "textBefore": "import tactic.linarith divisibility.dvd_zero -- hide\n\n/-\n#  Divisibility\n\n## Level 4: A multiplication lemma\n-/\n\nnamespace exlean --hide\n\n/-\nIn the last level, you *proved* a divisibility statement. In this level, you'll *decompose* given\ndivisibility statements.\n\nTo prove a statement of the form `x \u2223 y` is to prove an existentially-quantified statement, by\nexists introduction (the `use` tactic in Lean).\n\nOn the other hand, a given divisibility statement `h : a \u2223 b` represents the\nexistentially-quantified statement `h : \u2203 (m : \u2124), b = a * m`. We decompose this to an integer `k`\nand a hypothesis `h\u2082 : b = a * k` via `cases h with m h\u2082`. In handwritten mathematics, this\nis exists elimination.\n-/\n\n/-\n### An addition result\n\nBelow, I present a proof that given `h\u2081 : a \u2223 b` and `h\u2082 : a \u2223 c`, then `a \u2223 b + c` follows.\n-/\n\nvariables {a b c d : \u2124} -- hide\n\n/- Axiom : dvd_add (a b c : \u2124)\n(h\u2081 : a \u2223 b) (h\u2082 : a \u2223 c) : a \u2223 b + c\n-/\ntheorem dvd_add (h\u2081 : a \u2223 b) (h\u2082 : a \u2223 c) : a \u2223 b + c :=\nbegin\n  cases h\u2081 with m\u2081 h\u2083, -- We have `m\u2081 : \u2124` and `h\u2083 : b = a * m\u2081`.\n  cases h\u2082 with m\u2082 h\u2084, -- We have `m\u2082 : \u2124` and `h\u2084 : c = a * m\u2082`.\n  rw dvd_def, -- `\u22a2 \u2203 (m : \u2124), b + c = a * m`.\n  use (m\u2081 + m\u2082), -- Take `m\u2081 + m\u2082` for `m`.\n  rw [h\u2083, h\u2084], -- From `h\u2083` & `h\u2084`, `\u22a2 a * m\u2081 + a * m\u2082 = a * (m\u2081 + m\u2082)`.\n  linarith, -- This holds by algebra.\nend\n\n/- Tactic : cases\n`cases` is a general-purpose elimination tactic. It it used to 'decompose' a hypothesis into\nits constituent parts.\n\n### Examples\n\n* Given `h : \u2203 (x : \u2124), x + 5 = y`, typing `cases h with m h\u2082` replaces `h` with `m : \u2124` and\n`h\u2082 : m + 5 = y`.\n\n* Given `h : p \u2227 q`, typing `cases h with hp hq` replaces `h` with `hp : p` and `hq : q`.\n\n* Given `h : p \u2228 q`, typing `cases h with hp hq` replaces the current goal with two goals\n(1) in which `h` is replaced with `hp : p` and (2) in which `h` is replaced with `hq : q`.\n\n* Given `x : \u2115`, typing `cases x with k` replaces the goal with two new goals: (1) a goal in which\nevery occurence of `x` is replaced with `0` and (2) a goal with a new variable `k : \u2115` and in \nwhich every occurrence of `x` is replaced with `succ k`.\n-/\n\n\n/- Tactic : linarith\n`linarith` proves many 'algebraic' equations and inequalities. For example, it can prove\n`(x + y) ^ 2 = x ^ 2 + 2 * x * y + y ^ 2`. It can pr\n-/\n\n/-\nExtracing the comments from the above gives a handwritten proof:\n\n> We have `m\u2081 : \u2124` and `h\u2083 : b = a * m\u2081`.\n>\n> We have `m\u2082 : \u2124` and `h\u2084 : c = a * m\u2082`.\n>\n> We must show `\u2203 (m : \u2124), b + c = a * m`.\n>\n> Take `m\u2081 + m\u2082` for `m`. We must show `b + c = a * (m\u2081 + m\u2082)`.\n>\n> From `h\u2083` and `h\u2084`, we must show `a * m\u2081 + a * m\u2082 = a * (m\u2081 + m\u2082)`.\n>\n> This holds by algebra.\n-/\n\n/-\n### Tasks\n* Adapting the Lean proof above, show that if `h : a \u2223 b`, then `a \u2223 b * c` for all integers `c`.\n\n* Write the same proof by hand.\n-/\n\n/- Theorem :\nLet `a, b` be integers. Given `h : a \u2223 b`, we have `a \u2223 b * c`, for all integers `c`.\n-/\ntheorem dvd_mul_of_dvd_left (h : a \u2223 b) (c : \u2124) : a \u2223 b * c :=\nbegin\n", "proof": "  cases h with m h\u2082,\n  use m * c,\n  rw [h\u2082, mul_assoc],\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n\nend exlean -- hide", "height": 7, "editorText": "sorry", "lineOffset": 97, "name": "dvd_mul_of_dvd_left", "statement": "(h : a \u2223 b) (c : \u2124) : a \u2223 b * c"}, {"type": "lean", "content": "735", "hidden": true}]}, {"name": "", "problemIndex": -1, "objects": [{"type": "lean", "content": "736", "hidden": true}, {"type": "text", "content": "737"}, {"type": "lean", "content": "738", "hidden": true}, {"type": "text", "content": "739"}, {"type": "text", "content": "740"}, {"type": "text", "content": "741"}, {"type": "lean", "content": "742", "hidden": true}, {"type": "lean", "content": "743", "hidden": false}, {"type": "lean", "content": "744", "hidden": true}]}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "745", "hidden": true}, {"type": "text", "content": "746"}, {"type": "lean", "content": "747", "hidden": true}, {"type": "lean", "content": "748", "hidden": true}, {"type": "text", "content": "749"}, {"type": "text", "content": "750"}, {"type": "theorem", "text": "751", "lean": "theorem mul_dvd_mul (h\u2081 : a \u2223 b) (h\u2082 : c \u2223 d) : a * c \u2223 b * d :=\n", "sideBar": true, "firstProofLineNumber": 33, "lastProofLineNumber": 42, "textBefore": "import tactic.linarith divisibility.zero_dvd_iff-- hide\n\n/-\n#  Divisibility\n\n## Level 6: A second multiplication lemma\n-/\n\nnamespace exlean --hide\n\n\nvariables {a b c d : \u2124} -- hide\n\n/-\n### Tasks\n* Adapting the Lean proof of `dvd_add` from a previous level, show that if `h\u2081 : a \u2223 b` and `h\u2082 : c \u2223 d`, then\n`a * c \u2223 b * d`.\n\n* Write the same proof by hand.\n-/\n\n/-\n### Typing subscripts\n\nIn Lean, type `h\u2081` as `h\\1`.\n-/\n\n/- Theorem :\nLet `a, b, c, d` be integers. Given `h\u2081 : a \u2223 b` and `h\u2082 : c \u2223 d`, we have `a * c \u2223 b * d`.\n-/\ntheorem mul_dvd_mul (h\u2081 : a \u2223 b) (h\u2082 : c \u2223 d) : a * c \u2223 b * d :=\nbegin\n", "proof": "  cases h\u2081 with m\u2081 h\u2081,\n  cases h\u2082 with m\u2082 h\u2082,\n  rw dvd_def,\n  use (m\u2081 * m\u2082),\n  rw [h\u2081, h\u2082],\n  ring,\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 10, "editorText": "sorry", "lineOffset": 32, "name": "mul_dvd_mul", "statement": "(h\u2081 : a \u2223 b) (h\u2082 : c \u2223 d) : a * c \u2223 b * d"}, {"type": "lean", "content": "752", "hidden": true}]}, {"name": "", "problemIndex": 9, "objects": [{"type": "lean", "content": "753", "hidden": true}, {"type": "text", "content": "754"}, {"type": "lean", "content": "755", "hidden": true}, {"type": "text", "content": "756"}, {"type": "text", "content": "757"}, {"type": "text", "content": "758"}, {"type": "lean", "content": "759", "hidden": true}, {"type": "lean", "content": "760", "hidden": false}, {"type": "tactic", "content": "761", "name": "apply", "sideBar": true}, {"type": "theorem", "text": "762", "lean": "theorem dvd_mul_add_mul (h\u2081 : a \u2223 b) (h\u2082 : a \u2223 c) : a \u2223 b * s + c * t :=\n", "sideBar": true, "firstProofLineNumber": 68, "lastProofLineNumber": 76, "textBefore": "import tactic.linarith divisibility.mul_dvd_mul -- hide\n\n/-\n#  Divisibility\n\n## Level 7: Divisibility of linear combinations\n-/\n\nnamespace exlean --hide\n\n/-\nHere are some of the properties of the divisibility relation that you've seen so far:\n\n* [Definition] `a \u2223 b` means `\u2203 (m : \u2124), b = a * m`.\n\n* [Reflexivity] `dvd_refl : a \u2223 a`.\n\n* `dvd_add` given `h\u2081 : a \u2223 b` and `h\u2082 : a \u2223 c`, we have `a \u2223 b + c`.\n\n* `dvd_mul_of_dvd_left` given `h : a \u2223 b`, we have `a \u2223 b * c`, for any `c : \u2124`.\n\n-/\n\n\n/-\n### Tasks\n* By applying some of the results above, prove that if `a \u2223 b` and `a \u2223 c`, then `a` divides any\nlinear combination of `b` and `c`. That is, `a \u2223 b * s + c * t`, for all integers `s` and `t`. \n\n* Write the same proof by hand.\n-/\n\n/-\nIf you were writing this proof by hand, you might start by saying that it suffices (by `dvd_add`)\nto prove `a \u2223 b * s` and `a \u2223 c * t`. To do this in Lean, type `apply dvd_add`. Here's an\nexample of this kind of reasoning.\n-/\n\nvariables {a b c d s t : \u2124} -- hide\n\nexample (h\u2081 : a \u2223 b) (h\u2082 : a \u2223 c) (h\u2083 : a \u2223 d) : a \u2223 (b + c) + d :=\nbegin\n  apply dvd_add, -- 2 goals `\u22a2 a \u2223 b + c` and `\u22a2 a \u2223 d`\n  { -- 1) `\u22a2 a \u2223 b + c` \n    apply dvd_add, -- 2 goals `\u22a2 a \u2223 b` and `\u22a2 a \u2223 c`\n    { -- 1.1) `\u22a2 a \u2223 b`\n      exact h\u2081, }, -- This follows from `h\u2081`.\n    { -- 1.2) `\u22a2 a \u2223 c`\n      exact h\u2082, }, }, -- This follows from `h\u2082`.\n  { -- 2) `\u22a2 a \u2223 d`.\n    exact h\u2083, }, -- This follows from `h\u2083`.\nend\n\n/- Tactic : apply\nMost theorems have conditions under which they hold. For example, `dvd_add` states that\n`a \u2223 b + c` given the conditions `a \u2223 b` and `a \u2223 c`. If the target is `\u22a2 a \u2223 b + c`, then\ntyping `apply dvd_add` creates two new goals: (1) to prove `a \u2223 b` and (2) to prove `a \u2223 c`.\n\nThe use of `apply` can be shortened. If the hypotheses `h\u2081 : a \u2223 b` and `h\u2082 : a \u2223 c` are in the\ncontext, then the target `a \u2223 b + c` can be proved with `apply h\u2081 h\u2082`.\n-/\n\n/- Theorem :\nGiven `h\u2081 : a \u2223 b` and `h\u2082 : a \u2223 c`, we have `a \u2223 b * s + c * t`, for all integers `s` and `t`.\n-/\ntheorem dvd_mul_add_mul (h\u2081 : a \u2223 b) (h\u2082 : a \u2223 c) : a \u2223 b * s + c * t :=\nbegin\n", "proof": "  apply dvd_add,\n  { apply dvd_mul_of_dvd_left h\u2081, },\n  { apply dvd_mul_of_dvd_left h\u2082, },\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 9, "editorText": "sorry", "lineOffset": 67, "name": "dvd_mul_add_mul", "statement": "(h\u2081 : a \u2223 b) (h\u2082 : a \u2223 c) : a \u2223 b * s + c * t"}, {"type": "lean", "content": "763", "hidden": true}]}, {"name": "", "problemIndex": 4, "objects": [{"type": "lean", "content": "764", "hidden": true}, {"type": "text", "content": "765"}, {"type": "lean", "content": "766", "hidden": true}, {"type": "lean", "content": "767", "hidden": true}, {"type": "theorem", "text": "768", "lean": "theorem dvd_trans (h\u2081 : a \u2223 b) (h\u2082 : b \u2223 c) : a \u2223 c :=\n", "sideBar": true, "firstProofLineNumber": 18, "lastProofLineNumber": 26, "textBefore": "import tactic.linarith divisibility.dvd_mul_add_mul-- hide\n\n/-\n#  Divisibility\n\n## Level 8: Transtivity of divisibility\n-/\n\nnamespace exlean --hide\n\nvariables {a b c : \u2124} -- hide\n\n/- Theorem :\nLet `a, b, c, d` be integers. Given `h\u2081 : a \u2223 b` and `h\u2082 : c \u2223 d`, we have `a * c \u2223 b * d`.\n-/\ntheorem dvd_trans (h\u2081 : a \u2223 b) (h\u2082 : b \u2223 c) : a \u2223 c :=\nbegin\n", "proof": "  cases h\u2081 with m\u2081 h\u2081,\n  cases h\u2082 with m\u2082 h\u2082,\n  rw dvd_def,\n  use (m\u2081 * m\u2082),\n  rw [h\u2082, h\u2081, mul_assoc],  \n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 9, "editorText": "sorry", "lineOffset": 17, "name": "dvd_trans", "statement": "(h\u2081 : a \u2223 b) (h\u2082 : b \u2223 c) : a \u2223 c"}, {"type": "lean", "content": "769", "hidden": true}]}, {"name": "", "problemIndex": 15, "objects": [{"type": "lean", "content": "770", "hidden": true}, {"type": "text", "content": "771"}, {"type": "lean", "content": "772", "hidden": true}, {"type": "lean", "content": "773", "hidden": true}, {"type": "text", "content": "774"}, {"type": "lean", "content": "775", "hidden": true}, {"type": "axiom", "content": "776", "name": "dvd_antisymm (h\u2081 : 0 \u2264 a) (h\u2082 : 0 \u2264 b) (h\u2083 : a \u2223 b) (h\u2084 : b \u2223 a) :", "sideBar": true}, {"type": "lean", "content": "777", "hidden": true}, {"type": "lean", "content": "778", "hidden": true}, {"type": "lean", "content": "779", "hidden": false}, {"type": "text", "content": "780"}, {"type": "lean", "content": "781", "hidden": false}, {"type": "tactic", "content": "782", "name": "split", "sideBar": true}, {"type": "hint", "content": "783", "title": "784"}, {"type": "hint", "content": "785", "title": "786"}, {"type": "theorem", "text": "787", "lean": "lemma dvd_right_iff_eq (h\u2081 : 0 \u2264 b) (h\u2082 : 0 \u2264 c) :\n(\u2200 (a : \u2124), b \u2223 a \u2194 c \u2223 a) \u2194 b = c :=\n", "sideBar": false, "firstProofLineNumber": 81, "lastProofLineNumber": 104, "textBefore": "import tactic.linarith divisibility.dvd_trans  -- hide\n\n/-\n# Divisibility\n\n## Level 9: Antisymmetry\n-/\n\nnamespace exlean -- hide\n\nopen int -- hide\n\n/-\nThe divisibility relation is antisymmetric.\nThat is, suppose `a` and `b` are non-negative integers such that `a \u2223 b`, and `b \u2223 a`, then `a = b`.\n-/\nvariables {a b c d : \u2124} -- hide\n\n/- Axiom : dvd_antisymm (h\u2081 : 0 \u2264 a) (h\u2082 : 0 \u2264 b) (h\u2083 : a \u2223 b) (h\u2084 : b \u2223 a) :\na = b\n-/\ntheorem dvd_antisymm (H1 : 0 \u2264 a) (H2 : 0 \u2264 b) : a \u2223 b \u2192 b \u2223 a \u2192 a = b :=  -- hide\ndvd_antisymm H1 H2                                                        -- hide\n\n\nexample (h\u2081 : 0 \u2264 a) (h\u2082 : 0 \u2264 b) (h\u2083 : a \u2223 b) (h\u2084 : b \u2223 a) : a = b :=\nbegin\n  exact dvd_antisymm h\u2081 h\u2082 h\u2083 h\u2084,\nend\n\n/-\nIn this level, we'll prove an if and only if (`\u2194`) statement. To split an `\u2194` statement into two\nimplications, use the `split` tactic.\n\nIn the example below, the initial goal is $\\vdash a = 2b + c \\iff c = a - 2b$. After using the\n`split` tactic, we have two new goals: (1) $\\vdash a = 2b + c \\to c = a - 2b$ and \n(2) $\\vdash c = a - 2b \\to a = 2b + c$.\n-/\n\nexample : a = 2 * b + c \u2194 c = a - 2 * b :=\nbegin\n  split, \n  { -- 1) `\u22a2 a = 2 * b + c \u2192 c = a - 2 * b`.\n    assume h : a = 2 * b + c, -- `\u22a2 c = 2 * b - a`\n    linarith, },\n  { -- 2) `\u22a2 c = a - 2 * b \u2192 a = 2 * b + c`.\n    assume h : c = a - 2 * b,\n    linarith, },\nend\n\n/- Tactic : split\n\nThe `split` tactic splits a 'compound' target into multiple goals. \n\nFor example, `split` turns the target `\u22a2 p \u2194 q` into two goals: (1) to prove\n`p \u2192 q` and (2) to prove `q \u2192 p`.\n\nEqually, if the target is `\u22a2 p \u2227 q`, then `split` creates goals (1) `\u22a2 p` and (2) `\u22a2 q`.\n-/\n\n/- Hint : Specialzing a universally-quantified statement.\n\nSuppose `P` is a predicate. Recall that if `h : \u2200 (x : \u03b1), P(x)` and if `y : \u03b1`, then\n`specialize h y` replaces `h` with `P(y)`.\n-/\n\n/- Hint : Decomposing a `\u2194` statement.\n\nSuppose `h : p \u2194 q`. Then the tactic `cases h with h\u2082 h\u2083` replaces `h` with `h\u2082 : p \u2192 q` and\n`h\u2083 : q \u2192 p`.\n-/\n\n\n/- Theorem : no-side-bar\nGiven `d` is a common divisor of `a` and `b` and given `c \u2223 d`, we have `c` is a common divisor of\n`a` and `b`.\n-/\nlemma dvd_right_iff_eq (h\u2081 : 0 \u2264 b) (h\u2082 : 0 \u2264 c) :\n(\u2200 (a : \u2124), b \u2223 a \u2194 c \u2223 a) \u2194 b = c :=\nbegin\n", "proof": "  split,\n  { assume h : \u2200 (a : \u2124), b \u2223 a \u2194 c \u2223 a,\n    apply dvd_antisymm h\u2081 h\u2082,\n    { specialize h c,\n      cases h with h\u2083 h\u2084,\n      apply h\u2084,\n      apply dvd_refl, },\n    { specialize h b,\n      cases h with h\u2083 h\u2084,\n      apply h\u2083,\n      apply dvd_refl, }, },\n  { assume h : b = c,\n    assume a : \u2124,\n    rw h,  },\n\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n\n\nend exlean -- hide", "height": 24, "editorText": "sorry", "lineOffset": 80, "name": "dvd_right_iff_eq", "statement": "(h\u2081 : 0 \u2264 b) (h\u2082 : 0 \u2264 c) :\n(\u2200 (a : \u2124), b \u2223 a \u2194 c \u2223 a) \u2194 b = c"}, {"type": "lean", "content": "788", "hidden": true}]}, {"name": "", "problemIndex": 8, "objects": [{"type": "lean", "content": "789", "hidden": true}, {"type": "text", "content": "790"}, {"type": "lean", "content": "791", "hidden": true}, {"type": "text", "content": "792"}, {"type": "lean", "content": "793", "hidden": false}, {"type": "text", "content": "794"}, {"type": "lean", "content": "795", "hidden": false}, {"type": "text", "content": "796"}, {"type": "theorem", "text": "797", "lean": "theorem four_common_divisor_48_60 : common_divisor 4 48 60 :=\n", "sideBar": false, "firstProofLineNumber": 45, "lastProofLineNumber": 52, "textBefore": "import tactic.linarith divisibility.dvd_antisymm  -- hide\n\n/-\n# Divisibility\n\n## Level 10: Common divisor basics\n-/\n\nnamespace exlean -- hide\n\n/-\nLet `m, n, and d` be integers. For `d` to be a _common divisor_ of `m` and `n` means that\n`d \u2223 m` and `d \u2223 n`.\n-/\n\ndef common_divisor (d m n : \u2124) := (d \u2223 m) \u2227 (d \u2223 n)\n\n/-\nUsing the above definition, we'll show that `5` is a common divisor of `20` and `30`.\n-/\nexample : common_divisor 5 20 30 :=\nbegin\n  split, -- We'll show 1) `5 \u2223 20` and 2) `5 \u2223 30`.\n  { use 4,  -- 1) `\u22a2 5 \u2223 20`, it suffices to show `20 = 5 * 4`.\n    norm_num, }, -- This holds by arithmetic.\n  { use 6,  -- 2) `\u22a2 30 = 5 * 6`, it suffices to show `\u22a2 30 = 5 * 6`.\n    norm_num, }, -- This holds by arithmetic.\nend\n\n/-\n### Tasks\n\n* Adapt the Lean proof above to show that `4` is a common divisor of `48` and `60`.\n\n* Give a handwritten proof of the same result.\n\n-/\n\n\n/- Theorem : no-side-bar\n`4` is a common divisor of `48` and `60`.\n-/\ntheorem four_common_divisor_48_60 : common_divisor 4 48 60 :=\nbegin\n", "proof": "  split,\n  { use 12,\n    norm_num, },\n  { use 15,\n    norm_num, },\n\n\n  ", "proof_hint": "sorry", "textAfter": "\nend\n\n\nend exlean -- hide", "height": 8, "editorText": "sorry", "lineOffset": 44, "name": "four_common_divisor_48_60", "statement": "common_divisor 4 48 60"}, {"type": "lean", "content": "798", "hidden": true}]}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "799", "hidden": true}, {"type": "text", "content": "800"}, {"type": "lean", "content": "801", "hidden": true}, {"type": "text", "content": "802"}, {"type": "lean", "content": "803", "hidden": true}, {"type": "lean", "content": "804", "hidden": false}, {"type": "theorem", "text": "805", "lean": "theorem common_divisor_of_common_divisor_of_dvd\n(h\u2081 : common_divisor d a b) (h\u2082 : c \u2223 d) : common_divisor c a b :=\n", "sideBar": false, "firstProofLineNumber": 42, "lastProofLineNumber": 54, "textBefore": "import tactic.linarith divisibility.common_divisors  -- hide\n\n/-\n# Divisibility\n\n## Level 11: Common divisor results\n-/\n\nnamespace exlean -- hide\n\n/-\n### Tasks\n\nIn this level, you'll *decompose* the hypothesis that `d` is a common divisor of `a` and `b` to\nprove that `c` is a common divisor of `a` and `b`, under the hypothesis that `c \u2223 d`.\n\nAs `common_divisor d a b` is a conjunctive (an 'and') statement, it can be decomposed into\nits constituent parts using the `cases` tactic. See the example below.\n-/\n\nvariables {d a b c s t : \u2124} -- hide\n\n\nexample (h\u2081 : common_divisor d a b) : common_divisor d a (a * s + b * t) :=\nbegin\n  rw common_divisor at h\u2081, -- `h\u2081 : (d \u2223 a) \u2227 (d \u2223 b)`\n  cases h\u2081 with hda hdb, -- `hda : d \u2223 a`, `hdb : d \u2223 b`.\n  rw common_divisor, -- `\u22a2 (d \u2223 a) \u2227 (d \u2223 a * s + b * t)`\n  split, -- 2 goals: (1) `\u22a2 d \u2223 a` and (2) `\u22a2 d \u2223 a * s + b * t`.\n  { exact hda, }, -- (1) follows from `hda`\n  { apply dvd_mul_add_mul hda hdb, }, -- (2) follows from\n  -- our previous result on divisibility of linear combinations.\nend\n\n/- Theorem : no-side-bar\nGiven `d` is a common divisor of `a` and `b` and given `c \u2223 d`, we have `c` is a common divisor of\n`a` and `b`.\n-/\ntheorem common_divisor_of_common_divisor_of_dvd\n(h\u2081 : common_divisor d a b) (h\u2082 : c \u2223 d) : common_divisor c a b :=\nbegin\n", "proof": "  cases h\u2081 with hda hdb,\n  split,\n  { apply dvd_trans h\u2082 hda, },\n  { apply dvd_trans h\u2082 hdb },  \n\n  \n\n\n\n\n\n\n  ", "proof_hint": "sorry", "textAfter": "\nend\n\n\nend exlean -- hide", "height": 13, "editorText": "sorry", "lineOffset": 41, "name": "common_divisor_of_common_divisor_of_dvd", "statement": "(h\u2081 : common_divisor d a b) (h\u2082 : c \u2223 d) : common_divisor c a b"}, {"type": "lean", "content": "806", "hidden": true}]}, {"name": "", "problemIndex": 9, "objects": [{"type": "lean", "content": "807", "hidden": true}, {"type": "text", "content": "808"}, {"type": "lean", "content": "809", "hidden": true}, {"type": "lean", "content": "810", "hidden": true}, {"type": "text", "content": "811"}, {"type": "lean", "content": "812", "hidden": false}, {"type": "text", "content": "813"}, {"type": "lean", "content": "814", "hidden": true}, {"type": "hint", "content": "815", "title": "816"}, {"type": "theorem", "text": "817", "lean": "theorem uniqueness_of_greatest_common_divisor (k\u2081 : 0 \u2264 d) (k\u2082 : 0 \u2264 e)\n(h\u2081 : greatest_common_divisor d m n )\n(h\u2082 : greatest_common_divisor e m n) : d = e :=\n", "sideBar": true, "firstProofLineNumber": 46, "lastProofLineNumber": 64, "textBefore": "import tactic.linarith divisibility.common_divisors2  -- hide\n\n/-\n# Divisibility\n\n## Level 12: Greatest common divisors\n-/\n\nnamespace exlean -- hide\n\nopen int -- hide\n\n/-\nRecall that for `d` to be a common divisor of `a` and `b` means that `d \u2223 a` and `d \u2223 b`.\n\nFor `d` to be a _greatest common divisor_ of `m` and `n` means that\n* `d` is a common divisor of `m` and `n` and\n* if `e` is a common divisor of `m` and `n`, then `e \u2223 d`.\n-/\n\ndef greatest_common_divisor (d m n : \u2124) := (common_divisor d m n) \u2227 \n  (\u2200 (e : \u2124), common_divisor e m n \u2192 e \u2223 d)\n\n/-\n### Task\n\nShow that if the non-negative integers `d` and `e` are both greatest common divisors of `m` and `n`,\nthen `d = e`.\n-/\n\nvariables {d e m n : \u2124} -- hide\n\n/- Hint : Proving an equality\nRecall that `apply dvd_antisymm k\u2081 k\u2082,` will reduce the goal to two goals (1) `\u22a2 d \u2223 e` and\n(2) `\u22a2 e \u2223 d`.\n-/\n\n/- Theorem :\nIf the non-negative integers `d` and `e` are both greatest common divisors of `m` and `n`,\nthen `d = e`.\n-/\ntheorem uniqueness_of_greatest_common_divisor (k\u2081 : 0 \u2264 d) (k\u2082 : 0 \u2264 e)\n(h\u2081 : greatest_common_divisor d m n )\n(h\u2082 : greatest_common_divisor e m n) : d = e :=\nbegin\n", "proof": "  cases h\u2081 with hdcomm hdgreat,\n  cases h\u2082 with hecomm hegreat,\n  apply dvd_antisymm k\u2081 k\u2082,\n  { specialize hegreat d,\n    apply hegreat hdcomm, },\n  { specialize hdgreat e,\n    apply hdgreat hecomm, },\n\n\n\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n\nend exlean -- hide", "height": 19, "editorText": "sorry", "lineOffset": 45, "name": "uniqueness_of_greatest_common_divisor", "statement": "(k\u2081 : 0 \u2264 d) (k\u2082 : 0 \u2264 e)\n(h\u2081 : greatest_common_divisor d m n )\n(h\u2082 : greatest_common_divisor e m n) : d = e"}, {"type": "lean", "content": "818", "hidden": true}]}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "819", "hidden": true}, {"type": "text", "content": "820"}, {"type": "lean", "content": "821", "hidden": true}, {"type": "lean", "content": "822", "hidden": true}, {"type": "hint", "content": "823", "title": "824"}, {"type": "theorem", "text": "825", "lean": "theorem greatest_common_divisor_zero (a : \u2124) :\ngreatest_common_divisor a a 0 :=\n", "sideBar": true, "firstProofLineNumber": 27, "lastProofLineNumber": 39, "textBefore": "import tactic.linarith divisibility.gcd_uniqueness -- hide\n\n/-\n# Divisibility\n\n## Level 13: Greatest common divisor of an integer and zero\n-/\n\nnamespace exlean -- hide\n\nopen int -- hide\n\n\n\n/- Hint : Starting the proof\nRecall that `greatest_common_divisor d a b` is a conjunctive statement. Thus, you can\nsplit the goal in two using the `split` tactic.\n-/\n\n\n/- Theorem :\n`a` is a greatest common divisor of `a` and `0`, for every integer `a`.\n-/\ntheorem greatest_common_divisor_zero (a : \u2124) :\ngreatest_common_divisor a a 0 :=\nbegin\n", "proof": "  split,\n  { split,\n    { apply dvd_refl, },\n    { apply dvd_zero, }, },\n  { assume e : \u2124,\n    assume h : common_divisor e a 0,\n    cases h with hea he0,\n    exact hea, },\n\n\n\n\n    ", "proof_hint": "sorry", "textAfter": "\nend\n\n\nend exlean -- hide", "height": 13, "editorText": "sorry", "lineOffset": 26, "name": "greatest_common_divisor_zero", "statement": "(a : \u2124) :\ngreatest_common_divisor a a 0"}, {"type": "lean", "content": "826", "hidden": true}]}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "827", "hidden": true}, {"type": "text", "content": "828"}, {"type": "lean", "content": "829", "hidden": true}, {"type": "lean", "content": "830", "hidden": true}, {"type": "lean", "content": "831", "hidden": true}, {"type": "theorem", "text": "832", "lean": "theorem greatest_common_divisor_comm (h : greatest_common_divisor d a b) :\ngreatest_common_divisor d b a :=\n", "sideBar": true, "firstProofLineNumber": 22, "lastProofLineNumber": 36, "textBefore": "import tactic.linarith divisibility.gcd_zero -- hide\n\n/-\n# Divisibility\n\n## Level 14: Commutativity of greatest common divisor\n-/\n\nnamespace exlean -- hide\n\nopen int -- hide\n\nvariables {a b d : \u2124} -- hide\n\n/- Theorem :\nIf $d$ is a greatest common divisor of $a$ and $b$, then $d$ is a greatest common divisor of\n$b$ and $a$.\n-/\ntheorem greatest_common_divisor_comm (h : greatest_common_divisor d a b) :\ngreatest_common_divisor d b a :=\nbegin\n", "proof": "  rcases h with \u27e8\u27e8hda, hdb\u27e9, hcomm\u27e9,\n  split,\n  { exact \u27e8hdb, hda\u27e9 },\n  { intros e h,\n    cases h with h\u2081 h\u2082,\n    apply (hcomm e),\n    exact \u27e8h\u2082, h\u2081\u27e9, },\n\n\n\n\n\n\n\n    ", "proof_hint": "sorry", "textAfter": "\nend\n\n\nend exlean -- hide", "height": 15, "editorText": "sorry", "lineOffset": 21, "name": "greatest_common_divisor_comm", "statement": "(h : greatest_common_divisor d a b) :\ngreatest_common_divisor d b a"}, {"type": "lean", "content": "833", "hidden": true}]}, {"name": "", "problemIndex": 14, "objects": [{"type": "lean", "content": "834", "hidden": true}, {"type": "text", "content": "835"}, {"type": "lean", "content": "836", "hidden": true}, {"type": "lean", "content": "837", "hidden": true}, {"type": "text", "content": "838"}, {"type": "lean", "content": "839", "hidden": true}, {"type": "lean", "content": "840", "hidden": true}, {"type": "lean", "content": "841", "hidden": true}, {"type": "lean", "content": "842", "hidden": false}, {"type": "lean", "content": "843", "hidden": true}, {"type": "text", "content": "844"}, {"type": "lean", "content": "845", "hidden": false}, {"type": "text", "content": "846"}, {"type": "hint", "content": "847", "title": "848"}, {"type": "theorem", "text": "849", "lean": "lemma division_unique (h : b \u2260 0)\n(h\u2081 : a = b * q\u2081 + r\u2081 \u2227 (0 \u2264 r\u2081 \u2227 r\u2081 < abs b)) \n(h\u2082 : a = b * q\u2082 + r\u2082 \u2227 (0 \u2264 r\u2082 \u2227 r\u2082 < abs b)) : q\u2081 = q\u2082 \u2227 r\u2081 = r\u2082 :=\n", "sideBar": true, "firstProofLineNumber": 66, "lastProofLineNumber": 97, "textBefore": "import tactic.linarith divisibility.gcd_comm  -- hide\n\n/-\n# Divisibility\n\n## Level 15: Division\n-/\n\nnamespace exlean -- hide\n\nopen int -- hide\n\n/-\nThe division lemma states that if `a` and `b` are integers with `b \u2260 0`, then there exist integers\n`q` and `r` for which `a = b * q + r` and `0 \u2264 r < |b|`.\n\nThe quantity `q` is called the quotient and `r` is called the remainder.\n-/\n\nvariables (a b : \u2124) -- hide\n\nlemma division (h : b \u2260 0) : \u2203 (q r : \u2124), a = b * q + r \u2227 (0 \u2264 r \u2227 r < abs b) :=     -- hide\n\u27e8a/b, a % b, by rw [add_comm, mod_add_div a b], mod_nonneg a h, mod_lt a h\u27e9  -- hide\n\nexample (h : b \u2260 0) : \u2203 (q r : \u2124), 700 = b * q + r \u2227 (0 \u2264 r \u2227 r < abs b) :=\nbegin\n  apply division 700 b h,\nend\n\nvariables {q\u2081 r\u2081 q\u2082 r\u2082 : \u2124} -- hide\n\n/-\nIn this (somewhat tricky) level, your task is to show uniquness of the quotient and remainder.\nYou may freely use the following lemma.\n-/\n\nlemma abs_sub_lt {x y c : \u2124} (h\u2081 : 0 \u2264 x \u2227 x < c) (h\u2082 : 0 \u2264 y \u2227 y < c) : abs (x - y) < c :=\nbegin\n  rw abs_sub_lt_iff,\n  split;\n  linarith,\nend\n\n/-\nOther useful results include:\n\n* `abs_mul : abs (a * b) = (abs a) * (abs b)`\n* `abs_nonneg : 0 \u2264 abs a`\n* `le_mul_of_one_le_right : 0 \u2264 b \u2192 1 \u2264 a \u2192 b \u2264 b * a`.\n-/\n\n/- Hint : Proof by cases\nAt some point in your proof, you'll need to consider separately the cases `q\u2081 = q\u2082` and `q\u2081 \u2260 q\u2082`.\nYou can do this with `by_cases h : q\u2081 = q\u2082` (replacing `h` with whatever name you like).\n-/\n\n\n/- Theorem :\nLet $a, b$ be integers with $b \u2260 0$. If $a = b q_1 + r_1 = b q_2  + r_2$, where\n$0 \\le r_1 < |b|$ and $0 \\le r_2 < |b|$, then $q_1 = q_2$ and $r_1 = r_2$.\n-/\nlemma division_unique (h : b \u2260 0)\n(h\u2081 : a = b * q\u2081 + r\u2081 \u2227 (0 \u2264 r\u2081 \u2227 r\u2081 < abs b)) \n(h\u2082 : a = b * q\u2082 + r\u2082 \u2227 (0 \u2264 r\u2082 \u2227 r\u2082 < abs b)) : q\u2081 = q\u2082 \u2227 r\u2081 = r\u2082 :=\nbegin\n", "proof": "  cases h\u2081 with hx\u2081 hx\u2082,\n  cases h\u2082 with hy\u2081 hy\u2082,\n  rw hx\u2081 at hy\u2081,\n  have h\u2084 : r\u2081 - r\u2082 = b * (q\u2082 - q\u2081), linarith,\n  by_cases h\u2085 : q\u2081 = q\u2082,\n  { split,\n    { exact h\u2085, },\n    { rw [h\u2085.symm, show q\u2081 - q\u2081 = 0, by linarith, mul_zero] at h\u2084,\n      linarith, }, },\n  { exfalso,\n    have p\u2081 : abs (r\u2081 - r\u2082) = abs b * abs (q\u2082 - q\u2081), rw [h\u2084, abs_mul],\n    have p\u2082 : 0 < abs (q\u2082 - q\u2081),\n    { rw abs_pos,\n      intro p\u2083,\n      apply h\u2085,\n      linarith, },\n    have p\u2083 : abs b \u2264 abs (r\u2081 - r\u2082),\n    { rw p\u2081, \n      exact le_mul_of_one_le_right (abs_nonneg _) p\u2082, },\n    have p\u2084 := abs_sub_lt hx\u2082 hy\u2082,\n    linarith, },\n\n\n\n\n\n\n\n\n\n\n    ", "proof_hint": "sorry", "textAfter": "\nend\n\n\nend exlean -- hide", "height": 32, "editorText": "sorry", "lineOffset": 65, "name": "division_unique", "statement": "(h : b \u2260 0)\n(h\u2081 : a = b * q\u2081 + r\u2081 \u2227 (0 \u2264 r\u2081 \u2227 r\u2081 < abs b)) \n(h\u2082 : a = b * q\u2082 + r\u2082 \u2227 (0 \u2264 r\u2082 \u2227 r\u2082 < abs b)) : q\u2081 = q\u2082 \u2227 r\u2081 = r\u2082"}, {"type": "lean", "content": "850", "hidden": true}]}, {"name": "", "problemIndex": 8, "objects": [{"type": "lean", "content": "851", "hidden": true}, {"type": "text", "content": "852"}, {"type": "lean", "content": "853", "hidden": true}, {"type": "text", "content": "854"}, {"type": "lean", "content": "855", "hidden": false}, {"type": "text", "content": "856"}, {"type": "text", "content": "857"}, {"type": "lean", "content": "858", "hidden": false}, {"type": "lemma", "text": "859", "lean": "lemma five_nmid_sixty_two : \u00ac ((5 : \u2124) \u2223 62) :=\n", "sideBar": false, "firstProofLineNumber": 59, "lastProofLineNumber": 79, "textBefore": "import tactic.linarith divisibility.division -- hide\n\n/-\n# Divisibility\n\n## Level 16: Non-divisibility examples\n-/\n\nnamespace exlean -- hide\n\n/-\nIn any particular numerical example, it's easy to show divisibility. For example, here's a proof\nthat $7 \\mid 42$.\n-/\n\nexample : (7 : \u2124) \u2223  42 :=\nbegin\n  use 6,\n  norm_num,\nend\n\n/-\nBut how can we prove non-divisibility? How would you prove $7 \\nmid 31$?\n\nThe idea is to use the uniqueness of division result. Suppose (for a contradiction), that\n$h: 7 \\mid 31$. Decomposing $h$ gives $m : \\mathbb Z$ and $h : 31 = 7m = 7m + 0$.\n\nBut (as you may easily verify), we have $h_2 : 31 = 7 \\times 4 + 3$.\n\nUsing $h$ and $h_2$ in the uniquness of division result, we infer $m = 4$ and $0 = 3$. This\nlatter is a contradiction.\n-/\n\n/-\nHere we use the semi-colon `;` 'tactic combinator'. This is a time-saving measure that applies\nthe following tactic to each remaining goal. In our application, the tactic `tidy` is used\nto complete each of the three goals that arise from the application of `division_unique 31 7`.\n-/\n\nexample : \u00ac((7 : \u2124) \u2223 31) :=\nbegin\n  assume h : (7 : \u2124) \u2223 31,\n  cases h with m h, -- We have `m : \u2124` and `h : 31 = 7 * m`.\n  have h\u2081 : (31 : \u2124) = 7 * m + 0, linarith,\n  have h\u2082 : (31 : \u2124) = 7 * 4 + 3, norm_num,\n\n  have k\u2081 : m = 4 \u2227 (0 : \u2124) = 3,\n  { apply division_unique 31 7;\n    tidy, },\n  linarith, -- `k\u2081` gives a contradiction.\nend\n\n\n/- Lemma : no-side-bar\n5 does not divide sixty-two.\n-/\nlemma five_nmid_sixty_two : \u00ac ((5 : \u2124) \u2223 62) :=\nbegin\n", "proof": "  assume h : (5 : \u2124) \u2223 62,\n  cases h with m hm,\n  have h\u2081 : 62 = m * 5 + 0, linarith,\n  have h\u2082 : (62 : \u2124) = 12 * 5 + 2, norm_num,\n  \n  have k\u2081 : m = 12 \u2227 (0 : \u2124) = 2,\n  { apply division_unique 62 5;\n    tidy, },\n  linarith,\n\n\n\n\n\n\n\n\n\n\n\n  ", "proof_hint": "sorry", "textAfter": "\nend\n\n\n\n\nend exlean -- hide", "height": 21, "editorText": "sorry", "lineOffset": 58, "name": "five_nmid_sixty_two", "statement": "\u00ac ((5 : \u2124) \u2223 62)"}, {"type": "lean", "content": "860", "hidden": true}]}, {"name": "", "problemIndex": 13, "objects": [{"type": "lean", "content": "861", "hidden": true}, {"type": "text", "content": "862"}, {"type": "lean", "content": "863", "hidden": true}, {"type": "lean", "content": "864", "hidden": true}, {"type": "lean", "content": "865", "hidden": true}, {"type": "lean", "content": "866", "hidden": true}, {"type": "text", "content": "867"}, {"type": "lean", "content": "868", "hidden": false}, {"type": "text", "content": "869"}, {"type": "lean", "content": "870", "hidden": false}, {"type": "text", "content": "871"}, {"type": "lean", "content": "872", "hidden": false}, {"type": "text", "content": "873"}, {"type": "theorem", "text": "874", "lean": "lemma bezout1 (a b : \u2124) :\n\u2203 (d s t : \u2124), (greatest_common_divisor d a b) \u2227 (d = a * s + b * t) :=\n", "sideBar": false, "firstProofLineNumber": 71, "lastProofLineNumber": 129, "textBefore": "import tactic.linarith divisibility.basic_bezout strong_induction.well_ordering_principle -- hide\n\n/-\n# Divisibility\n\n## Level 17: B\u00e9zout's lemma (version 1)\n-/\n\nnamespace exlean -- hide\n\nopen int gcd_set -- hide\n\nvariables {a b : \u2124} {k : \u2115} -- hide\n\nopen gcd_set -- hide\n\n\n/-\nLet $a$ and $b$ be integers. B\u00e9zout's lemma asserts that there exists an integer $d$ such that\n$d$ is a greatest common divisor of $a$ and $b$ and such that $d = as + bt$, for some integers \n$s$ and $t$.\n\nIn this level, you'll prove B\u00e9zout's lemma via the well-ordering principle. If you haven't already\ndone so, please try the level on the well-ordering principle from the 'Strong Induction' world.\n\nThe proof contains several components. First, we need to consider the set\n$\\\\{y : \\mathbb N \\mid (0 < y) \\land (\\exists (s\\ t\\ : \\mathbb Z),\\, |a s + b t|  = y)\\\\}$.\n\nWe call this set `set_T a b`. You'll need to use the following lemmas concerning this set.\n* `lin_combo_of_min_element`\n* `dvd_of_min_element`\n* `set_T_nonempty`\n\nThe use of these lemmas is shown below.\n-/\n\nexample (h : min_element k (set_T a b)) : \u2203 (x y : \u2124), a * x + b * y = k :=\nbegin\n  exact lin_combo_of_min_element h,\nend\n\n/-\n\n-/\n\nexample (h : min_element k (set_T a b)) : \u2191k \u2223 a :=\nbegin\n  exact dvd_of_min_element a b k h,\nend\n\n\n/-\n\n-/\nexample (h : a \u2260 0) : (set_T a b).nonempty :=\nbegin\n  exact set_T_nonempty h,\nend\n\n/-\nOver to you!\n-/\n\n/- Theorem : no-side-bar\nB\u00e9zout's lemma (version 1). Every pair of integers $a$ and $b$ has a greatest common divisor $d$\nthat can be written as $d = as + bt$, for some integers $s$ and $t$.\n-/\nlemma bezout1 (a b : \u2124) :\n\u2203 (d s t : \u2124), (greatest_common_divisor d a b) \u2227 (d = a * s + b * t) :=\nbegin\n", "proof": "  by_cases hzeroa : a = 0,\n  { use [b, 0, 1],\n    rw hzeroa,\n    split,\n    { apply greatest_common_divisor_comm,\n      apply greatest_common_divisor_zero, },\n    norm_num, },\n  have h : (set_T a b).nonempty := set_T_nonempty hzeroa,\n  rcases well_ordering_principle h with \u27e8k, hkmin\u27e9,\n  rcases lin_combo_of_min_element hkmin with \u27e8s, t, hlin\u27e9,\n  use [k, s, t],\n  apply and.intro _ hlin.symm,\n  split,\n  { split,\n    { apply dvd_of_min_element a b k hkmin, },\n    { apply dvd_of_min_element b a k,\n      suffices h\u2083 : set_T b a = set_T a b,\n      { rwa h\u2083, },\n      have h\u2082 : \u2200 (m n : \u2124), set_T m n \u2286 set_T n m,\n      { intros m n x hmn,\n        rcases hmn with \u27e8hxpos, u, v, huv\u27e9,\n        split,\n        { exact hxpos },\n        { use [v, u],\n          rw \u2190huv,\n          congr' 1,\n          linarith, }, },\n      ext,\n      split,\n      { apply h\u2082 b a, },\n      { apply h\u2082 a b, },  },  },\n  { intros e hcd,\n    rcases lin_combo_of_min_element hkmin with \u27e8x, y, hxy\u27e9,\n    rw \u2190hxy,\n    cases hcd with hedvda hedvdb,\n    apply dvd_add,\n    { apply dvd_mul_of_dvd_left hedvda, },\n    { apply dvd_mul_of_dvd_left hedvdb, }, },\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n\n\n\nend exlean -- hide", "height": 59, "editorText": "sorry", "lineOffset": 70, "name": "bezout1", "statement": "(a b : \u2124) :\n\u2203 (d s t : \u2124), (greatest_common_divisor d a b) \u2227 (d = a * s + b * t)"}, {"type": "lean", "content": "875", "hidden": true}]}, {"name": "", "problemIndex": 12, "objects": [{"type": "lean", "content": "876", "hidden": true}, {"type": "text", "content": "877"}, {"type": "lean", "content": "878", "hidden": true}, {"type": "text", "content": "879"}, {"type": "lean", "content": "880", "hidden": true}, {"type": "lean", "content": "881", "hidden": true}, {"type": "axiom", "content": "882", "name": "neg_dvd_of_dvd", "sideBar": true}, {"type": "lean", "content": "883", "hidden": false}, {"type": "axiom", "content": "884", "name": "neg_dvd", "sideBar": true}, {"type": "lean", "content": "885", "hidden": false}, {"type": "axiom", "content": "886", "name": "dvd_neg_of_dvd", "sideBar": true}, {"type": "lean", "content": "887", "hidden": false}, {"type": "theorem", "text": "888", "lean": "lemma gcd_neg (h : greatest_common_divisor d a b) :\ngreatest_common_divisor (-d) a b :=\n", "sideBar": true, "firstProofLineNumber": 63, "lastProofLineNumber": 89, "textBefore": "import tactic.linarith divisibility.bezout -- hide\n/-\n# Divisibility\n\n## Level 18: The negative of a greatest common divisor\n-/\n\nnamespace exlean -- hide\n\n/-\nSuppose $d$ is a greatest common divisor of $a$ and $b$. Then $-d$ is also a greatest common\ndivisor of $a$ and $b$.\n\nThe following results on divisibility will be useful.\n-/\n\nopen int -- hide\n\nvariables {a b d : \u2124} -- hide\n\n/- Axiom : neg_dvd_of_dvd\n(h : d \u2223 a) : -d \u2223 a\n-/\nlemma neg_dvd_of_dvd (h : d \u2223 a) : -d \u2223 a :=\nbegin\n  cases h with m h\u2082, -- `h\u2082 : a = d * m`\n  use -m, -- `\u22a2 a = -d * -m`,\n  rw h\u2082, -- `\u22a2 d * m = -d * -m`,\n  ring, -- This follows by algebra.\nend\n\n/- Axiom : neg_dvd\n-d \u2223 a \u2194 d \u2223 a\n-/\nlemma neg_dvd : -d \u2223 a \u2194 d \u2223 a :=\nbegin\n  split,\n  { assume h : -d \u2223 a,\n    rw \u2190neg_neg d,\n    exact neg_dvd_of_dvd h, },\n  { assume h : d \u2223 a,\n    exact neg_dvd_of_dvd h, },\nend\n\n/- Axiom : dvd_neg_of_dvd\n(h : d \u2223 a) : d \u2223 -a\n-/\nlemma dvd_neg_of_dvd (h : d \u2223 a) : d \u2223 -a :=\nbegin\n  cases h with m h\u2082, -- `h\u2082 : a = d * m`\n  use -m, -- `\u22a2 - a = d * -m`,\n  rw h\u2082, -- `\u22a2 -(d * m) = d * -m`,\n  ring, -- This follows by algebra.\nend\n\n/- Theorem :\nSuppose $d$ is a greatest common divisor of $a$ and $b$. Then $-d$ is also a greatest common\ndivisor of $a$ and $b$.\n-/\nlemma gcd_neg (h : greatest_common_divisor d a b) :\ngreatest_common_divisor (-d) a b :=\nbegin\n", "proof": "  rcases h with \u27e8\u27e8ha, hb\u27e9, hmin\u27e9,\n  split,\n  { split,\n    { exact neg_dvd_of_dvd ha, },\n    { exact neg_dvd_of_dvd hb, }, },\n  { assume e : \u2124,\n    rintro \u27e8hea, heb\u27e9,\n    specialize hmin (-e),\n    apply dvd_neg_of_dvd,\n    rw \u2190neg_dvd_iff_dvd,\n    apply hmin,\n    split,\n    { exact neg_dvd_of_dvd hea, },\n    { exact neg_dvd_of_dvd heb, }, },\n\n\n\n\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n\n\n\n\n\nend exlean -- hide", "height": 27, "editorText": "sorry", "lineOffset": 62, "name": "gcd_neg", "statement": "(h : greatest_common_divisor d a b) :\ngreatest_common_divisor (-d) a b"}, {"type": "lean", "content": "889", "hidden": true}]}, {"name": "", "problemIndex": 8, "objects": [{"type": "lean", "content": "890", "hidden": true}, {"type": "text", "content": "891"}, {"type": "lean", "content": "892", "hidden": true}, {"type": "text", "content": "893"}, {"type": "lean", "content": "894", "hidden": true}, {"type": "lean", "content": "895", "hidden": true}, {"type": "text", "content": "896"}, {"type": "lean", "content": "897", "hidden": false}, {"type": "theorem", "text": "898", "lean": "lemma bezout (a b : \u2124) :\n\u2203 (d s t : \u2124), greatest_common_divisor d a b \u2227 0 \u2264 d \u2227 (d = a * s + b * t) :=\n", "sideBar": true, "firstProofLineNumber": 32, "lastProofLineNumber": 59, "textBefore": "import tactic.linarith divisibility.gcd_neg -- hide\n/-\n# Divisibility\n\n## Level 19: B\u00e9zout's lemma (version 2)\n-/\n\nnamespace exlean -- hide\n\n/-\nYou'll show that for all integers $a$ and $b$, there exists a non-negative integer $d$ such that\n$d$ is a greatest common divisor of $a$ and $b$.\n-/\n\nopen int -- hide\n\nvariables (a b : \u2124) -- hide\n\n/-\nThe lemma `nonneg_or_nonneg_neg'` will be useful.\n-/\n\nexample : 0 \u2264 a \u2228 0 \u2264 -a := nonneg_or_nonneg_neg' a\n\n/- Theorem :\nFor all integers $a$ and $b$, there exists a non-negative integer $d$ such that\n$d$ is a greatest common divisor of $a$ and $b$.\n-/\nlemma bezout (a b : \u2124) :\n\u2203 (d s t : \u2124), greatest_common_divisor d a b \u2227 0 \u2264 d \u2227 (d = a * s + b * t) :=\nbegin\n", "proof": "  rcases bezout1 a b with \u27e8e, u, v, hgcd, heq\u27e9,\n  cases (nonneg_or_nonneg_neg' e) with ha hna,\n  { use [e, u, v],\n    exact \u27e8hgcd, ha, heq\u27e9 },\n  { use [-e, -u, -v],\n    have h\u2082 : greatest_common_divisor (-e) a b, from gcd_neg hgcd,\n    exact \u27e8h\u2082, hna, by linarith\u27e9, },\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n\n\n\n\n\nend exlean -- hide", "height": 28, "editorText": "sorry", "lineOffset": 31, "name": "bezout", "statement": "(a b : \u2124) :\n\u2203 (d s t : \u2124), greatest_common_divisor d a b \u2227 0 \u2264 d \u2227 (d = a * s + b * t)"}, {"type": "lean", "content": "899", "hidden": true}]}, {"name": "", "problemIndex": 21, "objects": [{"type": "lean", "content": "900", "hidden": true}, {"type": "text", "content": "901"}, {"type": "lean", "content": "902", "hidden": true}, {"type": "text", "content": "903"}, {"type": "lean", "content": "904", "hidden": true}, {"type": "lean", "content": "905", "hidden": true}, {"type": "lean", "content": "906", "hidden": true}, {"type": "lean", "content": "907", "hidden": true}, {"type": "axiom", "content": "908", "name": "greatest_common_divisor_gcd (a b : \u2124) :", "sideBar": true}, {"type": "lean", "content": "909", "hidden": true}, {"type": "lean", "content": "910", "hidden": true}, {"type": "lean", "content": "911", "hidden": true}, {"type": "lean", "content": "912", "hidden": true}, {"type": "lean", "content": "913", "hidden": true}, {"type": "lean", "content": "914", "hidden": true}, {"type": "lean", "content": "915", "hidden": true}, {"type": "lean", "content": "916", "hidden": true}, {"type": "text", "content": "917"}, {"type": "lean", "content": "918", "hidden": false}, {"type": "lean", "content": "919", "hidden": true}, {"type": "lean", "content": "920", "hidden": true}, {"type": "theorem", "text": "921", "lean": "lemma euclid_basic (b q r : \u2124) : gcd (b * q + r) b = gcd b r:=\n", "sideBar": true, "firstProofLineNumber": 64, "lastProofLineNumber": 101, "textBefore": "import tactic.linarith divisibility.bezout2  -- hide\n\n/-\n# Divisibility\n\n## Level 20: The Euclidean algorithm - basic step\n-/\n\nnamespace exlean -- hide\n\n/-\nAs a result of B\u00e9zout's lemma, we can define a function `gcd` such that `gcd a b` is\nthe greatest common divisor of `a` and `b`.\n-/\n\nnoncomputable theory -- hide\n\n-- begin hide\nlemma gcd_exists (a b : \u2124) : \u2203 (d : \u2124), (greatest_common_divisor d a b \u2227 0 \u2264 d) :=\nbegin\n  rcases bezout a b with \u27e8d, s, t, h, h\u2082, h\u2083\u27e9,\n  exact \u27e8d, h, h\u2082\u27e9,\nend\n-- end hide\n\nnoncomputable def gcd (a b : \u2124) := classical.some (gcd_exists a b) -- hide\n\nnoncomputable def egcd (a b : \u2124) := classical.some (bezout a b) -- hide\n\n/- Axiom : greatest_common_divisor_gcd (a b : \u2124) :\n(greatest_common_divisor (gcd a b) a b) \u2227 (0 \u2264 gcd a b)\n-/\nlemma greatest_common_divisor_gcd (a b : \u2124) : (greatest_common_divisor (gcd a b) a b) \u2227 (0 \u2264 gcd a b) := -- hide\nbegin -- hide\n  apply @classical.some_spec _ (\u03bb d, (greatest_common_divisor d a b) \u2227 (0 \u2264 d)), -- hide\nend -- hide\n\nexample (a b : \u2124) : \u2203 (s t : \u2124), (greatest_common_divisor (egcd a b) a b) \u2227 (0 \u2264 egcd a b) \u2227 (egcd a b = a * s + b * t):= -- hide\nbegin -- hide\n  apply @classical.some_spec _ (\u03bb d, \u2203 s t, (greatest_common_divisor d a b) \u2227 (0 \u2264 d) \u2227 d = a * s + b * t), -- hide\nend -- hide\n\n\n/-\nThe lemma `greatest_common_divisor_gcd` asserts that `gcd a b` is a greatest common divisor of `a`\nand `b` and that `0 \u2264 gcd a b`\n-/\n\nexample (a b : \u2124) : (greatest_common_divisor (gcd a b) a b) \u2227 (0 \u2264 gcd a b)\n:= greatest_common_divisor_gcd a b\n\nopen int -- hide\n\n\nvariables {a : \u2124}  -- hide\n\n/- Theorem :\nSuppose $a$, $b$, $q$, $r$ are integers and that $a = bq + r$.\n\nThen $\\gcd(a, b) = \\gcd(b, r)$.\n-/\nlemma euclid_basic (b q r : \u2124) : gcd (b * q + r) b = gcd b r:=\nbegin\n", "proof": "  /- hint\n  set a := b * q + r with h,\n  rcases (greatest_common_divisor_gcd a b) with \u27e8\u27e8\u27e8hxa, hxb\u27e9, hxgreat\u27e9, hxnn\u27e9,\n  -/\n  set a := b * q + r with h,\n  rcases (greatest_common_divisor_gcd a b) with \u27e8\u27e8\u27e8hxa, hxb\u27e9, hxgreat\u27e9, hxnn\u27e9,\n  rcases (greatest_common_divisor_gcd b r) with \u27e8\u27e8\u27e8hyb, hyr\u27e9, hygreat\u27e9, hynn\u27e9,\n  apply dvd_antisymm,\n  { exact hxnn, },\n  { exact hynn, },\n  { specialize hygreat (gcd a b),\n    apply hygreat,\n    split,\n    { exact hxb, },\n    { rw (show r = a + (b * (-q)), by linarith),\n      apply dvd_add hxa,\n      apply dvd_mul_of_dvd_left hxb, }, },\n  { specialize hxgreat (gcd b r),\n    apply hxgreat,\n    split,\n    { rw h,\n      apply dvd_add (dvd_mul_of_dvd_left hyb _) hyr, },\n    { exact hyb, }, },\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n\nend exlean -- hide", "height": 38, "editorText": "sorry", "lineOffset": 63, "name": "euclid_basic", "statement": "(b q r : \u2124) : gcd (b * q + r) b = gcd b r"}, {"type": "lean", "content": "922", "hidden": true}]}, {"name": "", "problemIndex": 20, "objects": [{"type": "lean", "content": "923", "hidden": true}, {"type": "text", "content": "924"}, {"type": "lean", "content": "925", "hidden": true}, {"type": "text", "content": "926"}, {"type": "lean", "content": "927", "hidden": true}, {"type": "lean", "content": "928", "hidden": true}, {"type": "text", "content": "929"}, {"type": "lean", "content": "930", "hidden": false}, {"type": "text", "content": "931"}, {"type": "axiom", "content": "932", "name": "gcd_eq_greatest_common_divisor", "sideBar": true}, {"type": "lean", "content": "933", "hidden": true}, {"type": "text", "content": "934"}, {"type": "lean", "content": "935", "hidden": false}, {"type": "axiom", "content": "936", "name": "gcd_zero (a : \u2124) :", "sideBar": true}, {"type": "lean", "content": "937", "hidden": true}, {"type": "text", "content": "938"}, {"type": "lean", "content": "939", "hidden": false}, {"type": "text", "content": "940"}, {"type": "lean", "content": "941", "hidden": false}, {"type": "text", "content": "942"}, {"type": "lemma", "text": "943", "lean": "lemma three_forty_gcd_23 : gcd 340 23 = 1 :=\n", "sideBar": false, "firstProofLineNumber": 104, "lastProofLineNumber": 111, "textBefore": "import tactic.linarith divisibility.euclid_basic  -- hide\n\n/-\n# Divisibility\n\n## Level 21: The Euclidean algorithm\n-/\n\nnamespace exlean -- hide\n\n/-\nUsing the result `euclid_basic` from our previous level, we can compute greatest common divisors.\n-/\n\nopen int -- hide\n\nvariables (a b d q r x y: \u2124)  -- hide\n\n/-\nAs an example, we'll compute $\\gcd(100,7)$. As a first step, we'll use `euclid_basic` to justify\nthe assertion that $\\gcd(100,7) = \\gcd(7, 2)$. The reason for this is that \n$100 = 7 \\times 14 + 2$, so $\\gcd(7 \\times 14 + 2, 7) = \\gcd(7, 2)$, by `euclid_basic`.\n\nHere ia a proof in Lean.\n-/\n\nexample : gcd 100 7 = gcd 7 2 := euclid_basic 7 14 2\n\n/-\nIn the above proof, note that the arguments  $7$, $14$, and $2$ correspond to the calculation\n$100 = 7 \\times 14 + 2$.\n-/\n\n\n/- Axiom : gcd_eq_greatest_common_divisor\n (h\u2081 : greatest_common_divisor d a b) (h\u2082 : 0 \u2264 d) : gcd a b = d\n-/\n-- begin hide\nlemma gcd_eq_greatest_common_divisor {a b d : \u2124} (h\u2081 : greatest_common_divisor d a b) (h\u2082 : 0 \u2264 d) : gcd a b = d :=\nbegin\n  rcases (greatest_common_divisor_gcd a b) with \u27e8hxgreat, hxnn\u27e9,\n  exact uniqueness_of_greatest_common_divisor hxnn h\u2082 hxgreat h\u2081,\nend\n-- end hide\n\n/-\nIn later worlds, we'll have occasion to use the lemma `gcd_eq_greatest_common_divisor`. This states\nthat if $d$ is a greatest common divisor of $a$ and $b$ and if $d$ is non-negative, then\n$\\gcd(a,b) = d$.\n-/\n\nexample (h\u2081 : greatest_common_divisor d a b) (h\u2082 : 0 \u2264 d) : gcd a b = d :=\ngcd_eq_greatest_common_divisor h\u2081 h\u2082\n\n/- Axiom : gcd_zero (a : \u2124) : \ngcd a 0 = abs a\n-/\n-- begin hide\nlemma gcd_zero : gcd a 0 = abs (a) :=\nbegin\n  refine gcd_eq_greatest_common_divisor  _ (abs_nonneg a),\n  rcases abs_cases a with \u27e8habs, hineq\u27e9 | \u27e8habs, hineq\u27e9; rw habs,\n  { apply greatest_common_divisor_zero, },\n  { split,\n    { split,\n      { rw neg_dvd, },\n      { apply dvd_zero, }, },\n    { rintros e \u27e8ha, _\u27e9,\n      apply dvd_neg_of_dvd ha, }, },\nend\n-- end hide\n\n/-\nWe'll apply this process repeatedly until we reach $\\gcd(a, 0)$, for some integer $a$. We then\nuse the lemma `gcd_zero`.\n-/\n\nexample : gcd a 0 = abs a := gcd_zero a\n\n/-\nBelow is a Lean proof that 1 is a greatest common divisor of 7 and 100.\n-/\n\nexample : gcd 100 7 = 1 :=\nbegin\n  calc gcd 100 7\n      = gcd 7 2 : euclid_basic 7 14 2\n  ... = gcd 2 1 : euclid_basic 2  3 1\n  ... = gcd 1 0 : euclid_basic 1  2 0\n  ... = 1       : gcd_zero 1,\nend\n\n/-\n### Task\n\nAdapt the proof above to show that $\\gcd(340, 23) = 1$.\n-/\n\n/- Lemma : no-side-bar\n$\\gcd(340, 23) = 1$\n-/\nlemma three_forty_gcd_23 : gcd 340 23 = 1 :=\nbegin\n", "proof": "  calc gcd 340 23\n      = gcd 23 18 : euclid_basic 23 14 18\n  ... = gcd 18  5 : euclid_basic 18  1  5\n  ... = gcd  5  3 : euclid_basic  5  3  3\n  ... = gcd  3  2 : euclid_basic  3  1  2\n  ... = gcd  2  1 : euclid_basic  2  1  1\n  ... = gcd  1  0 : euclid_basic  1  2  0\n  ... = 1         : gcd_zero 1,", "proof_hint": "sorry", "textAfter": "\nend\n\n\nend exlean -- hide", "height": 8, "editorText": "sorry", "lineOffset": 103, "name": "three_forty_gcd_23", "statement": "gcd 340 23 = 1"}, {"type": "lean", "content": "944", "hidden": true}]}], "parents": [5]}, {"name": "945", "levels": [{"name": "", "problemIndex": 13, "objects": [{"type": "lean", "content": "946", "hidden": true}, {"type": "text", "content": "947"}, {"type": "lean", "content": "948", "hidden": true}, {"type": "lean", "content": "949", "hidden": true}, {"type": "lean", "content": "950", "hidden": true}, {"type": "text", "content": "951"}, {"type": "lean", "content": "952", "hidden": true}, {"type": "axiom", "content": "953", "name": "mod_def (x y : \u2124) :", "sideBar": true}, {"type": "lean", "content": "954", "hidden": true}, {"type": "text", "content": "955"}, {"type": "lean", "content": "956", "hidden": false}, {"type": "text", "content": "957"}, {"type": "text", "content": "958"}, {"type": "theorem", "text": "959", "lean": "theorem sixty_cong_37_mod_11 : 60 \u2261 38 [MOD 11] :=\n", "sideBar": false, "firstProofLineNumber": 72, "lastProofLineNumber": 77, "textBefore": "import divisibility.euclidean_algorithm -- hide\n\n/-\n#  Congruences\n\n## Level 1: The definition of congruence\n\nThe notation `a \u2261 b [MOD n]`, read '`a` is congruent to `b` modulo `n`' means `n \u2223 b - a`. \n\nType `\u2261` as `\\==`.\n-/\n\n\nnamespace exlean -- hide\n\ndef modeq (n a b : \u2124) := n \u2223 b - a  -- hide\n\nnotation a ` \u2261 `:50 b ` [MOD `:50 n `]`:0 := modeq n a b -- hide\n\n/-\nIf you forget this definition or ever want to replace `a \u2261 b [MOD n]` with the definition in a proof, use\nthe result `mod_def`.\n-/\n\nvariables {a b n : \u2124} -- hide\n\n/- Axiom : mod_def (x y : \u2124) :\na \u2261 b [MOD n] \u2194 n \u2223 b - a\n-/\nlemma mod_def : a \u2261 b [MOD n] \u2194 n \u2223 b - a := by refl -- hide\n\n/-\nFor example, we will prove that `45 \u2261 17 [MOD 7]`. The first two lines of the proof are\nunnecessary but may be helpful in understanding how to apply definitions.\n\nIn the first line, we rewrite `\u22a2 45 \u2261 17 [MOD 7]` using the definition of congruence to give\n`\u22a2 7 \u2223 45 - 17`.\n\nUsing the definition of divisibility, this becomes `\u22a2 \u2203 (m : \u2124), 45 - 17 = 7 * m`.\n\nTo prove this existentially-quantified statement, we take `m` to be `4`. The result follows by\narithmetic.\n-/\n\nexample : 17 \u2261 45 [MOD 7] :=\nbegin\n  rw mod_def, -- `\u22a2 7 \u2223 45 - 17`\n  rw dvd_def, -- `\u22a2 \u2203 (m : \u2124), 45 - 17 = 7 * m`\n  use 4,      -- `\u22a2 45 - 17 = 7 * 4`\n  norm_num,   -- This holds by arithmetic.\nend\n\n/-\nIf you were to write the proof 'by hand', you might write the following:\n\n> By definition, we must prove `7 \u2223 45 - 17`. That is, that `45 - 17 = 7 * m`, for some `m`.\n> This holds if one takes `m` to be `4`.\n-/\n\n/-\n### Tasks\n* By making a minor variation to the proof above, show that `60 \u2261 38 [MOD 11] `.\n\n* Write the same proof by hand.\n-/\n\n/- Theorem : no-side-bar\n`60 \u2261 38 [MOD 11]` \n-/\ntheorem sixty_cong_37_mod_11 : 60 \u2261 38 [MOD 11] :=\nbegin\n", "proof": "  use (-2),\n  norm_num,\n\n\n\n  ", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 6, "editorText": "sorry", "lineOffset": 71, "name": "sixty_cong_37_mod_11", "statement": "60 \u2261 38 [MOD 11]"}, {"type": "lean", "content": "960", "hidden": true}]}, {"name": "", "problemIndex": 7, "objects": [{"type": "lean", "content": "961", "hidden": true}, {"type": "text", "content": "962"}, {"type": "lean", "content": "963", "hidden": true}, {"type": "text", "content": "964"}, {"type": "lean", "content": "965", "hidden": true}, {"type": "text", "content": "966"}, {"type": "lean", "content": "967", "hidden": false}, {"type": "lemma", "text": "968", "lean": "lemma reduction_of_500_mod_63 :\n\u2203 a, 500 \u2261 a [MOD 63] \u2227 (0 \u2264 a) \u2227 (a < abs (63)) :=\n", "sideBar": true, "firstProofLineNumber": 46, "lastProofLineNumber": 55, "textBefore": "import congruences.mod_def -- hide\n\n/-\n#  Congruences\n\n## Level 2: Reduction of an integer modulo $n$\n-/\n\nnamespace exlean -- hide\n\n/-\nLet $x$ and $n$ be integers with $n \\ne 0$. One can find an integer $a$ in the range $0 \\le a < |n|$\nsuch that $x \\equiv a \\pmod n$.\n\nThis is sometimes called _reduction_ of $x$ modulo $n$.\n-/\n\nvariables {x a n : \u2124} -- hide\n\n/-\nWe'll find a number $a$ such that $321 \\equiv a \\pmod{12}$ and such that $0 \\le a < |12|$\n\nFor $a$, I'll take the remainder on dividing $321$ by $12$. Note that\n$321 = q \\times 12 + r$, where $q = 26$ and $r = 9$.\n-/\n\nexample : \u2203 (a : \u2124), 321 \u2261 a [MOD 12] \u2227 (0 \u2264 a) \u2227 (a < abs (12)) :=\nbegin\n  use 9,  -- `\u22a2 321 \u2261 9 [MOD 12] \u2227 (0 \u2264 9) \u2227 (9 < abs(12))`\n  split,\n  { rw [mod_def, dvd_def], -- `\u22a2 \u2203 m, 9 - 321 = 12 * m`\n    use -26, -- `9 - 321 = 12 * (-26)`\n    norm_num, },\n  tidy, -- `tidy` proves `(0 \u2264 9) \u2227 (9 < abs(12))`\n\n\nend\n\n/- Lemma :\nThere is an integer $a$ such that $500 \\equiv a \\pmod{63}$ with\n$0 \\le a < |63|$.\n-/\nlemma reduction_of_500_mod_63 :\n\u2203 a, 500 \u2261 a [MOD 63] \u2227 (0 \u2264 a) \u2227 (a < abs (63)) :=\nbegin\n", "proof": "  use 59,\n  split,\n  { use -7,\n    norm_num, },\n  tidy,\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n\nend exlean -- hide", "height": 10, "editorText": "sorry", "lineOffset": 45, "name": "reduction_of_500_mod_63", "statement": "\u2203 a, 500 \u2261 a [MOD 63] \u2227 (0 \u2264 a) \u2227 (a < abs (63))"}, {"type": "lean", "content": "969", "hidden": true}]}, {"name": "", "problemIndex": 10, "objects": [{"type": "lean", "content": "970", "hidden": true}, {"type": "text", "content": "971"}, {"type": "lean", "content": "972", "hidden": true}, {"type": "text", "content": "973"}, {"type": "lean", "content": "974", "hidden": true}, {"type": "axiom", "content": "975", "name": "mod_refl {a : \u2124} :", "sideBar": true}, {"type": "lean", "content": "976", "hidden": false}, {"type": "text", "content": "977"}, {"type": "text", "content": "978"}, {"type": "hint", "content": "979", "title": "980"}, {"type": "theorem", "text": "981", "lean": "lemma mod_symm (h : a \u2261 b [MOD n]) : b \u2261 a [MOD n] :=\n", "sideBar": true, "firstProofLineNumber": 59, "lastProofLineNumber": 63, "textBefore": "import congruences.reduction1 -- hide\n\n/-\n#  Congruences\n\n## Level 3: Reflexivity and symmetry of mod\n-/\n\n\nnamespace exlean -- hide\n\n\n/-\nAs a first proper theorem on congruences, we'll show that `\u2261` is a reflexive relation.\n-/\n\nvariables {a b n : \u2124} -- hide\n\n/- Axiom : mod_refl {a : \u2124} :\na \u2261 a [MOD n]\n-/\nlemma mod_refl : a \u2261 a [MOD n] :=\nbegin\n  rw mod_def, -- `\u22a2 n \u2223 a - a`\n  rw dvd_def, -- `\u22a2 \u2203 (m : \u2124), a - a = n * m`\n  use 0,      -- `\u22a2 a - a = n * 0`\n  linarith,   -- Follows by algebra.\n\nend\n\n/-\nA handwritten proof might be:\n\n> By definition of congruence, it suffices to prove $n \\mid a - a$.\n> By definition of divisibility, it suffices to prove $a - a = nm$, for some integer $m$.\n> Take $m = 0$. Then $a - a = n \\times 0$ holds by algebra.\n-/\n\n/-\n### Tasks\n* Show that `\u2261` is a symmetric relation.\n\n* Write the same proof by hand.\n-/\n\n/- Hint : Decomposing a congruence\nIn the problem below, you are _given_ a congruence `h : a \u2261 b [MOD n]`. To extract information\nfrom this statement, use the `cases` tactic. \n\nFor example, write `cases h with m h\u2082` to produce an integer `m` and the hypothesis\n`h\u2082 : b - a = n * m`.\n-/\n\n/- Theorem :\nThe relation `\u2261` is symmetric.\n-/\nlemma mod_symm (h : a \u2261 b [MOD n]) : b \u2261 a [MOD n] :=\nbegin\n", "proof": "  cases h with m h\u2082,\n  use -m,\n  linarith,\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 5, "editorText": "sorry", "lineOffset": 58, "name": "mod_symm", "statement": "(h : a \u2261 b [MOD n]) : b \u2261 a [MOD n]"}, {"type": "lean", "content": "982", "hidden": true}]}, {"name": "", "problemIndex": 12, "objects": [{"type": "lean", "content": "983", "hidden": true}, {"type": "text", "content": "984"}, {"type": "lean", "content": "985", "hidden": true}, {"type": "lean", "content": "986", "hidden": true}, {"type": "text", "content": "987"}, {"type": "text", "content": "988"}, {"type": "lean", "content": "989", "hidden": false}, {"type": "text", "content": "990"}, {"type": "lean", "content": "991", "hidden": false}, {"type": "text", "content": "992"}, {"type": "hint", "content": "993", "title": "994"}, {"type": "hint", "content": "995", "title": "996"}, {"type": "theorem", "text": "997", "lean": "lemma mod_trans (h\u2081 : a \u2261 b [MOD n]) (h\u2082 : b \u2261 c [MOD n]) :\na \u2261 c [MOD n] :=\n", "sideBar": true, "firstProofLineNumber": 95, "lastProofLineNumber": 101, "textBefore": "import congruences.mod_refl_symm -- hide\n\n/-\n#  Congruences\n\n## Level 4: Transitivity of mod\n-/\n\n\nnamespace exlean -- hide\n\n\nvariables {a b c d n : \u2124} -- hide\n\n/-\nYour next task is to prove that `\u2261` is transitive. That is, assuming `a \u2261 b [MOD n]` and\n`b \u2261 c [MOD n]` to prove `a \u2261 c [MOD n]`. The clever way to do this is to invoke an appropriate\nresult you've already seen concerning divisibility. \n-/\n\n/-\nAs an example of the kind of technique you'll need, we'll give a proof that $a \\mid b + 2c + d$\ngiven $h_1 : a \\mid b + c$ and $h_2 : a \\mid c + d$.\n\nFirst we note $h_3 : b + 2c + d = (b + c) + (c + d)$. Rewriting with $h_3$, the goal becomes\n$\\vdash a \\mid (b + c) + (c + d)$. Applying the 'addition of divisibility' result, it suffices\nto prove two new goals (1) $a \\mid b + c$ and (2) $a \\mid c + d$. The first of these goals follows\nfrom $h_1$ and the second from $h_2$.\n\nNote the use of the `apply` tactic to construct new goals from the conditions of the `dvd_add`\ntheorem.\n-/\n\nexample (h\u2081 : a \u2223 b + c) (h\u2082 : a \u2223 c + d) : a \u2223 b + 2 * c + d :=\nbegin\n  have h\u2083 : b + 2 * c + d = (b + c) + (c + d), linarith,\n  rw h\u2083,\n  apply dvd_add,\n  { exact h\u2081 },\n  { exact h\u2082 },\nend\n\n/-\nWe can prove the same result more briefly by (a) dispensing with additional hypothesis `h\u2083` and\nrewriting 'in place' via 'show' and (b) giving `apply` the desired conditions without the need\nto introduce additional goals.\n-/\n\nexample (h\u2081 : a \u2223 b + c) (h\u2082 : a \u2223 c + d) : a \u2223 b + 2 * c + d :=\nbegin\n  rw (show b + 2 * c + d = (b + c) + (c + d), by linarith),\n  apply dvd_add h\u2081 h\u2082,\nend\n\n\n\n/-\n### Tasks\n* Show that `\u2261` is a transitive relation.\n\n* Write the same proof by hand.\n-/\n\n/- Hint : Starting the problem\nStart by rewriting the target and hypotheses with the definition of congruence. Do this with\n`rw mod_def at *`.\n-/\n\n/- Hint : A clever rewriting\nIf you took the hint above, the target will be `\u22a2 n \u2223 c - a`. A clever idea is to write\n`c - a` as `(c - b) + (b - a)`.\n\nOne way to do this is via:\n```\nhave h\u2083 : c - a = (c - b) + (b - a), by linarith,\nrw h\u2083,\n```\n\nAlternatively,\n```\nrw (show c - a = (c - b) + (b - a), by linarith),\n```\nThe latter approach obviates the need for an additional hypothesis.\n\nAfter rewriting (by either method), you can use one of the divisibility lemmas (see the sidebar)\nto finish the proof.\n-/\n\n/- Theorem :\nThe relation `\u2261` is transitive.\n-/\nlemma mod_trans (h\u2081 : a \u2261 b [MOD n]) (h\u2082 : b \u2261 c [MOD n]) :\na \u2261 c [MOD n] :=\nbegin\n", "proof": "  rw mod_def at *,\n  rw (show c - a = (c - b) + (b - a), by linarith),\n  apply dvd_add h\u2082 h\u2081,\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 7, "editorText": "sorry", "lineOffset": 94, "name": "mod_trans", "statement": "(h\u2081 : a \u2261 b [MOD n]) (h\u2082 : b \u2261 c [MOD n]) :\na \u2261 c [MOD n]"}, {"type": "lean", "content": "998", "hidden": true}]}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "999", "hidden": true}, {"type": "text", "content": "1000"}, {"type": "lean", "content": "1001", "hidden": true}, {"type": "lean", "content": "1002", "hidden": true}, {"type": "text", "content": "1003"}, {"type": "lemma", "text": "1004", "lean": "lemma modeq_zero_iff' : 0 \u2261 a [MOD n] \u2194 n \u2223 a :=\n", "sideBar": true, "firstProofLineNumber": 29, "lastProofLineNumber": 39, "textBefore": "import congruences.mod_trans -- hide\n\n/-\n#  Congruences\n\n## Level 5: A condition for an integer to be congruent to zero\n-/\n\n\nnamespace exlean -- hide\n\n\nvariables {a n : \u2124} -- hide\n\n/-\n### Tasks\n* Let $a$ and $n$ be integers. Prove, by hand, that $0 \\equiv a \\pmod n$ if and only if $n \\mid a$.\n\n\n* Write the same proof in Lean.\n-/\n\n\n/- Lemma :\nLet $a$ be an integer. Then $0 \\equiv a \\pmod n \\iff n \\mid a$.\n-/\nlemma modeq_zero_iff' : 0 \u2261 a [MOD n] \u2194 n \u2223 a :=\nbegin\n", "proof": "  rw [mod_def, sub_zero],\n\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 11, "editorText": "sorry", "lineOffset": 28, "name": "modeq_zero_iff'", "statement": "0 \u2261 a [MOD n] \u2194 n \u2223 a"}, {"type": "lean", "content": "1005", "hidden": true}]}, {"name": "", "problemIndex": 7, "objects": [{"type": "lean", "content": "1006", "hidden": true}, {"type": "text", "content": "1007"}, {"type": "lean", "content": "1008", "hidden": true}, {"type": "lean", "content": "1009", "hidden": true}, {"type": "text", "content": "1010"}, {"type": "hint", "content": "1011", "title": "1012"}, {"type": "hint", "content": "1013", "title": "1014"}, {"type": "theorem", "text": "1015", "lean": "lemma mod_mul_right (h : a \u2261 b [MOD n]) : a * c \u2261 b * c [MOD n] :=\n", "sideBar": true, "firstProofLineNumber": 47, "lastProofLineNumber": 56, "textBefore": "import congruences.modeq_zero_iff   -- hide\n\n/-\n#  Congruences\n\n## Level 6: Multiplying a congruence on the right\n-/\n\n\nnamespace exlean -- hide\n\n\nvariables {a b c n : \u2124} -- hide\n\n/-\n### Tasks\n* Given `a \u2261 b [MOD n]`, show `a * c \u2261 b * c [MOD n]`. As in the previous level, you can prove\nthis using an appropriate divisibilty lemma.\n\n* Write the same proof by hand.\n-/\n\n/- Hint : Starting the problem\nStart by rewriting the target and hypotheses with the definition of congruence. Do this with\n`rw mod_def at *`.\n-/\n\n/- Hint : Factoring\nThe expression `b * c - a * c` in the target can be factored to `(b - a) * c` using the technique\nshown in the previous level, namely,\n```\nrw (show b * c - a * c = (b - a) * c, by linarith),\n```\n\nIn fact, this factoring result is built in to Lean's mathematical library as the lemma `sub_mul`.\nSo you could, alternatively, use `rw \u2190sub_mul`.\n\nAfter rewriting (by either method), you can use one of the divisibility lemmas (see the sidebar)\nto finish the proof.\n-/\n\n/- Theorem :\nGiven `a \u2261 b [MOD n]`, the congruence `a * c \u2261 b * c [MOD n]` follows.\n-/\nlemma mod_mul_right (h : a \u2261 b [MOD n]) : a * c \u2261 b * c [MOD n] :=\nbegin\n", "proof": "  rw mod_def at *,\n  rw \u2190sub_mul,\n  apply dvd_mul_of_dvd_left h,\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 10, "editorText": "sorry", "lineOffset": 46, "name": "mod_mul_right", "statement": "(h : a \u2261 b [MOD n]) : a * c \u2261 b * c [MOD n]"}, {"type": "lean", "content": "1016", "hidden": true}]}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "1017", "hidden": true}, {"type": "text", "content": "1018"}, {"type": "lean", "content": "1019", "hidden": true}, {"type": "lean", "content": "1020", "hidden": true}, {"type": "text", "content": "1021"}, {"type": "theorem", "text": "1022", "lean": "lemma mod_add (h\u2081 : a \u2261 b [MOD n]) (h\u2082 : c \u2261 d [MOD n]) :\na + c \u2261 b + d [MOD n] :=\n", "sideBar": true, "firstProofLineNumber": 27, "lastProofLineNumber": 37, "textBefore": "import congruences.mod_mul_right -- hide\n\n/-\n#  Congruences\n\n## Level 7: Adding congruences\n-/\n\nnamespace exlean -- hide\n\nvariables {a b c d n : \u2124} -- hide\n\n/-\n### Tasks\n* Given `a \u2261 b [MOD n]` and `c \u2261 d [MOD n]`, show `a + c \u2261 b + d [MOD n]`. As before, you can prove\nthis using an appropriate divisibilty lemma.\n\n* Write the same proof by hand.\n-/\n\n/- Theorem :\nGiven `a \u2261 b [MOD n]` and `c \u2261 d [MOD n]`, the congruence `a + c \u2261 b + d [MOD n]` follows.\n-/\nlemma mod_add (h\u2081 : a \u2261 b [MOD n]) (h\u2082 : c \u2261 d [MOD n]) :\na + c \u2261 b + d [MOD n] :=\nbegin\n", "proof": "  rw mod_def at *,\n  rw (show b + d - (a + c) = (b - a) + (d - c), by linarith),\n  apply dvd_add h\u2081 h\u2082,\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 11, "editorText": "sorry", "lineOffset": 26, "name": "mod_add", "statement": "(h\u2081 : a \u2261 b [MOD n]) (h\u2082 : c \u2261 d [MOD n]) :\na + c \u2261 b + d [MOD n]"}, {"type": "lean", "content": "1023", "hidden": true}]}, {"name": "", "problemIndex": 7, "objects": [{"type": "lean", "content": "1024", "hidden": true}, {"type": "text", "content": "1025"}, {"type": "lean", "content": "1026", "hidden": true}, {"type": "lean", "content": "1027", "hidden": true}, {"type": "text", "content": "1028"}, {"type": "hint", "content": "1029", "title": "1030"}, {"type": "hint", "content": "1031", "title": "1032"}, {"type": "theorem", "text": "1033", "lean": "lemma mod_mul (h\u2081 : a \u2261 b [MOD n]) (h\u2082 : c \u2261 d [MOD n]) :\na * c \u2261 b * d [MOD n] :=\n", "sideBar": true, "firstProofLineNumber": 41, "lastProofLineNumber": 53, "textBefore": "import congruences.mod_add -- hide\n\n/-\n#  Congruences\n\n## Level 8: Multiplying congruences\n-/\n\nnamespace exlean -- hide\n\nvariables {a b c d n : \u2124} -- hide\n\n/-\n### Tasks\n* Given `a \u2261 b [MOD n]` and `c \u2261 d [MOD n]`, show `a * c \u2261 b * d [MOD n]`.\n\n* Write the same proof by hand.\n\nThe nicest way to do this is by using two different divisibility results.\n-/\n\n/- Hint: Starting the proof\nAs before, start by converging the congruences to divisibility statements using `rw mod_def at *`.\n-/\n\n/- Hint: A cunning rewrite\nYour next task is to rewrite the goal from `n \u2223 b * d - a * c` to something of the form\n`n \u2223 p + q`, for appropriate `p` and `q`. You can then use `apply dvd_add`.\n\nYou should then `apply` another of the divisibility results to each of the\nresulting goals.\n-/\n\n\n/- Theorem :\nGiven `a \u2261 b [MOD n]` and `c \u2261 d [MOD n]`, the congruence `a * c \u2261 b * d [MOD n]` follows.\n-/\nlemma mod_mul (h\u2081 : a \u2261 b [MOD n]) (h\u2082 : c \u2261 d [MOD n]) :\na * c \u2261 b * d [MOD n] :=\nbegin\n", "proof": "  rw mod_def at *,\n  rw (show b * d - (a * c) = (b - a) * d + (d - c) * a, by linarith),\n  apply dvd_add,\n  { apply dvd_mul_of_dvd_left h\u2081, },\n  { apply dvd_mul_of_dvd_left h\u2082, },\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 13, "editorText": "sorry", "lineOffset": 40, "name": "mod_mul", "statement": "(h\u2081 : a \u2261 b [MOD n]) (h\u2082 : c \u2261 d [MOD n]) :\na * c \u2261 b * d [MOD n]"}, {"type": "lean", "content": "1034", "hidden": true}]}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "1035", "hidden": true}, {"type": "text", "content": "1036"}, {"type": "lean", "content": "1037", "hidden": true}, {"type": "lean", "content": "1038", "hidden": true}, {"type": "text", "content": "1039"}, {"type": "text", "content": "1040"}, {"type": "lemma", "text": "1041", "lean": "lemma modeq_of_dvd_of_modeq (h\u2081 : m \u2223 n) (h\u2082 : a \u2261 b [MOD n]) : a \u2261 b [MOD m] :=\n", "sideBar": false, "firstProofLineNumber": 36, "lastProofLineNumber": 47, "textBefore": "import congruences.mod_mul  -- hide\n\n/-\n#  Congruences\n\n## Level 9: Reduction of congruences\n-/\n\nnamespace exlean -- hide\n\nvariables {n m a b : \u2124} -- hide\n\n/-\nWe've seen the idea of reducing an integer $x$ modulo $n$. This means finding an integer $a$\nsuch that $x \\equiv a \\pmod n$ with $0 \\le a < |n|$.\n\nThe word 'reduction' has another meaning in the study of congruences.\n\nSuppose $a$, $b$, $n$ and $m$ are integers with $m \\mid n$. Suppose $a \\equiv b \\pmod n$.\nIt follows that $a \\equiv b \\pmod m$. This is called the _reduction of the congruence_\n$a \\equiv \\pmod n$, modulo $m$.\n-/\n\n/-\n### Task\nProve the reduction result mentioned above. You should be able to do this in one line by employing\nan appropriate result from Divisibility World.\n\n-/\n\n/- Lemma : no-side-bar\nGiven $m \\mid n$ and $a \\equiv b \\pmod n$, the congruence $a \\equiv b \\pmod m$ follows.\n-/\nlemma modeq_of_dvd_of_modeq (h\u2081 : m \u2223 n) (h\u2082 : a \u2261 b [MOD n]) : a \u2261 b [MOD m] :=\nbegin\n", "proof": "  exact dvd_trans h\u2081 h\u2082,\n\n\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 12, "editorText": "sorry", "lineOffset": 35, "name": "modeq_of_dvd_of_modeq", "statement": "(h\u2081 : m \u2223 n) (h\u2082 : a \u2261 b [MOD n]) : a \u2261 b [MOD m]"}, {"type": "lean", "content": "1042", "hidden": true}]}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "1043", "hidden": true}, {"type": "text", "content": "1044"}, {"type": "lean", "content": "1045", "hidden": true}, {"type": "text", "content": "1046"}, {"type": "lean", "content": "1047", "hidden": true}, {"type": "theorem", "text": "1048", "lean": "lemma reduction (h : n \u2260 0) : \u2203 (a : \u2124), (x \u2261 a [MOD n]) \u2227 (0 \u2264 a) \u2227 (a < abs n) :=\n", "sideBar": true, "firstProofLineNumber": 26, "lastProofLineNumber": 46, "textBefore": "import congruences.mod_reduction -- hide\n/-\n#  Congruences\n\n## Level 10: Reduction of integers in general\n-/\n\nnamespace exlean -- hide\n\n/-\nWe now return to the other meaning of reduction. You will show that for all integers $x$ and $n$\nwith $n \\ne 0$, there exists an integer $a$ in the range $0 \\le a < |n|$ such that\n$x \\equiv a \\pmod n$.\n\nThe statement above has some similarity with the `division` lemma, as seen in Divisibility World.\n-/\n\nvariables {x a n : \u2124} -- hide\n\n/- Theorem :\nFor every non-zero integer $n$, there exists an integer $a$ such that $x \\equiv a \\pmod n$ with\n$0 \\le a < |n|$.\n-/\nlemma reduction (h : n \u2260 0) : \u2203 (a : \u2124), (x \u2261 a [MOD n]) \u2227 (0 \u2264 a) \u2227 (a < abs n) :=\nbegin\n", "proof": "  rcases (division x n h) with \u27e8m, r, hn, hrange\u27e9,\n  use r,\n  split,\n  { rw hn,\n    have h\u2082 : n * m + r \u2261 0 + r [MOD n],\n    { apply mod_add,\n      { use -m,\n        linarith, },\n      { apply mod_refl, }, },\n    rwa zero_add at h\u2082, },\n  exact hrange,\n\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 21, "editorText": "sorry", "lineOffset": 25, "name": "reduction", "statement": "(h : n \u2260 0) : \u2203 (a : \u2124), (x \u2261 a [MOD n]) \u2227 (0 \u2264 a) \u2227 (a < abs n)"}, {"type": "lean", "content": "1049", "hidden": true}]}, {"name": "", "problemIndex": 7, "objects": [{"type": "lean", "content": "1050", "hidden": true}, {"type": "text", "content": "1051"}, {"type": "lean", "content": "1052", "hidden": true}, {"type": "lean", "content": "1053", "hidden": true}, {"type": "text", "content": "1054"}, {"type": "text", "content": "1055"}, {"type": "hint", "content": "1056", "title": "1057"}, {"type": "lemma", "text": "1058", "lean": "lemma dvd_of_modeq_mul_of_common_divisor (h\u2081 : a * x \u2261 b [MOD n]) (h\u2082 : common_divisor d a n) : \nd \u2223 b :=\n", "sideBar": true, "firstProofLineNumber": 35, "lastProofLineNumber": 54, "textBefore": "import congruences.reduction2  -- hide\n\n/-\n#  Congruences\n\n## Level 11: A necessary condition for solving a linear congruence\n-/\n\nnamespace exlean -- hide\n\nvariables {n d a b x : \u2124} -- hide\n\n/-\nSuppose $d$ is a common divisor of integers $a$ and $n$. The linear congruence\n$a x \\equiv b \\pmod n$ has a solution only if $d \\mid b$.\n-/\n\n/-\n### Task\nProve the reduction result mentioned above, first by hand and then in Lean.\n-/\n\n/- Hint : A useful result\nRecall that if $d \\mid n$, and $s \\equiv t \\pmod n$, then $s \\equiv t \\pmod d$. We called this result\n`modeq_of_dvd_of_modeq`.\n-/\n\n/- Lemma : \nSuppose $d$ is a common divisor of integers $a$ and $n$. The linear congruence\n$a x \\equiv b \\pmod n$ has a solution only if $d \\mid b$.\n-/\nlemma dvd_of_modeq_mul_of_common_divisor (h\u2081 : a * x \u2261 b [MOD n]) (h\u2082 : common_divisor d a n) : \nd \u2223 b :=\nbegin\n", "proof": "  rcases h\u2082 with \u27e8hda, hdn\u27e9,\n  have h\u2083 : a * x \u2261 b [MOD d], from modeq_of_dvd_of_modeq hdn h\u2081,\n  rw \u2190modeq_zero_iff',\n  have h\u2084 : 0 \u2261 a * x [MOD d],\n  { rw modeq_zero_iff', \n    apply dvd_mul_of_dvd_left hda, },\n  apply mod_trans h\u2084 h\u2083,\n\n\n\n\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 20, "editorText": "sorry", "lineOffset": 34, "name": "dvd_of_modeq_mul_of_common_divisor", "statement": "(h\u2081 : a * x \u2261 b [MOD n]) (h\u2082 : common_divisor d a n) : \nd \u2223 b"}, {"type": "lean", "content": "1059", "hidden": true}]}, {"name": "", "problemIndex": 8, "objects": [{"type": "lean", "content": "1060", "hidden": true}, {"type": "text", "content": "1061"}, {"type": "lean", "content": "1062", "hidden": true}, {"type": "lean", "content": "1063", "hidden": true}, {"type": "text", "content": "1064"}, {"type": "lean", "content": "1065", "hidden": false}, {"type": "text", "content": "1066"}, {"type": "text", "content": "1067"}, {"type": "lemma", "text": "1068", "lean": "lemma no_soln_12_x_cong_10_mod_60 : \u00ac (12 * x \u2261 10 [MOD 60]) :=\n", "sideBar": false, "firstProofLineNumber": 48, "lastProofLineNumber": 81, "textBefore": "import congruences.condition_for_linear_congruence -- hide\n\n/-\n#  Congruences\n\n## Level 12: A linear congruence without a solution\n-/\n\nnamespace exlean -- hide\n\nvariables {x : \u2124} -- hide\n\n/-\nIt's easy to check that a given value $x$ _is_ a solution of a linear congruence.\n-/\n\nexample (h : x = 5) : 7 * x \u2261 3 [MOD 4] :=\nbegin\n  rw h, -- `\u22a2 7 * 5 \u2261 3 [MOD 4]`\n  use -8, -- `\u22a2 3 - 7 * 5 = 4 * -8`\n  norm_num,\nend\n\n\n/-\nIt's significantly more difficuult to show that a congruence doesn't have a solution.\n\nIn the previous level, you showed that the congruence $ax \\equiv \\pmod n$ has a solution only if\n$d \\mid b$, where $d$ is a common divisor of $a$ and $n$.\n\nIn this level, you'll use this to show that a certain linear congruence has no solutions.\nThis boils down to showing that a number doesn't divide another number, a topic we covered in\nDivision World.\n-/\n\n/-\n### Task\n\nUsing the ideas above and any other lemmas you've seen, show that\nthere is no $x$ for which  $12 x \\equiv 10 \\pmod {60}$.\n-/\n\n/- Lemma : no-side-bar\nThe congruence $12 x \\equiv 10 \\pmod {60}$ has no solution for $x$.\n-/\nlemma no_soln_12_x_cong_10_mod_60 : \u00ac (12 * x \u2261 10 [MOD 60]) :=\nbegin\n", "proof": "  assume h : 12 * x \u2261 10 [MOD 60],\n  have h\u2082 : common_divisor 12 12 60,\n  { split; norm_num, },\n  have h\u2083 : 12 * x \u2261 10 [MOD 12], from modeq_of_dvd_of_modeq h\u2082.2 h,\n  have h\u2084 : (12 : \u2124) \u2223 10,\n  { rw \u2190modeq_zero_iff',\n    apply mod_trans,\n    swap,\n    exact h\u2083,\n    use x,\n    linarith, },\n  cases h\u2084 with k h\u2084,\n  suffices h\u2085 : (k = 0) \u2227 ((0 : \u2124) = 10), linarith,\n  apply division_unique 10 12;\n  tidy,\n\n\n/-   assume h : 12 * x \u2261 10 [MOD 60],\n  cases h with m h,\n  have h\u2081 : 10 = 60 * m + 12 * x, linarith,\n  have h\u2082 : (12 : \u2124) \u2223 10,\n  { rw h\u2081,\n    apply dvd_mul_add_mul;\n    norm_num, },\n  cases h\u2082 with k h\u2082,\n  suffices h\u2085 : (k = 0) \u2227 ((0 : \u2124) = 10), linarith, \n  apply division_unique 10 12;\n  tidy, -/\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 34, "editorText": "sorry", "lineOffset": 47, "name": "no_soln_12_x_cong_10_mod_60", "statement": "\u00ac (12 * x \u2261 10 [MOD 60])"}, {"type": "lean", "content": "1069", "hidden": true}]}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "1070", "hidden": true}, {"type": "text", "content": "1071"}, {"type": "lean", "content": "1072", "hidden": true}, {"type": "lean", "content": "1073", "hidden": true}, {"type": "text", "content": "1074"}, {"type": "text", "content": "1075"}, {"type": "lemma", "text": "1076", "lean": "lemma modeq_mul_eq_one_of_coprime (h : greatest_common_divisor 1 a n) : \u2203 (x : \u2124), a * x \u2261 1 [MOD n] :=\n", "sideBar": true, "firstProofLineNumber": 34, "lastProofLineNumber": 49, "textBefore": "import congruences.linear_congruences_no_soln-- hide\n\n/-\n#  Congruences\n\n## Level 13: Solving a linear congruence\n-/\n\nnamespace exlean -- hide\n\nvariables {a n x : \u2124} -- hide\n\n/-\nWe've seen a necessary condition for a linear congruence to have a solution. You'll now prove a\nsufficient condition.\n\nSpecifically, you'll show that if $1$ is a greatest common divisor of $a$ and $n$, then the \ncongruence $ax \\equiv 1 \\pmod n$ has a solution for $x$.\n-/\n\n\n/-\n### Task\n\nProve the result above, both by hand and in Lean.\n-/\n\n/- Lemma :\nIf $1$ is a greatest common divisor of $a$ and $n$, then there exists an integer $x$ such that\n$a x \\equiv 1 \\pmod n$.\n-/\nlemma modeq_mul_eq_one_of_coprime (h : greatest_common_divisor 1 a n) : \u2203 (x : \u2124), a * x \u2261 1 [MOD n] :=\nbegin\n", "proof": "  rcases (bezout a n) with \u27e8d, s, t, hgcd, hdnn, heq\u27e9,\n  have h\u2082 : d = 1, from uniqueness_of_greatest_common_divisor hdnn zero_le_one hgcd h,\n  subst h\u2082,\n  use s,\n  rw heq,\n  use t,\n  linarith,\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 16, "editorText": "sorry", "lineOffset": 33, "name": "modeq_mul_eq_one_of_coprime", "statement": "(h : greatest_common_divisor 1 a n) : \u2203 (x : \u2124), a * x \u2261 1 [MOD n]"}, {"type": "lean", "content": "1077", "hidden": true}]}], "parents": [6]}], "texts": [["Pure Mathematics with Lean", "# Pure mathematics with Lean, version 1.4.0\n\n## By Gihan Marasingha\n\nThis is an interactive book aimed at beginning mathematics undergraduates. You'll learn to prove\ntheorems online using a computer tool called Lean.\n\nEach chapter is represented by a coloured circular button in the right-hand pane. Blue indicates your\ncurrent position, green is for completed chapters, and grey is for unread or incomplete chapters.\n\nAt every stage in a proof, there is a *target*, the thing you want to prove, and a *context*, the\nset of things you have already proved or assumed at the beginning of your argument.\nThe target and context change through the proof.\n\nThe word *goal* is used to refer variously to the target or to the combination of target and context.\n\nYou'll use *tactics* to modify the goal until you have proved the target (called 'closing the goal').\nEach tactic may invoke one or more *theorems*.\n\nNote: the book is roughly 30Mb in size. It must be downloaded before you can begin to work on the\nproblems. Once you open the book, wait for the text 'Lean is busy...' to disappear from the\ntop-right-hand pane before using Lean.\n\n*Pure mathematics with Lean* is part of the \n<a href=\"https://exlean.org\" target=\"blank\">exlean</a> project.\n\n**This book is under construction.** \n\n## Credits\n\nThis game was made using the\n<a href=\"https://github.com/mpedramfar/Lean-game-maker\">Lean Game Maker</a> by Mohammad Pedramfar.\n\nIt uses ideas and special tactics from the \n<a href=\"https://www.ma.imperial.ac.uk/~buzzard/xena/natural_number_game/\">Natural Number Game</a>\nby Kevin Buzzard.\n\n<a href=\"https://leanprover.github.io/\" target=\"blank\">Lean</a> is an interactive theorem prover developed at Microsoft Research under the direction of\nLeonardo de Moura.\n\nMathlib, Lean's mathematical library, is developed by the <a href=\"https://leanprover-community.github.io/\" target=\"blank\">Lean community</a>.\n", "Equations", "import myint.basic -- hide\n", "# Equations\n\n## Level 1: Proving equations through reflexivity\n\nIn the introduction, you read that tactics are used modify the goal, eventually proving \na theorem.\n\nThe `refl` tactic (short for `reflexivity`) can be used to prove any statement of the form\n`?X = ?X`. Here, I use `?X` to stand in for any expression of any type.\nIt could be `8 + 9` or `a * b` or `\"adele\"` or whatever.\n\nBelow, you are asked to prove `x + y = x + y`, where `x` and `y` are integers.\nThe word `sorry` between the `begin` and `end` lines below asks Lean not to give an error message if a\nproof isn't complete. You'll see a <span style=\"color:orange\">warning</span> message in the\nbottom-right hand pane. This indicates you shouldn't trust the proof just yet, as it uses `sorry`!\n\nDelete `sorry` (using the backspace key on your keyboard). In the right-hand pane you'll see:\n```\nx y : \u2124\n\u22a2 x + y = x + y\n```\n\nHere, `x y : \u2124` is the *context*, the set of things you know. In this case, you know `x` and `y`\nare integers.\n\nThe *target* is `\u22a2 x + y = x + y`. The `\u22a2` symbol can be read 'to prove'. So your target is\nto prove `x + y = x + y`.\n\nThe bottom part of the right-hand pane shows an <span style=\"color:red\">error</span>  message:\ntactic failed, there are unsolved goals. Don't panic! It's just telling you that you haven't yet\nproved the result.\n\nYour task is to replace `sorry` with `refl,`. Note the comma at the end of the line!\nIf you're successful, Lean will respond with the message `no goals` or `Proof complete!`\n", "The `refl` tactic closes any goal of the form `?X = ?X`. That is, it proves any equation where the\nleft and right sides are *definitionally equal*.\n", "## Translation to a hand-written proof\n\nIn words, the `refl` says, \"The result holds by reflexivity\". A one-line written proof of\nthe theorem below would be, \"The result hold by reflexivity\".\n\n", "namespace exlean -- hide\n", "open myint -- hide\n", "open_locale mynum -- hide\n", "variables (x y : \u2124) -- Declare `x` and `y` to be integers.\n", "`x + y = x + y`, for all integers `x` and `y`.\n", "end exlean -- hide\n", "import myint.basic -- hide\n", "# Equations\n\n## Level 2: Commutativity of addition via `rw`\n\nNow we'll prove something (slighlty) more interesting, that `x + y = y + x` for all integers `x`\nand `y`. Try the `refl` tactic below (remember to put a comma after `refl`) and see what happens.\n\nYou'll get an error message:\n```\ninvalid apply tactic, failed to unify\n  x + y = y + x\nwith\n  ?m_2 = ?m_2\n```\n\nLean tells you that you're trying to use `refl` to prove `x + y = y + x`, but it expects a target\nof the form `?m_2 = ?m_2`. There's no special meaning to the underscores here. It's the same as\nwriting `?X = ?X` as in the previous level.\n\nThe problem: even though we 'know' the left and right sides are equal, they are not\n*identically equal*.\nFortunately, Lean comes with a *theorem* of just the right kind. It's called `add_comm`, which is\nshort for additive commutativity.\nThe result `add_comm a b` states that `a + b = b + a`, where `a` and `b` are integers.\n\nTo apply this theorem, we'll use the `rw` (short for `rewrite`) tactic.\n\nReplace the `sorry` below with `rw add_comm` (followed by a comma\u2014I won't mention this from now\non).\n\nLean will look for the first expression in the target that matches the pattern `a + b` and\nreplace every instance of that expression with `b + a`. Here, Lean finds `x + y` and replaces\nit with `y + x`.\n\nEqually, if `h` is an equation of the form `p = q` (where `p` and `q` are expressions),\n`rw h` will cause Lean to look for `p` in the target and replace it with `q`.\n\nHaving issued `rw add_comm`, the goal is to prove `y + x = y + x`.\nYou know how to prove a goal of this kind from the previous level.\nWrite the proof on the line after the `rw add_comm`.\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "variables (x y : \u2124) -- hide\n", "namespace pre_group -- hide\n", "a + b = b + a\n", "theorem add_comm (a b : \u2124) : a + b = b + a := myint.add_comm' a b -- hide\n", "\nYour proof of the theorem below will use two lines of code. If you move your cursor to a previous\nline, Lean will show you the tactic state at any point in the proof. If you click on the name of\na theorem, you'll get some brief documentation.\n", "Moving through a proof", "`x + y = y + x`, for all integers `x` and `y`.\n", "end pre_group -- hide\n", "end exlean -- hide\n", "## Translation to a hand-written proof\n\nIn words, the `rw add_comm` says, \"Rewrite using commuativity of addition\".\nAs hand-written proofs aren't interactive, it's helpful to mention explicitly any changes to the\ncontext. Here's a hand-written proof of the above result.\n\n> Rewriting using commutativity of addition, the goal is to prove `y + x = y + x`.\n> This follows by reflexivity.\n", "If `h` is an equation of the form `p = q`, `rw h` rewrites replaces `p` in the target with `q`.\n\nIf `k` is in the context, `rw h at k` performs the rewrite at `k` instead of at the target.\n\n`rw \u2190h` will rewrite backward: every occurrence of `q` is replaced with `p`. Type `\\l` to produce `\u2190`.\n\n`rw [h1, h2, h3]` rewrites with multiple hypotheses (you aren't limited to three)!\n", "## Anatomy of a level\n\nEach level contains three vertial panes. The left-hand pane contains a list of the tactics and\ntheorem statements you've seen so far. Click on the arrows to dig deeper.\n\nThe middle pane is the one you're reading now! It contains text and interactive exercises.\nThe right-hand pane contains the Lean Infoview window, showing the 'tactic state' and error messages.\n\nYou can navigate through the book using the buttons in the top horizonal pane. The circular arrow\nresets your progress.\n", "## How `rw` here differs from that in standard Lean\n\nThe `rw` tactic used in this book is slightly different the standard `rw`. In particular, if\nthe result of a rewrite is an equation of the form `X = X`, then the standard `rw` tactic will\nautomatically close the goal via reflexivity.\n\nThis automation has been disabled here to help you think more carefully about proof construction.\n", "import myint.basic equations.commutativity_rw -- hide\n", "# Equations\n\n## Level 3: Rewriting with hypotheses\n\nLook at the theorem below. It seems that you're being asked to prove `x + y = x + 2 * x`.\nSurely that isn't true in general! What's\ngoing on? If you look carefully, you'll see an additional hypothesis, `h : y = 2 * x`.\n\nThe `:` is just notation for naming a hypothesis (also called an assumption).\nSo the statement of the theorem can be read:\n\n> Let `x` and `y` be integers. Let `h` be the hypothesis `y = 2 * x`.\n> Then `x + y = x + 2 * x`.\n\nWhen you start the proof, you'll note in the top-right pane that `h : y = 2 * x` has been\nadded to the context.\n\nYou can use the hypothesis to rewrite the goal by typing `rw h` much as you used `rw add_comm`\nto rewrite via the theorem `add_comm`.\n\n### Tasks\n\n* Before doing the problem in Lean, think about what effect `rw h` will have on the goal.\n\n* Predict what error message Lean will produce if you replace `sorry` with `refl`. Test your\nprediction.\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "namespace pre_group -- hide\n", "variables (x y : \u2124) -- hide\n", "Let `x` and `y` be integers. Let `h` be the hypothesis `y = 2 * x`. Then `x + y = x + 2 * x`.\n", "end pre_group -- hide\n", "end exlean -- hide\n", "## Translation to a hand-written proof\n\n> Rewriting using `h`, the goal is to prove `x + 2 * x = x + 2 * x`.\n> This follows by reflexivity.\n", "import myint.basic equations.commutativity_rw-- hide\n", "# Equations\n\n## Level 4: Focussed rewriting\n\nHere, you're asked to prove `(x + y) + z = z + (y + x)`. Clearly a case for rewriting with the\n`add_comm` theorem.\n\nThink about what `rw add_comm` will do. What will happen if you do `rw add_comm` twice? Try this\nbelow and test your conjecture.\n\nWhat happens is that `rw add_comm` looks for an expression of the form `a + b`. It finds one in\n`(x + y) + z`, matching `a` with `x + y` and `b` with `z`. It replaces this with `b + a`. That is,\nwith `z + (x + y)`.\n\nYou might wonder why this is the first match. Why doesn't Lean work on `x + y` first, matching\n`a` with `x` and `b` with `y`? It's because Lean works outside-in, then left-to-right. The second\n`+` operator in `(x + y) + z` is the outermost operator, so is read first by Lean.\n\nThe problem: applying `rw add_comm` to the new goal `\u22a2 z + (x + y) = z + (y + x)` will match `a`\nwith `z` and `b` with `x + y`, rewriting the goal to `\u22a2 (x + y) + z = z + (y + x)`, taking us back\nto where we started!\n\n### Focussing a rewrite with arguments\n\nRecall that `add_comm a b` is the theorem that `a + b = b + a`. The quantities `a` and `b` are\n*arguments* to the theorem `add_comm`.\nEqually, `add_comm x (y + z)` is the theorem that `x + (y + z) = (y + z) + x`. This theorem has\narguments `x` and `y + x`. Note than arguments can be expressions, not just variables.\n\nApplying `rw add_comm x (y + z)` transforms `\u22a2 z + (x + (y + z)) = z` to\n`\u22a2 z + ((y + z) + x) = z`.\n\n### Tasks\n* Think about what would happen if you replaced `sorry` with `rw z y`. Try it out. Explain the\nresulting error message.\n\n* Use arguments, where necessary, to prove the theorem below.\n\n\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "namespace pre_group -- hide\n", "variables (x y z : \u2124) -- Declare `x`, `y`, and `z` to be integers.\n", "\nWhen you start the proof below, Lean displays the target as `\u22a2 x + y + z = z + (y + x)`.\nWhat happened to the parentheses on the left-hand side? Lean treats addition as\n'left associative'. This is a fancy way of saying that `x + y + z` should always be\ninterpreted as `(x + y) + z`.\n", "Missing parentheses?", "Let `x`, `y`, and `z` be integers. Then `(x + y) + z = z + (y + x)`.\n", "end pre_group -- hide\n", "end exlean -- hide\n", "## Translation to a hand-written proof\n\nHere's a suggestion. When writing a proof by hand, you need not (and should not) aim at a direct\ntranslation of a Lean proof. Here, I've kept the main idea of each line of my Lean proof while\ntranslating for ease of human understanding.\n\n> Rewriting by additive commutativity, the goal is to prove `z + (x + y) = z + (y + x)`.\n> Rewriting with additive commutativity on `x + y`, the goal is to prove `z + (y + x) = z + (y + x)`.\n> This follows by reflexivity.\n", "import myint.basic equations.commutativity_rw -- hide\n", "# Equations\n\n## Level 5: Associativity\n\nTime for a new theorem. This one is called `add_assoc`, which is short for additive associativity.\n\nThe result `add_assoc a b c` states that `(a + b) + c = a + (b + c)`, for all integers `a`, `b`,\nand `c`. You can see the statement in the sidebar on the left by unfolding 'Theorem statements'.\n\nAs with `add_comm`, you can use `add_assoc` to rewrite the goal using `rw add_assoc`.\n\nBelow, your task is to prove `(x + y) + z = x + (z + y)`. In future levels, this theorem will\nbe available as `add_right_comm`.\n\n**Before writing a Lean proof**, construct a hand-written proof.\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "namespace pre_group -- hide\n", "(a + b) + c = a + (b + c)\n", "theorem myint.add_assoc (a b c : \u2124) : a + b + c = a + (b + c) := myint.add_assoc' a b c -- hide\n", "open myint\n", "### Tasks\n\n* Think about what would happen if you performed `rw add_assoc` once, twice, and thrice.\n  Try it out and compare with your predication.\n\n* Prove the theorem below.\n\n", "\nYou'll need to rewrite with both `add_comm` and `add_assoc`. You may need to give arguments to one\nof your rewrites, as described in the previous level.\n", "Hint", "Let `x`, `y`, and `z` be integers. Then `(x + y) + z = x + (z + y)`.\n", "## Translation to a hand-written proof\n\nIn the following hand-written proof, I omit the word 'rewriting'.\n\n> By associativity, the goal is to prove `x + (y + z) = x + (z + y)`.\n> By commutativity, the goal is to prove `x + (z + y) = x + (z + y)`.\n> This follows by reflexivity.\n", "end pre_group -- hide\n", "end exlean -- hide", "import myint.basic equations.associativity -- hide\n", "# Equations\n\n## Level 6: Structuring proofs with `have`\n\nThe `have` tactic introduces a hypothesis into the context. It's a way to add structure to your\nproofs, stating and proving intermediate results before using them.\n\nConsider the goal `\u22a2 x + ((x + y) + z) = x + (z + (x + y))`.\n\nOne way to close this goal is to rewrite, giving specific arguments to `add_comm`.\nAnother option is to introduce an intermediate goal of proving `(x + y) + z = z + (x + y)`.\n\nThis is accomplished using `have h : (x + y) + z = z + (x + y)` (followed by a comma). \nThere's nothing special about `h` as the name of the hypothesis. Change it to whatever you wish.\n\nThis opens up a new goal: you'll see 2 goals in right-hand pane. The top goal is the new goal,\nnamely `\u22a2 (x + y) + z = z + (x + y)`. The bottom goal is the old goal, only with a new hypothesis,\n`h : (x + y) + z = z + (x + y)`.\n\nYou first work on closing the new goal, then close the original goal using hypothesis `h`.\n", "\nIf you want to work only on goal, put braces after the `have`. When you're cursor is in the\ninner brace, you'll only be working on the first goal.\n```\nhave h : (x + y) + z = z + (x + y),\n{ sorry },\nsorry\n``` \n", "Focussing on one goal at a time", "`have` is used to introduce a new hypothesis into the context. It opens a new goal for the proof\nof the hypothesis.\n\n### Example\n`have h2 : x + y = y + x` introduces a new goal, to prove\n`x + y = y + x` while adding the hypothesis `h2 : x + y = y + x` to the context of the old goal.\n", "namespace exlean -- hide\n", "namespace pre_group -- hide\n", "open_locale mynum -- hide\n", "open myint -- hide\n", "variables (x y z : \u2124) -- hide\n", "Let `x`, `y`, and `z` be integers. Then `x + ((x + y) + z) = x + (z + (x + y)))`.\n", "## Translation to a hand-written proof\n\nIn my hand-written proof below, I omit references to reflexivity.\n\n> I claim `h : (x + y) + z = z + (x + y)`.\n> To prove this, use commutativity of addition.\n> Rewrite the original goal using `h`.\n", "end pre_group -- hide\n", "end exlean -- hide", "import myint.basic equations.associativity -- hide\n", "# Equations\n\n## Level 7: Multiple rewrites\n\nRather than writing, for example `rw add_assoc x y z, rw add_comm`, you can write\n`rw [add_assoc x y z, add_comm]`.\n\n### Tasks\n\n* Use this technique, together with `have`, to write a structured proof below.\n\n* Now write a proof using a long chain of rewrites followed by `refl`. Which proof do you prefer? Why?\n", "namespace exlean -- hide\n", "namespace pre_group -- hide\n", "open_locale mynum -- hide\n", "open myint -- hide\n", "variables (x y z : \u2124) -- hide\n", "Let `x`, `y`, and `z` be integers. Then `x + (y + (x + z)) = (z + (x + y)) + x`.\n", "end pre_group -- hide\n", "end exlean -- hide", "import myint.basic equations.multiple_rewrites -- hide\n", "# Equations\n\n## Level 8: Backward rewrites\n\nSuppose you wanted to prove `y + x = 0` on the assumptions `h1 : x + 0 = 0` and `h2 : y = 0`.\nOne option would be to rewrite with `h2` to give `\u22a2 0 + x = 0`. You could then finish by\nrewriting with `add_comm` and `h1`.\n\nAnother option is to start by rewriting with `h1` *backward*. This would replace `0`\nin the target with `x + 0`. To do this in Lean, type `rw \u2190h1`.\n\nTo get the left arrow, type `\\l` followed by space or tab. Alternatively, just type `<-`\n", "namespace exlean -- hide\n", "namespace pre_group -- hide\n", "open_locale mynum -- hide\n", "open myint -- hide\n", "variables (x y z : \u2124) -- hide\n", "Here is a proof of this result, using three rewrites, one backward.\n", "example (h1 : x + 0 = 0) (h2 : y = 0) : y + x = 0 :=\nbegin\n", "  [pure_maths] -- hide\n", "  rw [\u2190h1, add_comm, h2],\n  refl,\n", "-- hide  \n", "end\n", "### Tasks\n* Prove the following using two rewrites, one backward.\n\n* Once you've done that, write a structured proof of the same result.\n", "\nIntroduce and prove the hypotheses `h2 : y + z * x = (z + x) + y` and\n`h3 : (z + x) + y = y + (z + x)` using the `have` tactic. Finish by rewriting with these\nhypotheses.\n", "Hint for structured proof", "Let `x`, `y`, and `z` be integers. If `(z + x) + y = y + z * x`, then `y + z * x = y + (z + x)`\n", "end pre_group -- hide\n", "end exlean -- hide", "import myint.basic equations.backward_rewrite -- hide\n", "# Equations\n\n## Level 9: Additive identity\n\nThe Lean theorem `add_zero` states that `x + 0 = x` for every integer `x`. In mathematics, this\nproperty is called (right) additive identity. Note `add_zero` should appear as a 'Theorem statement'\nin the left-hand pane. \n", "namespace exlean -- hide\n", "namespace pre_group -- hide\n", "open_locale mynum -- hide\n", "open myint -- hide\n", "a + 0 = a\n", "theorem add_zero (a : \u2124) : a + 0 = a := myint.add_zero' a -- hide\n", "Your goal is to prove `zero_add`, the right additive identity property, using `add_zero`.\nOnce you've done this, `zero_add` will be available to you in future levels.\n\nYou can use a series of rewrites and a `refl` or you can use a `rw` and the `exact` tactic, as\ndescrbed in the drop-down box below.\n\nAs always, construct a hand-written proof **before** writing your Lean proof.\n", "If `h` an expression (or the name of a hypothesis or theorem) that exactly matches the target,\nthen `exact h` will close the current goal.\n", "The `exact` tactic can be used in place of `rw` where a hypothesis or theorem *exactly*\nmatches the target.\n\nThus, the goal `\u22a2 (x + y) + z = x + (y + z)` is closed with `exact add_assoc x y z`.\n\nLikewise, if `h : x + y + 5 = 10`, then `\u22a2 x + y + 5 = 10` is closed with `exact h`.\n", "The `exact` tactic.", "`0 + a = a` for every integer `a`.\n", "end pre_group -- hide\n", "end exlean -- hide", "import myint.basic equations.additive_identity -- hide\n", "# Equations\n\n## Level 10: Universal statements\n\nSo far, our hypotheses have made reference to specific variables. The hypothesis `h : x + 3 = 5`\nstates `x + 3 = 5` for the particular variable `x`.\n\nIf we want a statement that holds *for every* value of a variable, we use the *universal quantifier*\n`\u2200`. This is read, \"for all\" or \"for every\" and is typed `\\all`.\n\nFor example, `\u2200 (x : \u2124), x + 5 = 10` states that `x + 5 = 10` *for every* integer `x`. Of course,\nthis is a false statement! A statement that begins with `\u2200` is called a\n*universally quantified statement*.\n\nHere's how to *use* a universally quantified statement. Given the hypothesis\n`h : \u2200 (x : \u2124), x + 5 = 10`, the expression `h 3` corresponds to `3 + 5 = 10`.\nIt's what we get by replacing `x` with `3` in the body of the statement.\n\nIf `3 + 5` appears in the target, then `rw h 3` replaces `3 + 5` with `10`.\n\n### The specialize tactic\n\nThe `specialize` tactic specializes a universally quantified statement. For example if\n`h : \u2200 (x : \u2124), x + 5 = 10`, then `specialize h 20` *replaces* `h` with\n`h : 20 + 5 = 10`. However, after using `specialize`, you can't go back to the more general\nversion of `h`.\n", "namespace exlean -- hide\n", "namespace pre_group -- hide\n", "open_locale mynum -- hide\n", "open myint -- hide\n", "variable (x : \u2124) -- hide\n", "\n### Tasks\n\nHere, you'll prove the unusual result `2 + 5 = 8 + 5` on the assumption `\u2200 x, x + 5 = 10`.\n\n\n* Write a proof using `rw`.\n\n* Write another proof where you use one `rw` and one application of `specialize`.\n\n* Think about how you'd write this proof by hand. Compare with my suggested translation at the bottom\nof the page.\n", "Let the hypothesis `h` be a universally-quantified statement. For example,\n`h : \u2200 (x : \u2124), x + 5 = 10`.\nThen `specialize h 8` replaces `x` with `8` in the body of `h`. Thus `h` becomes `8 + 5 = 10`.\n\nYou can specialize on more than one variable at a time. If `k : \u2200 (x y : \u2124), x + y = y * x`, then\n`specialize k 2 3` replaces `h` with `h : 2 + 3 = 3 * 2`.\n", "`2 + 5 = 8 + 5` on the assumption `\u2200 x, x + 5 = 10`.\n", "## Translation to a hand-written proof\n\n> Using `h` with `2` in space of `x`, we must show `10 = 8 + 5`.\n> But this follows on taking `x` to be `8` in `h`.\n", "end pre_group -- hide\n", "end exlean -- hide", "import myint.basic equations.additive_identity -- hide\n", "# Equations\n\n## Level 11: Uniqueness of additive identity\n\nIn a previous level, we saw that there's an integer `0` with the property that\n`x + 0 = x` for every `x`.\n\nIn this level, you'll show that `0` is the *only* integer that satisfies this property.\n", "namespace exlean -- hide\n", "namespace pre_group -- hide\n", "open_locale mynum -- hide\n", "open myint -- hide\n", "### Rewriting at a hypothesis\n\nBy default, `rw add_assoc` (say) applies `add_assoc` to the target. If `h` is a hypothesis in the\nlocal context, `rw add_assoc at h` will rewrite `h` using `add_assoc`.\n\nIn the example below, we rewrite at `h` and finish with `exact`. Alternatively, we could have\nperformed a backward `rw` at the target using `rw \u2190add_assoc`.\n", "example (x y z : \u2124) (h : (x + y) + z = 20) : x + (y + z) = 20 :=\nbegin\n  rw add_assoc at h,\n  exact h,\nend\n", "Use the `specialize` tactic.\n", "Hint", "Let `e` be an integer satsifying the property `\u2200 (x : \u2124), x + e = x`. Then `e` must be `0`.\n", "end pre_group -- hide\n", "end exlean -- hide", "import myint.basic equations.unique_additive_identity -- hide\n", "# Equations\n\n## Level 12: Additive inverse\n\nThe Lean theorem `add_left_neg` states that `(-a) + a = 0` for every integer `a`. In mathematics,\nthis property is called (left) additive inverse.\n\nLikewise `add_right_neg (a : \u2124) : a + (-a) = 0`.\n\nYou'll use one of these properties in proving the next result.\n", "namespace exlean -- hide\n", "namespace pre_group -- hide\n", "open_locale mynum -- hide\n", "open myint -- hide\n", "(-a) + a = 0\n", "theorem add_left_neg (a : \u2124) : (-a) + a = 0  := myint.add_left_neg a -- hide\n", "a + (-a) = 0\n", "theorem add_right_neg (a : \u2124) : a + (-a) = 0  := myint.add_right_neg a -- hide\n", "You might find it useful to use the previously-proved theorem `add_right_comm`.\n", "Hint", "For all integers `x` and `y`, we have `(x + y) + -x = y`.\n", "end pre_group -- hide\n", "export pre_group (add_add_neg) -- hide\n", "end exlean -- hide", "import myint.basic equations.additive_inverse -- hide\n", "# Equations\n\n## Level 13: Cancellation I\n\nRecall the (right) uniqueness of additive identity. Let `y` be an integer. If for every integer `x`,\nwe have `x + y = x`, then `y = 0`.\n\nIn this level, we'll prove a theorem that is subtly different. Let `y` and `x` be integers. If\n`x + y = x`, then `y = 0`.\n\n**Question**: how does this new statement differ from from the uniqueness of additive identity?\n\nThe new result cannot be proved using only additive identity. You'll need to use the\nadditive inverse property.\n\nThis may be the most challenging level so far.\n", "namespace exlean -- hide\n", "namespace pre_group -- hide\n", "open_locale mynum -- hide\n", "open myint -- hide\n", "Use `add_add_neg`.\n", "Hint", "If `a + b = a`, then `b = 0`.\n", "end pre_group -- hide\n", "end exlean -- hide", "import myint.basic equations.cancellation_i -- hide\n", "# Equations\n\n## Level 14: Uniqueness of additive inverse\n\nWe've seen the uniqueness of (right) additive identity. Now we'll show the uniqueness of (right)\nadditive inverse.\n", "namespace exlean -- hide\n", "namespace pre_group -- hide\n", "open_locale mynum -- hide\n", "open myint -- hide\n", "Use `add_add_neg`.\n", "Hint", "Let `x` and `y` be integers. If `x + y = 0`, then `y = -x`. \n", "end pre_group -- hide\n", "end exlean -- hide", "import myint.basic equations.unique_additive_inverse -- hide\n", "# Equations\n\n## Level 15: The simplifier\n\nThis level introduces a powerful new tactic, `simp`, Lean's simplifier. It rewrites \nrepeatedly using either supplied theorems & hypotheses or theorems that it 'knows'.\n\nTo suggest theorems and hypotheses for use with `simp`, provide them as a comma-separated list.\nIn the example below, we supply `simp` with `add_assoc` and `add_comm y x`.\n\nWithout `simp`, you'd need several applications of `rw add_assoc`. \n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "namespace pre_group -- hide\n", "open myint -- hide\n", "example (x y z : \u2124) : x + ((y + z) + x) = (y + x) + (z + x) :=\nbegin\n  simp [add_assoc, add_comm y x],\nend\n", "### Tasks\n\n* Prove the result below using only `simp` with supplied theorems, as in the example above. You should\nonly need to supply four theorems.\n\n* For fun (!) try proving this result using `rw`. Which proof do you prefer?\n", "Let `x`, `y`, and `z` be integers. Then `(y + x) + (0 + z + 0) + (0 + x + 0) = y + (z + (x + x))`\n", "The `simp` tactic rewrites repeatedly using either supplied theorems & hypotheses or theorems\nthat it 'knows'.\n\nTo suggest theorems and hypotheses for use with `simp`, provide them as a comma-separated list.\nFor example `simp [h, add_comm]` rewrites repeatedly with hypotheses `h` and theorem `add_comm`.\n", "end pre_group -- hide\n", "end exlean -- hide", "import myint.basic equations.simplifier -- hide\n", "-- This import contains the definitions of the algebraic structures `add_monoid`, `add_comm_group`, etc.\nimport algebra.group.basic\n", "# Equations\n\n## Level 16: Algebraic structures and advanced tactics\n\nIn this level, we'll show how to unleash `simp`'s power using 'type classes'. We'll introduce\nalgebraic structures (such as additive monoid and additive commutative group) that you'll explore\nin greater detail later.\n\nIn the last level, I mentioned that `simp` can use theorems that it knows, but we still had to\nsupply every theorem explicitly.\n\nThe reason is that `simp` doesn't (yet) know anything about\nthe integer type we've been using. That's because we aren't actually using Lean's built-in integer\ntype, but our own copy, called `myint`.\n\nThe result I've called `zero_add` is short for `exlean.pre_group.zero_add`.\nHere `exlean` and `pre_group` are\n<a href=\"https://leanprover.github.io/theorem_proving_in_lean/dependent_type_theory.html#namespaces\",\ntarget = \"blank\">namespaces</a> I've created to hide the messy details. You don't need to\nunderstand namespaces at the moment, beyond the fact that they permit the same name to be used\nfor different functions.\n\n### Monoids and groups\n\nThe simplifier does know a *different* theorem called `zero_add`, outside of any namespace.\nThis theorem isn't restricted to a particular type (such as integers, natural numbers, vectors of\nlength 2, etc.). Rather, it holds for any type belong to the `add_monoid` *type class*.\n\nA type class is merely a mechanism for dealing coherently with a collection of types that satsify\ncertain properties. To be an *instance* of the `add_monoid` type class, a type `G` must have a 'zero'\nelement and an operation called addition and denoted `+` which satisfiy the properties\nof additive associativity and additive identity (both left and right).\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "namespace pre_group -- hide\n", "open myint -- hide\n", "Here, we show that `myint` is an intance of the `add_monoid` (short for 'additive monoid' type class.\nTo do this, we merely need to provide the apprioate 'fields' of the `add_monoid` structure.\n\nFor example, the line `zero_add := exlean.pre_group.zero_add,` fulfills the `zero_add`\nconstraint of the `add_monoid` type class by supplying our theorem `exlean.pre_group.zero_add`.\n\nIn fact, there are fields other than those shown, but Lean can generate these automatically from\nthe specified fields. This is what the `..` notation asks Lean to do.\n", "instance : add_monoid myint :=\n{ add_assoc := exlean.pre_group.myint.add_assoc,\n  zero_add := exlean.pre_group.zero_add,\n  add_zero := exlean.pre_group.add_zero,\n  .. }\n", "An instance of `add_comm_monoid` is an `add_monoid` for which the `+` operation is commutative.\nWe only need supply the `add_comm` field and let Lean generate the other fields by providing the\ninstance `myint.add_monoid`. Again, we use the `..` notation to do this.\n", "instance : add_comm_monoid myint :=\n{ add_comm := exlean.myint.add_comm,\n  .. myint.add_monoid }\n", "An `add_group` (addtive group) is an `add_monoid` that has an additive negation operator which\nsatisfies the `add_left_neg` property, namely that `(-a) + a = 0` for every `a`.\n", "instance : add_group myint :=\n{ neg := exlean.myint.neg,\n  add_left_neg := exlean.pre_group.add_left_neg,\n  .. myint.add_monoid }\n", "Finally an `add_comm_group` (additive commutative group) is an additive group that is also\nan additive commutative monoid. All we need do is provide the required instances.\n", "instance : add_comm_group myint :=\n{ .. myint.add_group, .. myint.add_comm_monoid }\n", "end pre_group -- hide\n", "### Levelled-up `simp`\n\nNow `simp` will automatically use `zero_add`, `add_zero`, `add_left_neg`, `add_right_comm`, etc.\nHere's an example.\n", "example (x y : \u2124) : x + (-y) + y = x + 0 :=\nbegin\n  simp\nend\n", "Note that `add_assoc` and `add_comm` are *not* automatically applied by `simp`. Can you think why?\n", "example (x y z : \u2124) : (y + x) + (0 + z + 0) + (0 + x + 0) = y + (z + (x + x)) :=\nbegin\n  simp [add_assoc, add_comm x z],\nend\n", "In the example below, an ordinary `simp` would be useless as the target `\u22a2 x = y` cannot be\nsimplified further. However, using `simp at h` will simplify the hypothesis `h` using the \n`sub_right_inj` theorem. You haven't seen this theorem yet: suffice it to say that it does the \nobvious thing and `simp` finds it for you.\n\n", "example (x y z : \u2124) (h : z - x = z - y) : x = y :=\nbegin\n  simp at h,\n  exact h,\nend\n", "### Congruence closure\n\nCongruence closure, or `cc`, is another powerful tactic. Don't worry about what the words\n'congruence' and 'closure' mean here\u2014they refer to concepts in computer science.\n\nRoughly speaking, `cc` can be used to prove equations where the proof depends on associativity,\ncommutativity, and (optionally) the use of hypotheses in the local context. Here's an example.\n", "example (x y z : \u2124) (h : (z + x) + y = y + z * x) : y + z * x = y + (z + x) :=\nbegin\n  cc,\nend\n", "`cc` can be used to prove equations where the proof depends on associativity,\ncommutativity, and (optionally) the use of hypotheses in the local context.\n", "Use `simp` (and whatever else you need) to prove the following result.\nThis *statement* is similar to a hard result you proved in a previous level, but the\n*proof* can be written in no more than two lines.\n", "If `y + x = x`, then `y = 0`.\n", "end exlean -- hide\n", "Logic (And)", "import data.int.basic -- hide\n", "# Logic and Proof (And)\n\n## Level 1: Theorems and `from`\n\n### Theorem statements, hypotheses, targets, proofs\n\nAs a student of higher mathematics, your main task is to prove theorems.\n\nA theorem consists of two parts: (1) a statement of a mathematical result and (2) a proof of\nthat result.\n\nPythagoras' Theorem states: let  $T$ be a right-angled triangle, let $a$, $b$, $c$ be the\nside-lengths of $T$, and let $c$ be the length of the hypotenuse. Then  $a^2 + b^2 = c ^2$.\n\nIn this theorem statement, the *hypotheses* are:\n* $T$ is a right-angled triangle,\n* $a$, $b$, $c$ are the side lengths of $T$,\n* $c$ is the length of the hypotenuse.\n\nEvery theorem statement also has a *target*. In Pythagoras' Theorem, the target is:\n* $\\vdash a^2 + b^2 = c ^2$.\nThe symbol $\\vdash$ is read 'to prove'.\n\nAt every point in the proof, you have a *goal*. The goal is to prove the target in the context\nof the given hypotheses. The goal can change through the course of a proof.\n\n### Easy proofs\n\nIn the simplest of theorems, the target is one of the hypotheses.\n\n**Theorem**: Let $x$ be an integer. Suppose $h_1 : x > 0$ and $h_2 : x ^ 2 = 16$. Then $x ^ 2 = 16$.\n\nIn the theorem statement above, the target $\\vdash x ^ 2 = 16$ can be deduced immediately from the\nhypothesis I have labelled $h_2$. You can write the proof as follows:\n\n**Proof**: The result follows from $h_2$. \u220e\n\nThe symbol \u220e (read 'QED') indicates the end of a proof.\n\n### Easy proofs in Lean using `from`\n\nWe'll use the proof assistant Lean to write mathematical proofs. In the example below, the\nhypotheses are:\n* `x : \u2124`, that $x$ is an integer. Here, `\u2124` is typed `\\int`.\n* `h\u2081 : x > 0`, that $x > 0$. Note `h\u2081` is typed `h\\1`.\n* `h\u2082 : x ^ 2 = 16`, that $x^2 = 16$.\n\nThe target is to prove\n* `x ^ 2 = 16`.\n\nThe proof is the single line:\n* `from h\u2082,`\n\nThis corresponds to the handwritten proof, 'The result follows from $h_2$'. Here, `from` is\nan example of a Lean 'tactic'. Tactics are computer programmes that help in proving theorems.\nOn the left pane is a drop-down menu of all tactics seen so far in this game.\n", "If one of the hypothesis `h` matches the target, then `from h` will close the goal.\n\n`from` is a synonym for the tactic `exact`.\n", "If one of the hypothesis `h` matches the target, then `exact h` will close the goal.\n", "example (x : \u2124) (h\u2081 : x > 0) (h\u2082 : x ^ 2 = 16) : x ^ 2 = 16 :=\nbegin\n  from h\u2082,\nend\n", "namespace exlean -- hide\n", "### Tasks\n\nNow it's your turn!\n\n1. If you see the text 'Lean is busy...' in the upper-right hand pane, please\nwait until Lean downloads.\n2. In the lower-right hand pane, you'll see a warning message,\n'declaration exlean.easy_proof uses `sorry`'. This is normal. It indicates that we haven't yet\nwritten a proper proof.\n3. Below, you'll see a theorem statement and (between the words `begin` and `end`), a `sorry` proof.\nWe use `sorry` to plug gaps in an incomplete proof.\n4. Delete the word `sorry`. You'll get an error message. Don't worry this just means we don't have\na proof.\n5. In the upper-right pane, you'll now see the *goal*. This consists of the hypotheses `x y : \u2124`,\n`h\u2081 : x + y = 3`, `h\u2082 : x < 0`, `h\u2083 : x * y = -10`, and the target, `\u22a2 x + y = 3`.\n6. **Write a one-line proof** of the target, adapting the proof above. Recall `h\u2082` is typed as `h\\2`.\nDon't forget the comma! On a piece of paper, state the theorem and give a 'handwritten' proof,\nfollowing the example above.\n7. If everything went well, you'll see the text 'Proof complete!' in the upper-right pane.\n8. Click 'Next level' in the top pane to proceed to the next level.\n", "Let $x$ and $y$ be integers. Suppose $h_1 : x + y = 3$, $h_2 : x < 0$, and $h_3 : x y = -10$.\nThen $x + y = 3$.\n", "end exlean -- hide", "import data.int.basic -- hide\n", "# Logic and Proof (And)\n## Level 2: Decomposing an 'and' hypothesis\n\n### And statements\n\nLet $p$ and $q$ be propositions (mathematical statements). The formal statement $p \\land q$\ncorresponds to the informal statement '$p$ and $q$'.\n\nSuppose you have given a hypothesis $h : p \\land q$. Decomposing this hypothesis replaces $h$ with\ntwo new hypotheses $h\u2081 : p$ and $h\u2082 : q$.\n\n**Theorem**: Let $x$ be an integer. Supose $h : (x > 0) \\land (x ^ 2 = 16)$. Then $x ^ 2 = 16$.\n\n**Proof**: Decomposing $h$ gives $h_1 : x > 0$ and $h_2 : x ^2 = 16$. The result follows from\n$h_2$. \u220e\n", "### Decomposing a hypothesis in Lean\n\nIn Lean, we use the `cases` tactic to decompose a compound hypothesis. In the example below, using\n`cases h with h\u2081 h\u2082` decomposes the original hypothesis `h : x > 0 \u2227 x * x = 16` into two\nnew hypotheses, `h\u2081 : x > 0` and `h\u2082 : x * x = 16`. The target, `\u22a2 x * x = 16` is proved using\nhypothesis `h\u2082`.\n\n*Notation*: the symbol `\u2227` in Lean is typed `\\and`.\n", "example (x : \u2124) (h : (x > 0) \u2227 (x * x = 16)) : x * x = 16 :=\nbegin\n  cases h with h\u2081 h\u2082,\n  from h\u2082,\nend\n", "`cases` is a general-purpose elimination tactic. It it used to 'decompose' a hypothesis into\nits constituent parts.\n\n### Examples\n\n* Given `h : \u2203 (x : \u2124), x + 5 = y`, typing `cases h with m h\u2082` replaces `h` with `m : \u2124` and\n`h\u2082 : m + 5 = y`.\n\n* Given `h : p \u2227 q`, typing `cases h with hp hq` replaces `h` with `hp : p` and `hq : q`.\n\n* Given `h : p \u2228 q`, typing `cases h with hp hq` replaces the current goal with two goals\n(1) in which `h` is replaced with `hp : p` and (2) in which `h` is replaced with `hq : q`.\n\n* Given `x : \u2115`, typing `cases x with k` replaces the goal with two new goals: (1) a goal in which\nevery occurence of `x` is replaced with `0` and (2) a goal with a new variable `k : \u2115` and in \nwhich every occurrence of `x` is replaced with `succ k`.\n", "There is nothing special about the choice of hypothesis labels, as seen below.\n", "example (x : \u2124) (Bob : (x > 0) \u2227 (x * x = 16)) : x * x = 16 :=\nbegin\n  cases Bob with alice sameera,\n  from sameera,\nend\n", "namespace exlean -- hide\n", "### Tasks\n\n1. Replace `sorry` below with a Lean proof using `cases`. Adapt the proof of the example above.\n2. On a piece of paper, state and give a handwritten proof of this result.\n", "Let $x$ and $y$ be integers. Suppose $h : (x + y = 3) \\land (x < 0)$. Then $x + y = 3$.\n", "end exlean -- hide", "import data.int.basic -- hide\n", "# Logic and Proof (And)\n\n## Level 3: And elimination\n\nWhat I've called 'decomposition' of a hypothesis `h : p \u2227 q` is actually a combination of two\nmore fundamental principles: _left and elimination_ and _right and elimination_\n\n**Theorem**: Let $x$ be an integer. Supose $h : (x > 0) \\land (x ^ 2 = 16)$. Then $x ^ 2 = 16$.\n\n**Proof**: The result follows from right and elimination on $h$. \u220e\n", "  (h : p \u2227 q) : q\n", "  (h : p \u2227 q) : p\n", "In Lean, if `h : p \u2227 q`, then `and.elim_right h` (also written `h.right`) is a proof of `q`.\nLikwise `and.elim_left h` (or `h.left`) is a proof of `p`.\n", "example (x : \u2124) (h : (x > 0) \u2227 (x * x = 16)) : x * x = 16 :=\nbegin\n  exact and.elim_right h,\nend\n", "The same proof can be given using an alternative notation.\n", "example (x : \u2124) (h : (x > 0) \u2227 (x * x = 16)) : x * x = 16 :=\nbegin\n  exact h.right,\nend\n", "namespace exlean -- hide\n", "### Tasks\n\n1. Replace `sorry` below with a one-line Lean proof, adapting either of the proofs above.\n2. On a piece of paper, state and give a handwritten proof of this result.\n", "Let $x$ and $y$ be integers. Suppose $h : (x + y = 3) \\land (x < 0)$. Then $x + y = 3$.\n", "end exlean -- hide", "import data.int.basic -- hide\n", "# Logic and Proof (And)\n\n## Level 4: Propositions\n\n### Propositions\n\nIn previous levels, we saw that if $x$ is an integer and if $h : (x > 0) \\land (x ^ 2 = 16)$,\nthen $x^2 = 16$ follows. One proof is first to decompose $h$ as $h_1 : x > 0$ and\n$h_2 : x ^2 = 16$ and then to apply $h_2$.\n\nHere's another example.\n\n**Theorem**: Let $y$ be an integer. Supose $h : (y \\ne 2) \\land (10 y = 5)$. Then $10y = 5$.\n\n**Proof**: Decomposing $h$ gives $h_1 : y \\ne 2$ and $h_2 : 10y = 5$. The result follows from\n$h_2$. \u220e\n", "Other than the details of the hypotheses, the proofs are identitcal. We can generalise both\narguments by using symbols in place of particular statements. These symbols are called\n_propositional variables_.\n\nUsing propositional variables to stand for arbitrary propositions is similar to the use of\nvariables names (such as $x$) to stand for arbitrary numbers in high school algebra.\n\nWe now give a generalisation of the above proof.\n\n**Theorem**: Let $p$ and $q$ be propositions. Suppose $h : p \\land q$. Then $q$ follows.\n\n**Proof**: Decomposing $h$ gives $h_1 : p$ and $h_2 : q$. The result follows from $h_2$. \u220e\n\nThe same thing can be written in Lean.\n", "example (p q : Prop) (h : p \u2227 q) : q :=\nbegin\n  cases h with h\u2081 h\u2082,\n  from h\u2082,\nend\n", "The same theorem can be be proved via and elimination.\n\n**Proof**: The result follows by right and elimination on $h$. \u220e\n", "example (p q : Prop) (h : p \u2227 q) : q :=\nbegin\n  from h.right,\nend\n", "namespace exlean -- hide\n", "### Task\n\n1. Replace `sorry` below with a proof using `cases`.\n2. Delete your proof and write a one-line proof using and elimination.\n2. On a piece of paper, state and give handwritten proofs of this result.\n", "Let $r$ and $s$ be propositions. Suppose $h : s \\land r$. Then $s$ follows.\n", "end exlean -- hide", "import data.int.basic -- hide\n", "# Logic and Proof (And)\n\n## Level 5: Further 'and' decomposition\n\n### Nested and\n\n**Theorem**: Let $p$, $q$, and $r$ be propositions. Suppose $h : (p \\land q) \\land r$. Then $q$ follows.\n\n**Proof**: Decomposing $h$ gives $h_{pq} : p \\land q$ and $h_r : r$.\nDecomposing $h_{pq}$ gives $h_p : p$ and $h_q : q$. \u220e\n\nThe same proof can be written in Lean.\n", "example (p q r : Prop) (h : (p \u2227 q) \u2227 r) : q :=\nbegin\n  cases h with hpq hr,\n  cases hpq with hp hq,\n  from hq,\nend\n", "As before, note that the hypothesis names have no significance.\n", "example (p q r : Prop) (h : (p \u2227 q) \u2227 r) : q :=\nbegin\n  cases h with h\u2081 h\u2082,\n  cases h\u2081 with h\u2083 h\u2084,\n  from h\u2084,\nend\n", "namespace exlean -- hide\n", "### Tasks\n\n1. Replace `sorry` below with a Lean proof, adapting the proof of the example above.\n2. On a piece of paper, state and give a handwritten proof of this result.\n", "variables (p q r : Prop)\n", "Let $p$, $q$, $r$ be propostions. Suppose $h : p \\land (q \\land r)$. Then $r$ follows.\n", "end exlean -- hide", "import data.int.basic -- hide\n", "# Logic and Proof (And)\n\n## Level 6: New hypotheses with `have`\n\n### The `have` tactic\n\nIn a long proof, it can help to introduce new hypotheses into the context for later use.\nThe next example isn't long, but illustrates the concept.\n\n**Theorem**: Let $p$ and $q$ be propositions. Suppose $h : p \\land q$. Then $q$ follows.\n\n**Proof**: We have $h_2 : q$ by right and elimination on $h$. The result follows from $h_2$. \u220e\n", "In Lean, we accomplish this using the `have` tactic.\n", "example (p q : Prop) (h : p \u2227 q) : q :=\nbegin\n  have h\u2082 : q, from h.right,\n  from h\u2082,\nend\n", "Equally, we could replace `h.right` with `and.elim_right h`.\n", "For a more sophisticated example, we'll take a hypothesis that involves nesting `\u2227`s.\n", "example (p r q : Prop) (h : (p \u2227 q) \u2227 r) : q :=\nbegin\n  have h\u2081 : p \u2227 q, from h.left,\n  from h\u2081.right,\nend\n", "Immediately after typing `have h\u2081 : p \u2227 q,` in the proof above, Lean would present you with \ntwo new goals:\n\n```\n2 goals\np r q : Prop,\nh : (p \u2227 q) \u2227 r\n\u22a2 p \u2227 q\n\np r q : Prop,\nh : (p \u2227 q) \u2227 r,\nh\u2081 : p \u2227 q\n\u22a2 q\n```\n\n\nThe first of these is the goal introduced by the `have` tactic, namely that of proving `p \u2227 q`\nin the original context. The Lean code `from h.left,` closes this goal.\n\nThe second goal is that of proving the original target, `q` in a context that includes the\nresult to be proved by the `have` tactic.\n", "`have` is used to introduce a new hypothesis into the context. It opens a new goal for the proof\nof the hypothesis.\n\n### Example\n`have h2 : x + y = y + x` introduces a new goal, to prove\n`x + y = y + x` while adding the hypothesis `h2 : x + y = y + x` to the context of the old goal.\n", "namespace exlean -- hide\n", "### Task\n\n1. Replace `sorry` below with a Lean proof, adapting the proof of the example above. Remember that\n`\u2227` is typed `\\and`.\n2. On a piece of paper, state and give a handwritten proof of this result.\n3. (Bonus) you should be able to write a one-line proof of this result, using only the `from`\ntactic and elimination rules. Try this!\n", "variables (p q r : Prop)\n", "Let $p$, $q$, $r$ be propostions. Suppose $h : p \\land (q \\land r)$. Then $q$ follows.\n", "end exlean -- hide", "import data.int.basic -- hide\n", "# Logic and Proof (And)\n\n## Level 7: Splitting an 'and' target\n\n### Splitting a goal\n\nTo prove a target $\\vdash (x > 0) \\land (x + y = 5)$ is to prove both\n$x > 0$ and $x + y = 5$. That is, the original goal is split into two new goals.\n\n**Theorem**: Let $x$ and $y$ be integers. Suppose $h_1 : x > 0$ and $h_2 : x + y = 5$. Then\n$(x > 0) \\land (x + y = 5)$.\n\n**Proof**: It suffices to prove (1) $x > 0$ and (2) $x + y = 5$.\n1. The target $x > 0$ follows from $h_1$.\n2. The target $x + y = 5$ follows from $h_2$. \u220e\n", "The Lean tactic `split` can be used to split an 'and' goal. In the proof below, the text following\neach `--` is a _comment_. Lean ignores comments. Add comments to your Lean proofs to help explain\nyour proof to the reader.\n", "example (x y : \u2124) (h\u2081 : x > 0) (h\u2082 : x + y = 5) : (x > 0) \u2227 (x + y = 5) :=\nbegin\n  split,\n  from h\u2081,  -- Proof of x > 0\n  from h\u2082,  -- Proof of x + y = 5\nend\n", "Immediately after typing `split,` in the proof above, Lean creates two new goals:\n```\n2 goals\nx y : \u2124,\nh\u2081 : x > 0,\nh\u2082 : x + y = 5\n\u22a2 x > 0\n\nx y : \u2124,\nh\u2081 : x > 0,\nh\u2082 : x + y = 5\n\u22a2 x + y = 5\n```\n\nThe _context_ of both goals (the list of hypotheses) is identical. The only difference is\nthe target. The line `from h\u2081,` closes the first goal, leaving only one goal.\n```\n1 goal\nx y : \u2124,\nh\u2081 : x > 0,\nh\u2082 : x + y = 5\n\u22a2 x + y = 5\n```\nWe close this final goal with `from h\u2082,`\n", "\nThe `split` tactic splits a 'compound' target into multiple goals. \n\n### Examples\n\n`split` turns the target `\u22a2 p \u2227 q` into two goals: (1) `\u22a2 p` and (2)  `\u22a2 q`.\n\nEqually, if the target is `\u22a2 p \u2194 q`, split creates the goals (1) to prove\n`p \u2192 q` and (2) to prove `q \u2192 p`.\n", "### The `show` tactic\n\nProofs with many goals (espeically nested goals) can become complicated. One way to make clear\nwhat is being proved is to use the `show` tactic.\n\nHere's a simple proof that `q` follows from the assumptions `h\u2081 : p` and `h\u2082 : q`.\n", "example (p q: Prop) (h\u2081 : p) (h\u2082 : q) : q :=\nbegin\n  from h\u2082,\nend\n", "Using the `show` tactic, we make clear that the line `from h\u2082` is a proof of `q`.\n", "example (p q: Prop) (h\u2081 : p) (h\u2082 : q) : q :=\nbegin\n  show q, from h\u2082,\nend\n", "More usefully, `show` can be used to clarify the target of the goals that arise after splitting\nan 'and' target.\n", "example (x y : \u2124) (h\u2081 : x > 0) (h\u2082 : x + y = 5) : (x > 0) \u2227 (x + y = 5) :=\nbegin\n  split,\n  show x > 0, from h\u2081,\n  show x + y = 5, from h\u2082, \nend\n", "`show` is used to clarify what is being proved.\n\n### Example\nIf the target is to prove `p \u2227 q` and the hypothesis `h` is a proof of `p \u2227 q`, then\n`show p \u2227 q, from h` indicates the target to Lean (and the human reader!) and closes the goal.\n", "### Focussing with braces\n\nDealing with many goals at once can be confusing. Braces can be used to separate goals.\nIf you place your cursor within a brace, only the current goal is shown. It's good practice to\ncreate a `sorry` proof for each new goal and fill in each `sorry` in turn.\n\n```\nexample (x y : \u2124) (h\u2081 : x > 0) (h\u2082 : x + y = 5) : (x > 0) \u2227 (x + y = 5) :=\nbegin\n  split,\n  { sorry, },\n  { sorry, },\nend\n```\n\nFilling in each `sorry` above leads to the following proof.\n", "example (x y : \u2124) (h\u2081 : x > 0) (h\u2082 : x + y = 5) :\n(x > 0) \u2227 (x + y = 5) :=\nbegin\n  split,\n  { show x > 0, from h\u2081, },\n  { show x + y = 5, from h\u2082, },\nend\n", "namespace exlean -- hide\n", "### Task\n\n1. Complete the Lean proof below. Use `split`, `show`, and braces, as in the example above. Start\nby writing `sorry` within each brace.\n2. On a piece of paper, state and give a handwritten proof of this result.\n", "variables (p q r : Prop)\n", "Let $p$, $q$, $r$ be propostions. Suppose $h_1 : p$, $h_2 : q$, and $h_3 : r$. Then $r \\land q$ \nfollows.\n", "end exlean -- hide", "import data.int.basic -- hide\n", "# Logic and Proof (And)\n\n## Level 8: And introduction\n\n### An introduction principle\n\nThe `split` tactic is useful when each of the constituents of a compound target are complicated.\nVia split, we create two new goals and work on each goal separately.\n\nAn alternative approach to proving a statement of the form `p \u2227 q` is to use the 'and introduction'\nprinciple. This principle combines a proof of `p` with a proof of `q` to give a proof of `p \u2227 q`.\n\n**Theorem**: Let $x$ and $y$ be integers. Suppose $h_1 : x > 0$ and $h_2 : x + y = 5$. Then\n$(x > 0) \\land (x + y = 5)$.\n\n**Proof**: The result follows by and introduction on $h_1$ and $h_2$. \u220e\n", "In Lean, if `h\u2081 : p` and `h\u2082 : q` then `and.intro h\u2081 h\u2082` is a proof of `p \u2227 q`.\n", "  (h\u2081 : p) (h\u2082 : q) : p \u2227 q\n", "example (x y : \u2124) (h\u2081 : x > 0) (h\u2082 : x + y = 5) : (x > 0) \u2227 (x + y = 5) :=\nbegin\n  from and.intro h\u2081 h\u2082,\nend\n", "namespace exlean -- hide\n", "### Tasks\n\n1. Replace `sorry` below with a one-line Lean proof, adapting the proof of the example above. Your proof\nshould use `and.intro` and the `from` tactic.\n2. On a piece of paper, state and give a handwritten proof of this result.\n", "variables (p q r : Prop)\n", "Let $p$, $q$, $r$ be propostions. Suppose $h_1 : p$, $h_2 : q$, and $h_3 : r$. Then $r \\land q$ \nfollows.\n", "end exlean -- hide", "import data.int.basic -- hide\n", "# Logic and Proof (And)\n\n## Level 9: Backward proof and `apply`\n\n### Mixed forward and backward proofs\n\nWe've seen two ways to prove $p \\land q$.\n\n1. First prove $h_1 : p$ and $h_2 : q$. Applying and introduction to $h_1$ and $h_2$ gives \nthe result. In Lean, `and.intro h\u2081 h\u2082` is a proof of `p \u2227 q` from `h\u2081` and `h\u2082`. We use this proof\nin `from and.intro h\u2081 h\u2082,` to close a goal `p \u2227 q`.\n2. Apply and introduction immediately to create two new goals: (1) to prove `p` and (2) to prove\n`q`. In Lean, we do this via the `split` tactic.\n\nThe second approach above is called 'backward' proof.\n\nA third approach is to combine both proof styles.\n\n**Theorem**: Let $p$, $q$, and $r$ be propositions. Suppose $h_1 : p$, $h_2 : q$, and $h_3 : r$.\nThen $p \\land (q \\land r)$.\n\n**Proof**: Applying and introduction with $h_1$, it suffices to prove $q \\land r$.\nThis follows by and introduction on $h_2$ and $h_3$. \u220e\n\n\nThe first line of the proof above involves a partial application of and introduction. We provide\nand introduction with the first 'argument', $h_1 : p$ and leave, as a new goal, the proof of\n$q \\land r$.\n\n### The `apply` tactic\n", "The `and.intro` rule takes two arguments: `h\u2081 : p` and `h\u2082 : q` and returns a proof of `p \u2227 q`.\n\nThe `apply` tactic takes any theorem and any number of arguments to that theorem and generates\nenough goals to fill in the remaining arguments.\n\nHere is a Lean version of the above proof. We use `apply`, giving `and.intro` the single argument\n`h\u2081`. It remains to prove `q \u2227 r`.\n", "variables (p q r : Prop)\nexample (h\u2081 : p) (h\u2082 : q) (h\u2083 : r) : p \u2227 (q \u2227 r) :=\nbegin\n  apply and.intro h\u2081,\n  show q \u2227 r, from and.intro h\u2082 h\u2083,\nend\n", "Alternatively, we could provide `apply and.intro` with *no* arguments. We would then\nhave to prove both goals, much like a `split` proof.\n", "example (h\u2081 : p) (h\u2082 : q) (h\u2083 : r) : p \u2227 (q \u2227 r) :=\nbegin\n  apply and.intro,\n  show p, from h\u2081,\n  show q \u2227 r, from and.intro h\u2082 h\u2083,\nend\n", "If we `apply and.intro` with both arguments, we are effectively doing a `from` proof.\n", "example (h\u2081 : p) (h\u2082 : q) (h\u2083 : r) : p \u2227 (q \u2227 r) :=\nbegin\n  have h\u2084 : q \u2227 r, from and.intro h\u2082 h\u2083,\n  apply and.intro h\u2081 h\u2084,\nend\n", "Consider the following result and its (handwritten) proof.\n\n**Theorem**: Let $p$, $q$, $r$ be propositions. Suppose $h_1 : p$, $h_2 : q$, and $h_3 : r$.\nThen $(p \\land q) \\land r$.\n\n**Proof**: Applying and introduction to $h_3$, it suffices to prove $p \\land q$. This follows from\nand introduction on $h_1$ and $h_2$. \u220e\n\n\nAs a human, you are clever enough to realise that $h_3$ in the proof above is meant to be the\nsecond argument to and introduction.\n\nComputers must be given more precise instructions. Any missing arguments at the front or middle\nof an `apply` are indicated with a `_` 'wildcard character.\n", "example (h\u2081 : p) (h\u2082 : q) (h\u2083 : r) : (p \u2227 q) \u2227 r :=\nbegin\n  apply and.intro _ h\u2083,\n  show p \u2227 q, from and.intro h\u2081 h\u2082,\nend\n", "`apply`, provided with a theorem name and any number of conditions of the theorem,\nopens as many new goals are necessary to fill in proofs of the remaining conditions\nof the theorem.\n", "namespace exlean -- hide\n", "### Tasks\n\n1. Replace `sorry` below with a Lean proof, adapting the proof of the example above. Your proof\nshould use `and.intro` and the `apply` tactic. Use `show` to indicate changes of the goal.\n2. On a piece of paper, state and give a handwritten proof of this result.\n", "Let $p$, $q$, $r$ be propostions. Suppose $h_1 : p$, $h_2 : q$, and $h_3 : r$. Then\n$(p \\land (q \\land r)) \\land p$ follows.\n", "end exlean -- hide", "import data.int.basic -- hide\n", "# Logic and Proof (And)\n\n## Level 10: And summary\n\n### Elimination and introduction\n\nIn logic, the entire meaning of $\\land$ is encapsulated by two principles.\n\n1. And introduction. Given $h_1 : p$ and $h_2 : q$, and introduction on $h_1$ and $h_2$ gives a \nproof of $p \\land q$.\n2. And elimination. Given $h : p \\land q$,\n    * Left and elimination on `h` gives a proof of `p`.\n    * Right and elimination on `h` gives a proof of `q`.\n\n\nIn Lean, the principles are as follows.\n\n1. And introduction. Given `h\u2081 : p` and `h\u2082 : q`, `and.intro h\u2081 h\u2082` is a proof of `p \u2227 q`.\n2. And elimination. Given `h : p \u2227 q`,\n    * `h.left` or `and.elim_left h` gives a proof of `p`.\n    * `h.right` or `and.elim_right h` gives a proof of `q`.\n\n### `cases` and `split`, backward proof\n\nLean provides the mechanism `cases` for doing left and right and elimination simultaneously.\nIf `h : p \u2227 q`, then `cases h with h\u2081 h\u2082` replaces `h` with two new hypotheses, `h\u2081 : p` and\n`h\u2082 : q`.\n\nThe `split` tactic is used for 'backward' and introduction. If the target is `p \u2227 q`, a forward\napplication of and introduction requires having proved first `h\u2081 : p` and `h\u2082 : q`. \nVia `split`, Lean creates two new goals, one for each of the conditions of and introduction.\n", "### `from`, `have`, and `show`\n\n* `from` is used to give a hypothesis or other proof term that closes the goal.\n* `have` allows you to create an auxiliary goal. The result of the goal is added to the context.\n* `show` is used to indicate what you're trying to prove.\n\n### `apply` and mixed forward / backward proofs\nThe `apply` tactic permits writing mixed forward / backward proofs, depending on the number\nof arguments given to the applied theorem.\n", "namespace exlean -- hide\n", "### Task\n\n1. Prove the Lean result below. Try as many different proof methods as you can. Which method\ndo you like the best?\n2. On a piece of paper, state and give a handwritten proof of this result.\n3. (Bonus) Give a one-line Lean proof of the result.\n", "variables (p q r : Prop)\n", "Let $p$, $q$, $r$ be propostions. Suppose $h : p \\land (q \\land r)$. Then $p \\land q$ \nfollows.\n", "end exlean -- hide", "Logic (Or)", "import data.int.basic -- hide\n", "# Logic and Proof (Or)\n\n## Level 1: Proving or statements\n\n### Left and right or introduction\n", "Let $p$ and $q$ be propositions. The formal statement $p \\lor q$\ncorresponds to the informal statement '$p$ or $q$'.\n\nThus, $(x > y) \\lor (x + y = 5)$ corresponds to '$x > y$ or $x + y = 5$'.\n\nTo *prove* an or statement $p \\lor q$ is either (1) to prove $p$ or (2) to prove $q$.\n\nThese are the two _introduction rules_ for $\\lor$. They can be stated more formally.\n\nLet $p$ and $q$ be propositions.\n1. Let $h : p$. 'Left or introduction' on $h$ gives a proof of $p \\lor q$.\n2. Let $h : q$. 'Right or introduction' on $h$ gives a proof of $p \\lor q$.\n\n**Theorem**: Let $x$ and $y$ be integers. Suppose $h : x + y = 5$. Then $(x > y) \\lor (x + y = 5)$.\n\n**Proof**: The result follows by right or introduction on $h$. \u220e\n", "### Or introduction in Lean\n\nThe Lean names for left and right or introduction are `or.inl` and `or.inr` respectively.\n\nSuppose `p` and `q` are propositions.\n1. Let `h : p`. Then `or.inl h` gives a proof of `p \u2228 q`.\n2. Let `h : q`. Then `or.inr h` gives a proof of `p \u2228 q`.\n\nBelow, we have a Lean proof of the previous theorem. The symbol `\u2228` is typed `\\or`.\n", "  (h : p) : p \u2228 q\n", "  (h : q) : p \u2228 q\n", "example (x y : \u2124) (h : x + y = 5) : (x > y) \u2228 (x + y = 5) :=\nbegin\n  from or.inr h,\nend\n", "Proofs by left or introduction proceed as you might expect.\n", "example (x y : \u2124) (h : x > y) : (x > y) \u2228 (x + y = 5) :=\nbegin\n  from or.inl h,\nend\n", "namespace exlean -- hide\n", "### Tasks\n\n1. Replace `sorry` below with a one-line Lean proof, adapting the proof of the example above.\n2. On a piece of paper, state and give a handwritten proof of this result.\n", "variables (p q r s : Prop)\n", "Let $p$, $q$, $r$, and $s$ be propostions. Suppose $h_1 : p$, $h_2 : s$, and $h_3 : r$. Then $r \\lor q$ \nfollows.\n", "end exlean -- hide", "import data.int.basic -- hide\n", "# Logic and Proof (Or)\n\n## Level 2: Nested or introduction\n", "**Theorem**: Let $a$ and $b$ be integers. Suppose $h : a = b$. Then\n$(a = 5) \\lor ((a=b) \\lor (a=7))$.\n\n**Proof**: We have $h_2 : (a=b)\\lor (a=7)$ from left or introduction on $h$.\nWe show $(a = 5) \\lor ((a=b) \\lor (a=7))$ from right or introduction on $h_2$. \u220e\n", "The same proof is represented in Lean below.\n", "example (a b : \u2124) (h : a = b) : (a = 5) \u2228 ((a = b) \u2228 (a = 7)) :=\nbegin\n  have h\u2082 : (a = b) \u2228 (a = 7), from or.inl h,\n  show (a = 5) \u2228 ((a = b) \u2228 (a = 7)), from or.inr h\u2082,\nend\n", "For a more succinct proof, we can skip the intermediate derivation of $(a=b) \\lor (a=7)$.\n\n**Proof**: The result follows by right or introduction applied to the result of\nleft or introduction on $h$. \u220e\n\nThis proof is shorter, but less readable. Here it is in Lean.\n", "example (a b : \u2124) (h : a = b) : (a = 5) \u2228 ((a = b) \u2228 (a = 7)) :=\nbegin\n  from or.inr (or.inl h)\nend\n", "namespace exlean -- hide\n", "### Tasks\n\n1. Replace `sorry` below with a Lean proof, using `have` to produce an intermediate proof. Recall\nthat `\u2228` is typed `\\or`.\n2. On a piece of paper, state and give a handwritten proof of this result.\n3. (Bonus) Give a one-line proof of the result.\n", "variables (p q : Prop)\n", "Let $p$ and $q$ be propostions. Suppose $h : q$. Then $(p \\lor q) \\lor p$ follows.\n", "end exlean -- hide", "import data.int.basic -- hide\n", "# Logic and Proof (Or)\n\n## Level 3: Backward or introduction\n", "In the last level, we saw this rather terse proof.\n", "example (a b : \u2124) (h : a = b) : (a = 5) \u2228 ((a = b) \u2228 (a = 7)) :=\nbegin\n  from or.inr (or.inl h)\nend\n", "We also so a more readable version that requires the introduction of an additional hypothesis.\n", "example (a b : \u2124) (h : a = b) : (a = 5) \u2228 ((a = b) \u2228 (a = 7)) :=\nbegin\n  have h\u2081 : (a = b) \u2228 (a = 7), from or.inl h,\n  show (a = 5) \u2228 ((a = b) \u2228 (a = 7)), from or.inr h\u2081,\nend\n", "### Backward or introduction\n\nA 'backward proof' of the above result avoids the introduction of additional hypotheses while\nremaining readable.\n\n**Proof**: It suffices, by right or introduction, to prove $(a = b)\\lor (a = 7)$.\nThis follows from left or introduction on $h$. \u220e\n\nRecall right or introduction takes $h : q$ and gives a proof of $p \\lor q$. When we use \nright or introduction backward, we replace the goal of proving $p \\lor q$ with the goal of\nproving $q$ (in the same context as the original goal).\n\nIn this backward proof, we write 'it suffices to prove' to indicate that the old goal is being\nreplaced with a new goal.\n", "### Backward or introduction in Lean\n\nIf the target is `\u22a2 p \u2228 q`, the tactic `right` replaces the goal with one of proving `q`.\nLikewise, the tactic `left` replaces the goal with that of proving `p`.\n", "example (a b : \u2124) (h : a = b) : (a = 5) \u2228 ((a = b) \u2228 (a = 7)) :=\nbegin\n  right,\n  show (a = b) \u2228 (a = 7), from or.inl h,\nend\n", "We can prove the same theorem entirely through backward applications of or introduction.\n", "example (a b : \u2124) (h : a = b) : (a = 5) \u2228 ((a = b) \u2228 (a = 7)) :=\nbegin\n  right,\n  show (a = b) \u2228 (a = 7),\n  left,\n  show a = b, from h,\nend\n", "`left` changes a goal of proving `p \u2228 q` into a goal of proving `p`.\n", "`right` changes a goal of proving `p \u2228 q` into a goal or proving `q`.\n", "namespace exlean -- hide\n", "### Task\n\n1. Replace `sorry` below with a backward Lean proof via the `left` and `right` tactics. Make your\nproof more readable by using the `show` tactic each time the goal changes.\n2. On a piece of paper, state and give a handwritten proof of this result.\n3. (Bonus) Write a one-line proof that uses only `from` and forward or introduction.\n", "variables (p q r : Prop)\n", "Let $p$, $q$, $r$ be propostions. Suppose $h : q$. Then $(p \\lor (q \\lor r)) \\lor p$\nfollows.\n", "end exlean -- hide", "import data.int.basic tactic -- hide\n", "# Logic and Proof (Or)\n\n## Level 4: Decomposing or statements\n", "Let $x$ be a natural number (a non-negative integer). Suppose you are given the hypothesis\n$h : (x = 2) \\lor (x = 3)$. What can you prove?\n\nYou know *either* that $x = 2$ *or* you know $x = 3$ but you don't know which one holds.\nLet's label the two possibilities. Either $h_1 : x = 2$ or $h_2 : x = 3$.\n\n* On the assumption $h_1 : x = 2$, you know $x ^ 2 + 6 = 2 ^ 2 + 6 = 10 = 5x$.\n* On the assumption $h_2 : x = 3$, you know $x ^ 2 + 6 = 3 ^ 2 + 6 = 5x$.\n\nIn either case, you deduced $x ^ 2 + 6 = 5x$. Thus, it seems logical to say that\n$x ^ 2 + 6 = 5x$ follows from the original assumption $h : (x = 2) \\lor (x = 3)$.\n", "### Or elimination\n\nLet $p$, $q$, and $r$ be propositions. Let $h : p \\lor q$. The or elimination rule applied to $h$\nstates that if (1) $r$ can be deduced from the assumption of $p$ and (2) if $r$ can be deduced from\nthe assumption of $q$, then $r$ follows.\n\n### The `cases` tactic for decomposing an or statement\n\nIn Lean, one way to decompose an or statement is to use the `cases` tactic, as in the example below.\nWe'll soon discuss the the new tactics `rw` and `norm_num`.\n", "example (x : \u2115) (h : (x = 2) \u2228 (x = 3)) : x ^ 2 + 6 = 5 * x :=\nbegin\n  cases h with h\u2081 h\u2082,\n  { rw (h\u2081 : x = 2),  -- The case h\u2081 : x = 2.\n    show 2 ^ 2 + 6 = 5 * 2, norm_num, }, \n  { rw (h\u2082 : x = 3),  -- The case h\u2082 : x = 3.\n    show 3 ^ 2 + 6 = 5 * 3, norm_num, },\nend\n", "In the proof above, we start with two hypotheses, `x : \u2115` and `h : (x = 2) \u2228 (x = 3)`.\nThe target is `\u22a2 x ^ 2 + 6 = 5 * x`.\n\nThe effect of `cases h with h\u2081 h\u2082` here is to create two new goals. In the first goal, the original \n'or' hypothesis `h` is replaced with its left side, `h\u2081 : x = 2`. IN the second goal, `h` is\nreplaced with its right side, `h\u2082 : x = 3`.\n```\n 2 goals\n case or.inl\n x : \u2124,\n h\u2081 : x = 2\n \u22a2 x ^ 2 - 5 * x + 6 = 0\n \n case or.inr\n x : \u2124,\n h\u2082 : x = 3\n \u22a2 x ^ 2 - 5 * x + 6 = 0\n\n ```\n\nWhen we prove the first goal, we use the rewrite tactic, `rw` in the form `rw h\u2081` to replace\n`x` in the target with `2`. This leaves the goal of proving `2 ^ 2 + 6 = 5 * 2`.\nWe close this goal with the Lean tactic `norm_num`, suitable for proving various numerical\ngoals.\n", "The proof above can be written more briefly by removing instances of `show` and the type annotations\nto `rw`. However, the resulting proof is harder to read.\n", "example (x : \u2115) (h : (x = 2) \u2228 (x = 3)) : x ^ 2 + 6 = 5 * x :=\nbegin\n  cases h with h\u2081 h\u2082,\n  { rw h\u2081,\n    norm_num, }, \n  { rw h\u2082,\n    norm_num, },\nend\n", "If `h` is an equation of the form `p = q`, `rw h` rewrites replaces `p` in the target with `q`.\n\nIf `k` is in the context, `rw h at k` performs the rewrite at `k` instead of at the target.\n\n`rw \u2190h` will rewrite backward: every occurrence of `q` is replaced with `p`. Type `\\l` to produce `\u2190`.\n\n`rw [h1, h2, h3]` rewrites with multiple hypotheses (you aren't limited to three)!\n", "\nThe `norm_num` tactic proves numerical goals. For example, it will close the goal\n`\u22a2 10 * 3 + 5 = 37 - 7`\n", "If you were to write the proof 'by hand', you might write the following:\n\n> By definition, it suffices to show there exists an integer `m` such that `10 = 5 * m`.\n> Take `2` for `m`. Then we must show `10 = 5 * 2`.\n> This is true by arithmetic.\n", "namespace exlean -- hide\n", "\n### Tasks\n\n1. Replace `sorry` below with a Lean proof, adapting the proof above.\n2. On a piece of paper, state and give a handwritten proof of this result.\n", "As in the example, you can use `cases h with h\u2081 h\u2082` to decompose the 'or' statement `h`.\nAt later steps, you'll need to use the `rw` and `norm_num` tactics.\n", "Starting the proof", "If you followed the hint above, in the second goal, you'll have an 'and' hypothesis\n`h\u2082 : (x = 3) \u2227 (x > 0)` in the second goal. You can decompose this hypothesis using something like\n`cases h\u2082 with h\u2083 h\u2084`. Here, `h\u2083 : x = 3` and `h\u2084 : x > 0`.\n", "Dealing with 'and'", "variable (x : \u2115)\n", "Let $x$ be a natural number. Suppose\n$h : (x = 1) \\lor ((x= 3) \\land (x > 0))$, then $x ^2 + 3 = 4 x$.\n", "end exlean -- hide", "import data.int.basic tactic -- hide\n", "# Logic and Proof (Or)\n\n## Level 5: Implication\n", "Before continuing or study of $\\lor$, we examine how to prove an implication.\n\n### Implication\n\nThe statement $(x = 2) \\to x ^ 2 = 4$ is an example of implication. It can be read, 'if $x = 2$, then $x^2 = 4$'.\n\nTo *prove* an implication $p \\to q$ is to assume $p$ and derive $q$.\n\n**Theorem**: $(x = 2) \\to (x ^2 = 4)$.\n\n**Proof**: Assume $h : x = 2$. We must prove $x ^ 2 = 4$. Rewriting with $h$, we must prove\n$2 ^ 2 = 4$. This follows by numerical calculation. \u220e\n\n### Proving implications in Lean\n\nTo prove `p \u2192 q` in Lean, start with `assume h : p` (replacing `h` with any other name). \nYou then need to prove `q`. The symbol `\u2192` is typed `\\r`.\n", "example (x : \u2115) : (x = 2) \u2192 (x ^ 2 = 4) :=\nbegin\n  assume h : x = 2,\n  show x ^ 2 = 4,\n  rw (h : x = 2),\n  show 2 ^ 2 = 4, norm_num,\nend\n", "If the target is `\u22a2 p \u2192 q`, then `assume h : p` replaces the goal with one in which the target\nis `\u22a2 q` and in which the context contains the hypothesis `h : p`.\n", "namespace exlean -- hide\n", "\n### Tasks\n\n1. Replace `sorry` below with a Lean proof.\n2. On a piece of paper, state and give a handwritten proof of this result.\n", "Start with `assume h : a = b,`\n\nThe remainder of the proof is identical to that of an example from an earlier level in this world.\n", "Starting the proof", "variables (a b : \u2124)\n", "Let $a$ and $b$ be integers. Then $(a = b) \\to ((a = 5) \\lor ((a = b) \\lor (a = 7)))$.\n", "end exlean -- hide", "import data.int.basic tactic -- hide\n", "# Logic and Proof (Or)\n\n## Level 6: Or elimination (again)\n", "### Or elimination\n\nWe'll restate the or elimination rule from a previous level.\n\nLet $p$, $q$, and $r$ be propositions. Let $h : p \\lor q$. Let $h_1$ be a proof that $p$ implies $r$.\nLet $h_2$ be a proof that $q$ implies $r$.\n\nThe or elimination rule applied to $h$, $h_1$, and $h_2$ produces a proof of $r$.\n\n### A forward or elimination proof\n\n\n**Theorem**: Let $x$ be a natural number. Suppose $h : (x = 2) \\lor (x = 3)$. Then\n$x ^ 2 + 6 = 5x$.\n\n**Proof**: We have $h_1 : (x = 2) \\to x ^ 2 + 6 = 5x$:\n\n> Assume $H_2 : x = 2$. We must show $x ^ 2 + 6 = 5x$. Rewriting with $H_2$,\n> $\\vdash 2 ^ 2 + 6 = 5 \\times 2$, which holds by numerical calculation.\n \nWe have $h_2 : (x = 3) \\to x ^ 2 + 6 = 5x$:\n\n> Assume $H_3 : x = 3$. We must show $x ^ 2 + 6 = 5x$. Rewriting with $H_3$,\n> $\\vdash 3 ^ 2 + 6 = 5 \\times 3$, which holds by numerical calculation.\n\nThe result follows by or elimination on $h$, $h_1$, and $h_2$. \u220e\n\n### Or elimination in lean\n\nThe Lean or elimination theorem is called `or.elim`. For propositions, `p`, `q`, and `r`, if\n`h : p \u2228 q`, `h\u2081 : p \u2192 r`, and `h\u2082 : q \u2192 r`, then `or.elim h h\u2081 h\u2082` is a proof of `r`.\n\n", "  (h : p \u2228 q) (h\u2081 : p \u2192 r) (h\u2082 : q \u2192 r) : r\n", "example (x : \u2115) (h : (x = 2) \u2228 (x = 3)) : x ^ 2 + 6 = 5 * x :=\nbegin\n  have h\u2081 : (x = 2) \u2192 (x ^ 2 + 6 = 5 * x),\n  { assume H\u2082 : x = 2,\n    show x ^ 2 + 6 = 5 * x,\n    rw H\u2082,\n    show 2 ^ 2 + 6 = 5 * 2, norm_num, },\n  have h\u2082 : (x = 3) \u2192 (x ^ 2 + 6 = 5 * x),\n  { assume H\u2083 : x = 3,\n    show x ^ 2 + 6 = 5 * x,\n    rw H\u2083,\n    show 3 ^ 2 + 6 = 5 * 3, norm_num, },\n  from or.elim h h\u2081 h\u2082,\nend\n", "This forward proof is somewhat long-winded and requires introducing intermediate hypotheses.\nAn alternative approach is to have a mixed forward / backward proof using `apply or.elim`:\n", "example (x : \u2115) (h : (x = 2) \u2228 (x = 3)) : x ^ 2 + 6 = 5 * x :=\nbegin\n  apply or.elim h,\n  { assume h\u2081 : x = 2,\n    rw h\u2081,\n    show 2 ^ 2 + 6 = 5 * 2, refl, }, \n  { assume h\u2082 : x = 3,\n    rw h\u2082,\n    show 3 ^ 2 + 6 = 5 * 3,\n    refl, }, -- The case h\u2082 : x = 3\nend\n", "After typing `apply or.elim h` in the proof above, we are left with two goals, each an implication.\n```\n 2 goals\n x : \u2115,\n h : x = 2 \u2228 x = 3\n \u22a2 x = 2 \u2192 x ^ 2 + 6 = 5 * x\n \n x : \u2115,\n h : x = 2 \u2228 x = 3\n \u22a2 x = 3 \u2192 x ^ 2 + 6 = 5 * x\n  ```\n\nThe approach shares features with the use of `cases` to decompose an `\u2228` statement.\n", "namespace exlean -- hide\n", "\n### Tasks\n\n1. Replace `sorry` below with a Lean proof, using `cases` to decompose `h`\n2. Delete your proof and write a proof using `apply or.elim h`.\n3. Delete this proof and write a forward proof that else with `from or.elim h h\u2081 h\u2082`.\n4. On a piece of paper, state and give handwritten proofs of this result.\n", "variables (p q : Prop)\n", "Let $p$ and $q$. Suppose $h : p \\lor q$. Then $q \\lor p$ follows.\n", "end exlean -- hide", "import data.int.basic tactic -- hide\n", "# Logic and Proof (Or)\n\n## Level 7: Or summary\n", "### Introduction and elimination\n\nThe $\\lor$ symbol is defined by two principles.\n\n1. Or introduction. Let $p$ and $q$ be propostions.\n    * Left or introduction on $h : p$ gives a proof of $p \\lor q$.\n    * Right or introduction on $h : q$ gives a proof of $p \\lor q$.\n2. Or elimination. Let $p$, $q$, and $r$ be propositions. Let $h : p \\lor q$, $h_1 : p$, and\n$h_2 : q$. Then or elimination on $h$, $h_1$, and $h_2$ gives a proof of $r$.\n\nIn Lean, the principles are as follows.\n\n1. Or introduction. Let `p` and `q` be propositions.\n    * Let `h : p`. Then `or.inl h` is a proof of `p \u2228 q`.\n    * Let `h : q`. Then `or.inr h` is a proof of `p \u2228 q`.\n2. Or elimination. Let `p`, `q`, and `r` be propositions. Let `h : p \u2228 q`, `h\u2081 : p \u2192 r`, and\n`h\u2082 : q \u2192 r`. Then `or.elim h h\u2081 h\u2082` is a proof of `r`.\n\n### Or tactics\n\nUsing the `left`, `right`, and `cases` tactics, we can write backward proofs involving `\u2228`.\n\n1. Or introduction. Let `p` and `q` be propositions. Suppose `\u22a2 p \u2228 q` is the target.\n    * `left` changes the goal to `\u22a2 p`.\n    * `right` changes to goal to `\u22a2 q`.\n2. Let `p`, `q`, `r` be propositions. Suppose `h : p \u2228 q`. If the target is `\u22a2 r`, then\n`cases h with h\u2081 h\u2082` replaces the current goal with two new goals:\n    a. A goal in which `h` has been replaced with `h\u2081 : p` and\n    b. a goal in which `h` has been replaced with `h\u2082 : q`.\nIn both cases the target remains as `\u22a2 r`.\n\n### `apply`, `rw`, `norm_num`, `assume`\n\n* `apply` is a general-purpose tactic for writing mixed forward / backward proofs. Supply\n`apply` with the name of a theorem, some conditions for the theorem, and a suitable number of\nwildcards. Lean will either close the goal or open enough new goals to account for the missing\nconditions.\n* `rw` is used for substitutions. For example, if `h : x = 5` and `\u22a2 x + y = 6`, then\n`rw h` will change the target to `\u22a2 5 + y = 6`.\n* `norm_num` proves numerical goals, such as `5 * 7 + 4 = 39`.\n* `assume` is used in proving implications. To prove `p \u2192 q` is to first `assume h : p` and then\nderive `q` on this assumption.\n", "namespace exlean -- hide\n", "We end this world with a challenge question that will test your understanding of all the rules\nof introduction and elimination for `\u2227` and `\u2228`.\n\n### Tasks\n\n1. Replace `sorry` below with a Lean proof.\n2. On a piece of paper, state and give a handwritten proof of this result.\n3. (Bonus) What's the shortest Lean proof you can write? What proof is most readable? Can you\nexplain your proof to your friends?\n", "variables (p q r : Prop)\n", "Let $p$ and $q$. Suppose $h : p \\lor q$. Then $q \\lor p$ follows.\n", "end exlean -- hide", "Variables", "import tactic -- hide\n", "# Variables\n\n## Level 1: Introduction to variables; for all elimination\n", "Let $x$ be an integer variable. Consider the following equations:\n\n* $(x - 1) ^ 2 = x ^2 - 2x + 1$,\n* $x ^ 2 + x - 6 = 0$,\n* $x ^ 2 + 1 = 0$.\n\nOne of them holds for every $x$, one only for certain $x$, and one for no $x$.\n\nNone of the equations, by itself, is a full mathematical statement. The following *are* complete\nmathematical statements, each of which can be proved.\n\n* For every $x : \\mathbb Z$, we have $(x - 1)^2 = x^2 - 2x + 1$.\n* It's not the case that for every $x : \\mathbb Z$, we have $x^2 + x - 6 = 0$.\n* There exists an $x : \\mathbb Z$ such that $x ^ 2 + x - 6 = 0$.\n* There does not exist and $x : \\mathbb Z$ such that $x^2 + 1 = 0$.\n", "### For all statements\n\nThe symbol $\\forall$ is read 'for all' or 'for every'. Thus,\n$\\forall (x : \\mathbb Z), (x - 1) ^ 2 = x ^2 - 2x + 1$ is a short way of writing, 'for every\ninteger $x$, $(x-1)^2 = x^2 - 2x + 1$'.\n\nIn Lean, we write `\u2200` as `\\all`, so the mathematical statement above is written in Lean as\n```\n\u2200 (x : \u2124), (x - 1) ^ 2 = x ^ 2 - 2x + 1\n```\n\n### For all elimination\n\nLet $h$ be a proof of $\\forall (x : \\mathbb Z), (x - 1) ^ 2 = x ^2 - 2x + 1$. Part of the meaning\nof $h$ is that $(x - 1) ^ 2 = x ^2 - 2x + 1$ holds no matter what *particular* integer value is\nsubsituted for $x$.\n\nWith the above definitions, for all elimination with $h$ and $3$ gives a proof of\n$(3-1)^2 = 3 ^ 2 - 2 \\times 3 + 1$.\n\n\n### For all elimination in Lean\n\nLet `h` be a proof of a 'for all' statement (such as `\u2200 (x : \u2115), x ^ 2 \u2265 0`) and let `a` be a\nparticular quantity (such as `4`). Then `h a` is a proof of the specialised statement\n(in this case, `4 ^ 2 \u2265 0`).\n", "example (h : \u2200 (x : \u2115), x ^ 2 \u2265 0) : 4 ^ 2 \u2265 0 :=\nbegin\n  from h 4,\nend\n", "### A fun example\n\n**Theorem**: Let $f$ be a function from the natural numbers to the\nnatural numbers. Let $h$ be the assumption that for every $x$, $f(x) > x^2$. Then\n$f(2) > 4$ and $f(3) > 9$.\n\nThis theorem can be stated more formally.\n\n**Theorem**: Let $f : \\mathbb N \\to \\mathbb N$, let $h : \\forall x, f(x) > x ^2$. Then \n$(f(2) > 4) \\land (f(3) > 9)$.\n\n**Proof**: By and introduction, it suffices to prove (1) $f(2) > 4$ and (2) $f(3) > 9$.\n1. We show $f(2) > 4$ by for all elimination with $h$ and $2$.\n2. We show $f(3) > 9$ by for all elimination with $h$ and $3$. \u220e\n\nThe same result is proved in Lean as follows.\n", "variable (f : \u2115 \u2192 \u2115)\nexample (h : \u2200 (x : \u2115), f(x) > x ^ 2) : (f(2) > 4) \u2227 (f(3) > 9) :=\nbegin\n  split,\n  { show f(2) > 4, from h 2, },\n  { show f(3) > 9, from h 3, },\nend\n", "\n### Tasks\n\n1. Replace `sorry` below with a Lean proof, adapting the proof above.\n2. On a piece of paper, state and give a handwritten proof of this result.\n", "As the target is an `\u2227` statement, you can start with a `split`, creating new goals for the\nleft side and right side of the `\u2227`.\n\nYou can close the first goal in a similar manner to the proof above\n", "Starting the proof", "Proving the second goal requires a bit more thought. A single application of for all\nelimination won't suffice. Instead, you can close the second goal with two `rw`s (rewrites).\nProvide each `rw` with an equation of the form `f(a + 2) = f(a)` for an appropriate choice of `a`,\nby for all elimination.\n", "The second goal", "namespace exlean -- hide\n", "Let $f : \\mathbb N \\to \\mathbb N$ be a function. Let $h$ be the assumption that \n$\\forall x, f(x + 2) = f(x)$. Then $f(2) = f(0)$ and $f(5) = f(1)$.\n", "end exlean -- hide", "import tactic -- hide\n", "# Variables\n\n## Level 2: For all introduction\n", "We've seen how to *apply* for all statements. How do you *prove* a for all statement?\n\n**Theorem**: Let $f : \\mathbb Z \\to \\mathbb Z$ be a function. Let $h$ be the assumption that\nfor every $x$, $-5 < f(x)$ and $f(x) < 5$. Then, for every integer $y$, $f(y) < 5$.\n\n**Proof**: Assume $y$ is an integer. We must show $f(y) < 5$. \nWe have $h\u2081 : -5 < f(y) \\land f(y) < 5$ from for all elimination on $h$ and $y$.\nThe result follows from right and elimination on $h_1$. \u220e\n\nAs illustrated above, to prove something happens for every $x$ is to assume $y$ is a variable\nquantity and then to demonstrate that the desired property holds for that $y$.\n", "variable (f : \u2124 \u2192 \u2124)\nexample (h : \u2200 x, -5 < f(x) \u2227 f(x) < 5) : \u2200 y, f(y) < 5 :=\nbegin\n  assume y : \u2124,\n  show f(y) < 5,\n  have h\u2081 : -5 < f(y) \u2227 f(y) < 5, from h y,\n  from and.elim_right h\u2081,\nend\n", "\n### Tasks\n\n1. Replace `sorry` below with a Lean proof.\n2. On a piece of paper, state and give a handwritten proof of this result.\n", "Begin with `assume y : \u2124`. This changes the goal to one of showing `f(y + 1) = f(y) \u2228 f(y) = 0`.\n", "Starting the proof", "namespace exlean -- hide\n", "Let $f : \\mathbb Z \\to \\mathbb Z$ be a function. Let $h$ be the assumption that for every\ninteger $x$, $f(x+1)=f(x)$. Then, for every integer $y$, $f(y+1) = f(y)$ or $f(y) = 0$.\n", "end exlean -- hide", "import tactic -- hide\n", "# Variables\n\n## Level 3: Proving 'there exists' statements with `use`\n", "### There exist statements\n\nIn this level, you'll see how to prove 'there exists' statements. A 'there exists' statement\nasserts that there exists $x$ for which a property, depending on $x$, holds.\n\nTo prove a 'there exists' statement is to provide (1) a particular value $m$ and (2) a proof that\nthe property holds for $m$.\n\nHere is an example.\n\n**Theorem**: There exists a natural number $x$ such that $x ^ 2 + x = 6$.\n\n**Proof**: Take $2$ for $x$. We must show $2 ^ 2 + 2 = 6$. This holds by numerical\ncalculation. \u220e\n\nWe use the notation $\\exists$ for 'there exists. With this notation, the statement of the above\ntheorem is $\\exists (x : \\mathbb N), x ^ 2 + x = 6$.\n\nLean uses the notation `\u2203` for 'there exists'. The symbol `\u2203` is typed `\\ex`.\nBelow, we use the tactic `use` in the proof of the 'there exists' statement. The effect of\n`use 2` is to replace the goal `\u2203 (x : \u2115), x ^ 2 + x = 6` with the goal of proving `2 ^ 2 + 2 = 6`.\n", "example : \u2203 (x : \u2115), x ^ 2 + x = 6 :=\nbegin\n  use 2,\n  show 2 ^ 2 + 2 = 6, norm_num,\nend\n", "If the goal is `\u22a2 \u2203 (x : \u03b1), P x` and if `y : \u03b1`, then `use y` changes the goal to\n`\u22a2 P y`.\n\n### Example\nWith a goal `\u22a2 \u2203 (x : \u2124), x + 5 = 23`, typing `use 18` changes the goal to `\u22a2 18 + 5 = 23`.\n", "\n### Tasks\n\n1. Replace `sorry` below with a Lean proof.\n2. On a piece of paper, state and give a handwritten proof of this result.\n", "Do some work on paper to determine what value $m$ you should take for `x`. Then try\n`use `$m$\n", "Starting the proof", "namespace exlean -- hide\n", "There exists a natural number $x$ such that $2x^2 + 5x - 30 = 22$.\n", "end exlean -- hide", "import tactic -- hide\n", "# Variables\n\n## Level 4: Exists introduction\n", "### Exists introduction\n\nIn the last level, we saw backward proofs of 'there exist' statements. For example, in our\nproof that there exists a natural number $x$ such that $x ^ 2 + x = 6$, we started by taking\n$2$ for $x$. This left us with the goal of proving $2 ^ 2 + 2 = 6$.\n\nThe more fundamental principle is *exists introduction*: given (1) a term $m$ and (2) a proof\n$h$ that $m$ satisfies some property, exists introduction produces a proof that there exists $x$\nsuch that the property holds for $x$.\n\n**Theorem**: There exists a natural number $x$ such that $x ^ 2 + x = 6$.\n\n**Proof**: By numerical calculation, we have $h : 2 ^ 2 + x = 6$. The result follows from exists\nintroduction with $2$ and $h$. \u220e\n", "### Exists introduction in Lean\n\nThe exists introduction rule is called `exists.intro` in Lean.\n", "  (m : \u03b1) (h : P m) : \u2203 (x : \u03b1), P x\n", "example : \u2203 (x : \u2115), x ^ 2 + x = 6 :=\nbegin\n  have h : 2 ^ 2 + 2 = 6, norm_num,\n  from exists.intro 2 h,\nend\n", "\n### Tasks\n\n1. Replace `sorry` below with a Lean proof, adapting the proof above. Use `exists.intro` instead of\n`use`.\n2. On a piece of paper, state and give a handwritten proof of this result.\n", "namespace exlean -- hide\n", "There exists a natural number $x$ such that $2x^2 + 5x - 30 = 22$.\n", "end exlean -- hide", "import tactic -- hide\n", "# Variables\n\n## Level 5: Decomposing an exists statement with `cases`\n", "### Decomposing exists statements\n\nIn the last level, we saw how to *prove* an exists statment. What if you're given an \nexists statement? What can you *do* with it?\n\n**Theorem**: Let $f : \\mathbb Z \\to \\mathbb Z$. Let $h$ be the assumption that there exists\nan integer $x$ such that $f(x + 2) > 5$. Then there exists an integer $y$ such that $f(y) > 5$.\n\n**Proof**: Decomposing $h$ gives an integer $m$ and the hypothesis $h_2 : f(m + 2) > 5$. \nTake $m + 2$ for $y$. We must show $f(m + 2) > 5$. This follows from $h_2$. \u220e\n\nMore formally, the statement of the theorem is: suppose $f : \\mathbb Z \\to \\mathbb Z$ and suppose\n$h : \\exists (x : \\mathbb Z), f(x) > 5$. Then $\\exists (y : \\mathbb Z), f(y + 2) > 5$.\n\nAn important observation about the proof above is that the assumption\n$h : \\exists (x : \\mathbb Z), f(x) > 5$ is *not the same* as asserting that $x$ *is* an integer\nfor which $f(x) > 5$.\n\nThe $x$ in the statement $h$ is to be thought of as a 'potential' quantity. We can replace it with\nany other variable name. Thus $h$ is *the same* as the assumption \n$\\exists (t : \\mathbb Z), f(t) > 5$.\n\nWhen we decompose $h$, we commit to a name for this potential variable (in the proof above, $m$) and\nwe commit to assertion about $m$ (in the proof above, $h_2 : f(m) > 5$).\n", "### The `cases` tactic\n\nThe `cases` tactic performs this decomposition in Lean. Below, `cases h with m h\u2082` \nreplaces `h : \u2203 (x : \u2124), f(x + 2) > 5` with `m : \u2124` and `h\u2082 : f(m + 2) > 5`.\n", "variable (f : \u2124 \u2192 \u2124)\nexample (h : \u2203 (x : \u2124), f(x + 2) > 5) : \u2203 (y : \u2124), f(y) > 5 :=\nbegin\n  cases h with m h\u2082,\n  use m + 2,\n  show f(m + 2) > 5, from h\u2082,\nend\n", "### Doing linear arithmetic in Lean\n\n**Theorem**: Let $f : \\mathbb Z \\to \\mathbb Z$. Let $z$ be an integer. Let $h$ be the assumption\nthat there exists an integer $x$ such that $f(x) > 5$. Then there exists an integer $y$ such that\n$f(y + z) > 5$.\n\n**Proof**: Decomposing $h$ gives an integer $m$ and the hypothesis $h_2 : f(m) > 5$. \nTake $m - z$ for $y$. We must show $f((m - z) + z) > 5$. We rewrite this goal, by arithmetic,\nto one of showing $f(m) > 5$. This follows from $h_2$.\n\nNote that though one can prove $f((m-z) + z) > 5$ is equivalent to $f(m) > 5$, these two statements\nare not identical. It's for this reason that we need to perform arithmetic to show the former\nstatement can be rewritten as the former.\n\nLean proves arithmetic results using the tactic `linarith`.\n", "`linarith` can prove linear equations and inequalities.\n", "variable (z : \u2124)\nexample (h : \u2203 (x : \u2124), f(x) > 5) : \u2203 (y : \u2124), f(y + z) > 5 :=\nbegin\n  cases h with m h\u2082,\n  use m - z,\n  rw (show (m - z) + z = m, by linarith),\n  from h\u2082,\nend\n", "\n### Tasks\n\n1. Replace `sorry` below with a Lean proof, adapting the proof above. \n2. On a piece of paper, state and give a handwritten proof of this result.\n", "namespace exlean -- hide\n", "", "end exlean -- hide", "import tactic -- hide\n", "# Variables\n\n## Level 6: Predicates\n", "We've informally described 'for all' elimination. We said that if a property holds for every $x$,\nthen that property holds if a particular value is substituted for $x$.\n\nMore concisely, we can use notation to describe the dependence of a property on a variable.\n\n### Predicates\nA *predicate* is a function that returns a proposition. \nFor example, let $P$ be the predicate on the integers defined by $P(x) := x > 5$. Then $P(10)$ is the proposition\n$10 > 5$. Likewise, $P(2)$ is the proposition $2 > 5$.\n\nAs another example let $S$ be the predicate on people defined by\n$S(x) := x \\text{ has red hair}$. Then $S(\\text{Prince Harry})$ states that\nPrince Harry has red hair.\n\nBy using predicate notation, we can state general results about proof.\n\n### For all statements and predicates\n\nLet $Q$ be the predicate defined by $Q(x) := (x - 1) ^ 2 = x ^2 - 2x + 1$.\nThe statement $\\forall (x : \\mathbb Z), (x - 1) ^ 2 = x ^2 - 2x + 1$ can be written\nconcisely as $\\forall (x : \\mathbb Z), Q(x)$. Suppose $h$ is a proof of\n$\\forall (x : \\mathbb Z), Q(x)$. For all elimination on $h$ and $3$ gives a proof of $Q(3)$, namely\nthe statement $(3 - 1) ^ 2 = 3 ^ 2 - 2\\times3 + 1$.\n\n### For all elimination\n\nMore generally, let $X$ be any type of quantity, let $P$ be a predicate on $X$. Let $h$ be a\nproof of $\\forall (x : X), P(x)$. Let $a$ be a term of type $X$. For all elimination on $h$ and $a$\ngives a proof of $P(a)$.\n\n### Predicates and for all elimination in Lean\n\nIn Lean `P : X \u2192 Prop` indicates that `P` is a predicate on a type `X`.\nGiven the 'for all' statement `h : \u2200 (x : X), P(x)`, given that `a` is a term of type `X`,\nwe deduce `P(a)`. The proof of this in Lean is simply `h a`.\n", "namespace exlean -- hide\n", "variables (X : Type*) (P Q : X \u2192 Prop)\nexample (h : \u2200 (x : X), P(x)) (a : X) : P(a) :=\nbegin\n  from h a,\nend\n", "### For all introduction\n\nLet $X$ be a type and let $P$ be a predicate on $X$. The 'for all introduction' rule asserts that\nto prove $\\forall (x : X), P(x)$ is to assume $x : X$ and derive $P(x)$.\n\n### Combining for all introduction and for all elimination\n\n**Theorem**: Let $P$ and $Q$ be predicates on a type $X$.\nLet $h$ be the assumption $\\forall (x : X), P(x) \\land Q(x)$.\nThen $\\forall (y : X), Q(y) \\land P(y)$.\n\n**Proof**: Assume $y : X$. We must show $Q(y) \\land P(y)$.\nBy for all elimination on $h$ and $y$, we have $P(y) \\land Q(y)$.\nDecomposing this gives $h_1 : P(y)$ and $h_2 : Q(y)$.\n\nWe show $Q(y) \\land P(y)$ by and introduction on $h_2$ and $h_1$. \u220e\n\nLet's do this in Lean.\n\nThe line `have : P(y) \u2227 Q(y), from h y` introduces a hypothesis\ncalled `this` into the context, where `this : P(y) \u2227 Q(y)`.\n", "example (h : \u2200 (x : X), P(x) \u2227 Q(x)) : \u2200 (y : X), Q(y) \u2227 P(y) :=\nbegin\n  assume y : X,\n  have : P(y) \u2227 Q(y), from h y,\n  cases this with h\u2081 h\u2082,\n  show Q(y) \u2227 P(y), from and.intro h\u2082 h\u2081,\nend\n", "\n### Tasks\n\n1. Replace `sorry` below with a Lean proof, adapting the proof above. \n2. On a piece of paper, state and give a handwritten proof of this result.\n", "", "end exlean -- hide", "Groups", "import  group.basic -- hide\n", "# Groups\n\n## Level 1: The group axioms; the inverse of an inverse\n", "A group $(G, \\ast)$ is a type (or set) $G$ together with a binary operation $\\ast : G \\times G \\to G$\nand a special element $e_G \\in G$ satisfying the following properties (called the _group axioms_):\n* [identity] for every $a : G$, $a \\ast e_G = a$ and $e_G \\ast a = a$.\n* [associativity] for all $a, b, c : G$, $(a \\ast b) \\ast c = a \\ast (b \\ast c)$\n* [inverse] for every $a : G$, there exists $b : G$ such that $a \\ast b = e_G$ and $b \\ast a = e_G$.\n", "### Groups in Lean\n\nIn Lean, we write $1$ for the identity element $e_G$ of a group. The symbol `1` here isn't \n(necessarily) the same as the ordinary number $1$.\n\nThe group axioms in Lean are the following:\n* `mul_one : \u2200 (a : G), a * 1 = a`\n* `one_mul : \u2200 (a : G), 1 * a`\n* `mul_assoc : \u2200 (a b c : G), (a * b) * c = a * (b * c)`\n* `mul_left_inv : \u2200 (a : G), a\u207b\u00b9 * a = 1` (note `a\u207b\u00b9` is typed `a\\-1`)\n\nIf you forget them, you can refresh your memory using the 'Groups' drop-down in the\n'Theorem statements' drop-down menu on the left \n\nHere are the group axioms in practice.\n", "namespace exlean -- hide\n", "open group -- hide\n", "variables {G : Type*} [group G] (a b c : G) -- hide\n", "(a : G) : a * 1 = a\n", "(a : G) : 1 * a = a\n", "(a b c : G) : a * (b * c) = (a * b) * c\n", "(a : G) : a\u207b\u00b9 * a = 1\n", "example : a * 1 = a := mul_one a\nexample : 1 * a = a := one_mul a\nexample : (a * b) * c = a * (b * c) := mul_assoc a b c\nexample : a\u207b\u00b9 * a = 1 := mul_left_inv a\n", "Together, `mul_one` and `one_mul` are equivalent to the 'normal' group identity axiom; `mul_assoc`\nis the same as the normal associativity axiom. The odd-one-out is `mul_left_inv`.\n\nRather than merely asserting the existence of an inverse of `g`, we name the inverse `g\u207b\u00b9`.\nMoreover, the `mul_left_inv` axiom only seems to suggest that `g\u207b\u00b9` is a left inverse of `g`.\nAs we'll soon see, the right inverse property can be proved from the other properties.\n\n", "### Uniqueness of identity\n\n**Theorem**:\nSuppose $b$ is an element of $G$ such that for every $a : G, b \\ast a = a$,\nthen $b = 1$.\n\nWe'll give a proof 'by calculation'. This is a series of equations, each with its own proof, \nstarting with the left-side and ending with the right-side of the desired equation $b = 1$.\n\n**Proof**:\n$$\n\\begin{align}\nb &= b \\ast 1 && \\text{[by identity axiom (mul one)]}\\\\\\\\\n&= b \\ast (b^{-1} \\ast b) && \\text{[by left inverse]} \\\\\\\\\n& = (b \\ast b^{-1}) \\ast b && \\text{[by associativity]} \\\\\\\\\n& = b^{-1} \\ast b && \\text{[by the hypothesis]} \\\\\\\\\n& = 1. && \\text{[by left inverse]}\n\\end{align}\n$$\n\u220e\n", "The Lean proof of this result is remarkably similar to the handwritten proof:\n", "(h : \u2200 (a : G), b * a = a) : b = 1\n", "lemma eq_one_of_self_mul_eq (h : \u2200 (a : G), b * a = a) : b = 1 :=\nbegin\n  calc b = b * 1      : by rw mul_one\n  ... = b * (b\u207b\u00b9 * b) : by rw mul_left_inv\n  ... = (b * b\u207b\u00b9) * b : by rw mul_assoc\n  ... = b\u207b\u00b9 * b       : by rw h\n  ... = 1             : by rw mul_left_inv\nend\n", "Above, `calc` indicates that we are starting a proof by calculation. The\nproof for each line of calculation is shown after the colon.\n\nConsider the following two lines from the proof.\n```\n  ... = b * (b\u207b\u00b9 * b) : by rw mul_left_inv\n  ... = (b * b\u207b\u00b9) * b : by rw mul_assoc\n```\nThe second line asserts `b = (b\u207b\u00b9 * b) = (b * b\u207b\u00b9) * b`, the proof of which is: `by rw mul_assoc`\n", "### Tasks\n\n* By hand, write a proof that if $a$ is an element of a group $G$, then $(a^{-1})^{-1} = a$. Use\nonly the group axoims from Lean (in particular, you may not use the 'right inverse' property).\n\n* Complete the Lean 'proof by calculation' below. I've started you off with a suggested first\nline of the proof. You'll need to add intermediate lines and replace all\n`sorry`s with proofs. I suggest working from top to bottom, one line at a time. That way, you\ncan check if your proof is 'structurally correct' as you'll have only a `sorry` warning rather\nthan an error message after each line.\n", "The inverse of the inverse of $a$ is $a$.\n", "end exlean -- hide", "import  group.inv_inv -- hide\n", "# Groups\n\n## Level 2: Right inverse\n", "namespace exlean -- hide\n", "open group -- hide\n", "variables {G : Type*} [group G] (a b c : G) -- hide\n", "In the previous level, we introduced the left inverse axiom for groups. In this level, you'll\n*prove* that the right inverse property follows from the other group axioms.\n\n\n### Tasks\n\n* By hand, write a proof that if $b$ is an element of a group $G$, then $b * b^{-1} = 1$. You may\nuse any axioms or theorems proved in the previous level.\n\n* Complete the Lean 'proof by calculation' below.\n", "$b \\ast b^{-1} = 1$.\n", "end exlean -- hide", "import group.mul_right_inv -- hide\n", "# Groups\n\n## Level 3: Uniqueness of inverse\n", "namespace exlean -- hide\n", "open group -- hide\n", "variables {G : Type*} [group G] {a b c : G} -- hide\n", "In the first level of this world, you saw the 'uniqueness of identity' result. In this level,\nyou'll prove an equivalent 'uniqueness of inverse' result.\n\n\n### Tasks\n\n* By hand, write a proof that if $a, b$ are elements of a group $G$ and if $a \\ast b = 1$, then\n$a^{-1}$ equals $b$. You will only need the group axioms.\n\n* Write a Lean proof by calculation, using only the group axioms.\n", "If $a \\ast b = 1$, then $a^{-1} = b$.\n", "end exlean -- hide", "import group.unique_inverse -- hide\n", "# Groups\n\n## Level 4: The inverse of a product\n", "namespace exlean -- hide\n", "open group -- hide\n", "variables {G : Type*} [group G] (a b c : G) -- hide\n", "### Tasks\n\n* By hand, write a proof that if $a, b$ are elements of a group $G$, then\n$(a \\ast b)^{-1} = b^{-1} \\ast a^{-1}$.\n\n* Complete the Lean proof below.\n", "You've seen `inv_eq_of_mul_eq_one`. This result states that if `s * t = 1`, then `s\u207b\u00b9 = t`.\nHere, you can apply this result, via `apply inv_eq_of_mul_eq_one` to change the\ngoal to one of proving `(a * b) * (b\u207b\u00b9 * a\u207b\u00b9) = 1`.\n\nThis latter goal can be proved by calculation.\n", "A helpful result", "$(a \\ast b)^{-1} = b^{-1} \\ast a^{-1}$.\n", "end exlean -- hide", "import  group.mul_inv_rev -- hide\n", "# Groups\n\n## Level 5: Left cancellation\n", "namespace exlean -- hide\n", "open group -- hide\n", "variables {G: Type* } [group G] {a b c : G}  -- hide\n", "Just as with 'ordinary' multiplication, we can cancel the same factor on the left of\nboth sides of an equation.\n\n### Tasks\n\n* Give a handwritten proof that if $a \\ast b = a \\ast c$, then $b = c$.\n\n* Give a Lean 'proof by calculation' below.\n", "If $a \\ast b = a \\ast c$, then $b = c$.\n", "end exlean -- hide", "import  group.left_cancellation -- hide\n", "# Groups\n\n## Level 6: Injectivity of inverse\n", "namespace exlean -- hide\n", "open group -- hide\n", "variables {G: Type* } [group G] (a b c : G)  -- hide\n", "One way to prove two group elements are equal is to show that their inverses are equal.\n\n### Tasks\n\n* Give a handwritten proof that if $a$ and $b$ are group elements, then\n$a^{-1} = b^{-1} \\leftrightarrow a = b$.\n\n* Give a Lean proof of this result.\n", "Let $a$ and $b$ be elements of a group $G$. We have\n$a^{-1} = b^{-1} \\leftrightarrow a = b$.\n", "end exlean -- hide", "import  group.injectivity_of_inverse -- hide\n", "# Groups\n\n## Level 7: Right cancellation\n", "namespace exlean -- hide\n", "open group -- hide\n", "variables {G: Type* } [group G] (a b c : G)  -- hide\n", "From the left cancellation result, we cheaply prove an iff result.\n", "(a b c : G) : a * b = a * c \u2194 a = b\n", "lemma mul_left_cancel_iff : a * b = a * c \u2194 b = c :=\nbegin\n  split,\n  { assume h : a * b = a * c,\n    show b = c, exact mul_left_cancel h, },\n  { assume h : b = c,\n    show a * b = a * c, rw h,\n  }\nend\n", "### Tasks\n\n* Give a handwritten proof of the right cancellation result, that\n$b \\ast a = c \\ast a \\leftrightarrow b = c$. \n\n* Give a Lean proof of this result.\n", "You can prove this result in a single line of `rw`s. Start with\n`rw [\u2190inv_inj]`.\n", "A one-line proof", "Let $a$ and $b$ be elements of a group $G$. We have\n$b \\ast a = c \\ast a \\leftrightarrow b = c$.\n", "end exlean -- hide", "import  group.right_cancellation -- hide\n", "# Groups\n\n## Level 8: Powers\n", "namespace exlean -- hide\n", "open group -- hide\n", "variables {G: Type* } [group G] {a b c : G} {n m : \u2115} -- hide\n", "Exponentiation is defined to be repeated multiplication. That is, if $a$ is an element of a group\n$G$, then $a^0 := 1$ and $a^{n + 1} := a \\ast a^n$, for a natural number $n$.\n\nThe normal 'laws of indices' apply. That is, if $a : G$ and $n, m : \\mathbb N$, then:\n* $a ^ 0 = 1$,\n* $a ^ 1 = a$,\n* $1 ^ n = 1$,\n* $a ^{n + m} = a ^ n \\ast a*m$,\n* $a^{nm} = (a ^ n) ^ m$.\n", "### Laws of indices in Lean\n\nHere are the laws of indices in Lean.\n* `pow_zero a : a ^ 0 = 1`\n* `pow_one a : a ^ 1 = a`\n* `one_pow n : 1 ^ n = 1`\n* `pow_add a n m : a ^ (n + m) = (a ^ n) * (a ^ m)`\n* `pow_mul a n m : a ^ (n * m) = (a ^ n) ^ m`\n\nThey can be applied as follows.\n", "(a : G) : a ^ 0 = 1\n", "(a : G) : a ^ 1 = a\n", "(n : \u2115) : 1 ^ n = 1\n", "(a : G) (n m : \u2115) : a ^ (n + m) = a ^ n * a ^ m\n", "(a : G) (n m : \u2115) : a ^ (n * m) = (a ^ n) ^ m\n", "example : a ^ 0 = 1 := pow_zero a\nexample : a ^ 1 = a := pow_one a\nexample : (1 : G) ^ n = 1 := one_pow n\nexample : a ^ (n + m) = a ^ n * a ^ m := pow_add a n m\nexample : a ^ (n * m) = (a ^ n) ^ m := pow_mul a n m\n", "As an example, we'll suppose $a^7 = 1$ and find $q$ and $r$ such that $a^26 = a^{7q + r}$ and\nsuch that $0 \\le r < 7$.\n\n**Theorem**: Let $a$ be an element of a group $G$. Suppose $h : a ^ 7 = 1$. Then there exist\nnatural numbers $q$ and $r$ such that $a ^ {26} = a ^r$, where $0 \\le r < 7$.\n\n**Proof**: Take $q$ to be 3 and $r$ to be $5$. We must show both that $a^{26} = a^{7\\times 3 + 5}$\nand that $0 \\le 5 < 7$.\n\nThe first part is proved by calculation.\n$$\n\\begin{align}\na^{26} &= a ^ {7 \\times 3 + 5} && \\text{[trivially]} \\\\\\\\\n&= (a ^ 7) ^ 3 \\ast a ^ 5 && \\text{[by laws of indices]} \\\\\\\\\n&= 1 ^ 3 \\ast a ^ 5  && \\text{[by $h$]} \\\\\\\\\n& = a ^ 5. && \\text{[by laws of indices and the identity axiom]}\n\\end{align}\n$$\nThe second part is easily proved.\n\n\nThe same argument can be written in Lean. The `tidy` tactic here proves `0 \u2264 5 \u2227 5 < 7`.\n", "example (h : a ^ 7 = 1) :\n\u2203 (q r : \u2115), a ^ 26 = a ^ r \u2227 (0 \u2264 r) \u2227 (r < 7) :=\nbegin\n  use [3, 5],\n  split,\n  { calc a ^ 26\n        = a ^ (7 * 3 + 5)     : by trivial\n    ... = (a ^ 7) ^ 3 * a ^ 5 : by rw [pow_add, pow_mul]\n    ... = (1 ^ 3) * a ^ 5     : by rw h \n    ... = a ^ 5               : by rw [one_pow, one_mul] },\n  { tidy, },\nend\n", "### Tasks\n\n* Complete the Lean proof below, closely following the proof above.\n\n* Write a proof of the same result by hand.\n\n", "If $a ^ 8 = 1$, then there exist natural numbers $q$ and $r$ such that $a ^ {39} = a ^ r$ and\n$0 \\le r < 8$.\n", "end exlean -- hide", "import group.powers -- hide\n", "# Groups\n\n## Level 9: Negative powers\n", "namespace exlean -- hide\n", "open group -- hide\n", "variables {G: Type* } [group G] {a b c : G} {n m : \u2124} -- hide\n", "We've seen how to define $a ^ n$ where $a$ is a group element and $n$ is a natural number.\nWe can extend the definition to consider $a ^ m$, where $m$ is an integer.\n\nThere are two possibilities:\n* $m = n$ for a natural number $n$. We then take $a ^ m := a ^ n$.\n* $m = -(n + 1)$ for a natural number $n$. We define $a ^ m = (a ^ (n + 1))^{-1}$.\n\n\n### Laws of indices in Lean\n\nThe laws of indices for integers powers are virtually the same as laws of indices for natural\nnumber powers. Only the names of the results are different.\n\nTaking `n` and `m` to be integers, the laws of indices in Lean are as follows.\n* `one_gpow n : 1 ^ n = 1`\n* `gpow_add a n m : a ^ (n + m) = (a ^ n) * (a ^ m)`\n* `gpow_mul a n m : a ^ (n * m) = (a ^ n) ^ m`\n\nHere they are in action!\n", "(n : \u2124) : 1 ^ n = 1\n", "(a : G) (n m : \u2124) : a ^ (n + m) = a ^ n * a ^ m\n", "(a : G) (n m : \u2124) : a ^ (n * m) = (a ^ n) ^ m\n", "example : (1 : G) ^ n = 1 := one_gpow n\nexample : a ^ (n + m) = a ^ n * a ^ m := gpow_add a n m\nexample : a ^ (n * m) = (a ^ n) ^ m := gpow_mul a n m\n", "As an example, we'll suppose $a^7 = 1$ and find $q$ and $r$ such that $a^{-22} = a^{7q + r}$ and\nsuch that $0 \\le r < 7$.\n\n**Theorem**: Let $a$ be an element of a group $G$. Suppose $h : a ^ 7 = 1$. Then there exist\nintegers $q$ and $r$ such that $a ^ {-20} = a^ {7q + r}$, where $0 \\le r < 7$.\n\n**Proof**: Take $q$ to be $-4$ and $r$ to be $6$. We must show both that $a^{-20} = a^{7\\times (-4) + 6}$\nand that $0 \\le 6 < 7$.\n\nThe first part is proved by calculation.\n$$\n\\begin{align}\na^{-22} &= a ^ {7 \\times (-4) + 6} && \\text{[trivially]} \\\\\\\\\n&= (a ^ 7) ^ (-4) \\ast a ^ 6 && \\text{[by laws of indices]} \\\\\\\\\n& = a ^ 6. && \\text{[by laws of indices, $h$, and the identity axiom]}\n\\end{align}\n$$\nThe second part is easily proved.\n\n\nThe same argument can be written in Lean. The `tidy` tactic here proves `0 \u2264 5 \u2227 5 < 7`.\n", "example (h : a ^ (7 : \u2124) = 1) :\n\u2203 (q r : \u2124), a ^ (-22 : \u2124) = a ^ r \u2227 (0 \u2264 r) \u2227 (r < 7) :=\nbegin\n  use [-4, 6],\n  split,\n  { calc a ^ (-22 : \u2124) = a ^ ((7 : \u2124) * -4 + 6) : by trivial\n    ... = a ^ ((7 : \u2124) * -4) * a ^ (6 : \u2124) : by rw gpow_add\n    ... = a ^ (6 : \u2124) : by rw [gpow_mul, h, one_gpow, one_mul], },\n  { tidy, },\nend\n", "In the proof above, note that we need to specify, on occassion, that the quantities we are\npresenting to Lean are integers, not natural numbers. We do this with a type annotation. \nFor example, `(-22 : \u2124)` is the integer `-22`. If you just type `-22`, Lean will complain that\nyou can't take negatives of natural numbers!\n", "### Tasks\n\n* Complete the Lean proof below, closely following the proof above. I suggest you copy-and-paste\nthe proof and make adjustments as necessary.\n\n* Write a proof of the same result by hand.\n\n", "If $a ^ 8 = 1$, then there exist natural numbers $q$ and $r$ such that $a ^ {39} = a ^ r$ and\n$0 \\le r < 8$.\n", "end exlean -- hide", "Strong Induction", "import tactic.linarith tactic.ring_exp strong_induction.basic -- hide\n", "# Strong Induction\n\n## Level 1: Strong induction\n\n", "namespace exlean -- hide\n", "open_locale classical -- hide\n", "(h\u2081 : P(0))\n(h\u2082 : \u2200 (k : \u2115), (\u2200 m : \u2115, m \u2264 k \u2192 P(m)) \u2192 P (k + 1)) :\n\u2200 (n : \u2115), P(n)\n", "open nat -- hide\n", "Strong induction is used to prove that a predicate $P$ holds for every natural number $n$.\nTo apply strong induction you need to prove:\n* [Base case] $P(0)$\n* [Inductive step] For all $k : \u2115$, $P(k + 1)$ follows from the inductive hypothesis\nthat for all $m : \u2115$, if $m \\le k$, then $P(m)$ holds.\n", "### Strong induction example\n\nA sequence $f : \u2115 \u2192 \u2124$ is defined by $f(0) \u2254 2$, $f(1) \u2254 8$, and\n$f (n + 2) \u2254 8 f(n + 1) - 15 f(n)$.\n", "namespace strong_sequence -- hide\n", "def f : \u2115 \u2192 \u2124 \n| 0 := 2\n| 1 := 8\n| (n + 2) := 8 * f(n + 1) - 15 * f(n)\n", "By strong induction, we'll prove that $f(n) = 3^n + 5^n$, for every natural number $n$.\n", "example (n : \u2115) : f(n) = 3 ^ n + 5 ^ n :=\nbegin\n  let P := \u03bb x, f(x) = 3 ^ x + 5 ^ x, -- The predicate.\n  have base : P 0,\n  { dsimp [P, f], -- Use the definitions of `P` and `f`.\n    norm_num, },\n  have ind_step : \u2200 (k : \u2115), (\u2200 (m : \u2115), m \u2264 k \u2192 P m) \u2192 P (k + 1),\n  { dsimp [P],\n    assume k : \u2115,\n    assume ih : \u2200 (m : \u2115), m \u2264 k \u2192 P m,\n    cases k with p,\n    { refl, },\n    { dsimp [f], -- use the recursive definition of `f`.\n      simp only [succ_eq_add_one] at *, -- replace `succ p` with `p + 1` everywhere.\n      rw ih (p + 1) (by linarith),\n      rw ih p (by linarith),\n      ring_exp, }, }, -- the `ring_exp` proves equations involving variable exponents.\n  apply strong_induction base ind_step,\nend\n", "In the proof above, we start by definining the predicate `P` as an anonymous (or 'lambda') function.\nFor example `\u03bb x, x ^ 2` is the function that sends `x` to `x ^ 2`. We define `P` to be the predicate\nthat takes `x` to the proposition `f(x) = 3 ^ x + 5 ^ x`. Note `\u03bb` is typed `\\la` in Lean.\n\nHaving defined `P`, we prove both the base case (which I've called `base`) and the inductive step\n(which I've called `ind_step`). To conlude, we apply strong induction to these two hypotheses.\n\nIn the inductive step, we introduce the induction variable `k` and the induction hypothesis `ih`.\nNext, in a procedure common to proofs by induction, we consider cases for `k`.\n\nAs `k` is a natural number, either `k = 0` or `k` is the successor of some natural number `p`.\nIn the later case, we make things easy for ourselves by replacing `succ p` with `p + 1`.\n\nNote that we apply the induction hypothesis twice: once to `p + 1` and again to `p`.\n", "### Task\n\nA sequence $g : \\mathbb{N} \\to \\mathbb{Z}$ is defined by $g(0) \u2254 11$, $g(1) \u2254 26$, and\n$g(n + 2) \u2254 5g(n + 1) - 6g(n)$.\n\n* By adapting the proof above, prove that $g(n) = 4 \\times 3 ^ n + 7 \\times 2 ^ n$, for each natural number $n$.\n* Do the same thing by hand.\n", "def g : \u2115 \u2192 \u2124 \n| 0 := 11\n| 1 := 26\n| (n + 2) := 5 * g(n + 1) - 6 * g(n)\n", "$g(n) = 4 \\times 3 ^ n + 7 \\times 2 ^ n$, for each natural number $n$.\n", "end strong_sequence -- hide\n", "end exlean", "import tactic.linarith tactic.ring_exp strong_induction.basic -- hide\n", "# Strong Induction\n\n## Level 2: Strong induction with a different base case\n", "namespace exlean -- hide\n", "open_locale classical -- hide\n", "open nat -- hide\n", "Often we want to prove that a predicate holds for all sufficiently large natural numbers. Here,\nwe'll demonstrate that every natural number $n \\ge 2$ can be expressed in the form $n = 2 s + 3 t$\nfor natural numbers $s$ and $t$.\n\nOne approach to this is to think of the proof as involving strong induction with a base case of 2.\nThis approach requires creating a new and more general version of strong induction.\n\nInstead, our approach is to use the ordinary version of strong induction, but where the predicate\nasserts $n + 2 = 2 s + 3 t$. Clearly, to prove the result is to prove that this predicate holds\nfor *every* natural number.\n\nTo translate between the original formulation and the new one, we use the result `le_iff_exists_add`.\nThis asserts `a \u2264 n` if and only if `\u2203 (c : \u2115), n = a + c`.\n", "example (n a: \u2115) : a \u2264 n \u2194 \u2203 (c : \u2115), n = a + c := le_iff_exists_add\n", "Combining these ideas gives our proof.\n", "example (n : \u2115) (h : 2 \u2264 n) : \u2203 (s t : \u2115), n = 2 * s + 3 * t :=\nbegin\n  rw le_iff_exists_add at h, -- These two lines adjust the predicate\n  rcases h with \u27e8c, rfl\u27e9,     -- for the different base case.\n  let P := \u03bb x, \u2203 (s t : \u2115), 2 + x = 2 * s + 3 * t,\n  have base : P 0,\n  { use [1, 0],\n    norm_num, },\n  have ind_step : \u2200 (k : \u2115), (\u2200 (m : \u2115), m \u2264 k \u2192 P m) \u2192 P (k + 1),\n  { assume k : \u2115,\n    assume ih : \u2200 (m : \u2115), m \u2264 k \u2192 P m,\n    cases k with p,\n    { use [0, 1],\n      norm_num, },\n    have hPp : P p,\n    { apply ih p,\n      simp only [succ_eq_add_one], \n      linarith, },\n    rcases hPp with \u27e8s, t, hst\u27e9,\n    use [s + 1, t],\n    simp only [succ_eq_add_one, \u2190add_assoc, hst],\n    ring, },\n  apply strong_induction base ind_step,\nend\n", "Every natural number $n$ at least 8 can be expressed as $n = 3s + 5t$ for natural numbers $s$\nand $t$.\n", "end exlean -- hide", "import data.set.basic strong_induction.basic tactic.linarith -- hide\n", "# Strong Induction\n\n## Level 3: Minimal elements\n", "namespace exlean -- hide\n", "Let $S$ be a set of natural numbers. A natural number $n$ is said to be a _minimal element_ of $S$\nif $n \\in S$ and for every every $m \\in S$, $n \\le m$.\n", "example (n : \u2115) (S : set \u2115) (h : min_element n S ) :\nn \u2208 S \u2227 (\u2200 (m : \u2115), m \u2208 S \u2192 n \u2264 m) := h\n", "namespace min_element_example -- hide\n", "Let the function $f : \\mathbb N \\to \\mathbb N$ be given by $f(x) = 5 x + 7$ and let $T$ be the set\nof natural numbers $x$ for which $f(x) \\ge 400$.\n", "def f (x : \u2115) := 5 * x + 7\ndef T : set \u2115 := {x : \u2115 | f x \u2265 400}\n", "We'll show that $79$ is a minimal element of $T$. To do this, we split the target into two goals:\n1. to prove $79 \\in T$ and\n2. to prove that every element of $T$ is at least $79$.\n", "example : min_element 79 T :=\nbegin\n  split, \n  { dsimp [T, f], -- We must show `5 * 79 + 7 \u2265 400`.\n    norm_num, }, -- This follows by arithmetic.\n  { dsimp [T, f], -- `\u22a2 \u2200 (m : \u2115), 5 * m + 5 \u2265 400 \u2192 79 \u2264 m`.\n    assume m : \u2115,\n    assume h : m \u2208 T,\n    linarith, },\nend\n", "end min_element_example -- hide\n", "variables {S : set \u2115} {x y : \u2115} -- hide\n", "### Task\n\nProve uniquenss of minimal element. For this level, you won't need induction.\n", "The Lean lemma `le_antisymm` asserts that `x = y` follows given `x \u2264 y` and `y \u2264 x`.\n", "A useful lemma on inequalities", "If a set $S$ of natural numbers has a minimal element, then that element is unique.\n", "end exlean -- hide", "import data.set.basic strong_induction.basic -- hide\n", "# Strong Induction\n\n## Level 4: The Well Ordering Principle\n", "namespace exlean -- hide\n", "open_locale classical -- hide\n", "open set nat --hide\n", "In the previous level, we show that if a set $S$ of natural numbers has a minimal element, then\nthat element is unique.\n\nIn this level, you'll show that every non-empty set of natural numbers has a minimal element. The\n(challenging) proof requires strong induction.\n", "### Nonempty sets\n\nIn Lean, a set `S` is nonempty if `\u2203 x, x \u2208 S`.\n\nAs an example, consider the set $\\\\{x : \\mathbb N \\mid x ^ 2 + 2x + 15 = 0\\\\}$. We'll show this set\nis nonempty.\n", "example : set.nonempty {x : \u2115 | x * x + 2 * x = 15} :=\nbegin\n  use 3,  -- `\u22a2 3 \u2208 {x : \u2115 | x ^ 2 + 2 * x = 15}`\n  rw mem_set_of_eq, -- `\u22a2 3 ^ 2 + 2 * 3 = 15`\n  refl,\nend\n", "Start with proof by contradiction. Type `by_contra h\u2081`.\nThen push the negation through the quantifiers with `push_neg at h\u2081`.\n", "How to start!", "If you've taken the hint above, your goal now will be to prove `false`. This isn't evidently \nsomething amenable to strong induction!\n\nHowever, you can show that it suffices to prove `\u2200 (x : \u2115), x \u2209 S` by filling in the sorry below.\n```\nsuffices hs : \u2200 (x : \u2115), x \u2209 S,\n{ sorry, },\n```\nThis leaves you with the goal of proving, by strong induction, that `\u2200 (x : \u2115), x \u2209 S`.\n", "How to introduce strong induction", "If a goal can be proved in a fairly straightforward manner from the assumptions, the `tidy` tactic\ncan sometimes find a proof.\n", "At some point in your proof you may need to use the fact that `m < (succ n) \u2194 m \u2264 n`. This result\nis called `lt_succ_iff`.\n", "A crucial inequality result", "Every nonempty set of natural numbers has a minimal element.\n", "end exlean -- hide", "Divisibility", "import tactic.ring -- hide\n", "#  Divisibility\n\n## Level 1: The definition of divisibility\n\nThe notation `x \u2223 y` means `\u2203 (m : \u2124), y = x * m`. Here, the symbol, `\u2223` is typed `\\|` or `\\mid`.\n", "namespace exlean -- hide\n", "def myint_dvd : \u2124 \u2192 \u2124 \u2192 Prop := \u03bb (x y : \u2124), \u2203 (m : \u2124), y = x * m -- hide\n", "If you forget this definition or ever want to replace `x \u2223 y` with the definition in a proof, use\nthe result `dvd_def`.\n", "variables {x y : \u2124} -- hide\n", "x \u2223 y \u2194 \u2203 (m : \u2124), y = x * m\n", "lemma dvd_def : x \u2223 y \u2194 \u2203 (m : \u2124), y = x * m := by refl -- hide\n", "For example, we will prove that `5 \u2223 10`. In the (unecessary) first line of the proof, we rewrite\n`5 \u2223 10` using the definition of divisibility to give `\u2203 (m : \u2124), 10 = 5 * m`. \n\nIt remains to *find* an `m` that works. Let's use `2`. After that, we must prove `10 = 5 * 2`. But\nthis follows by definition of multiplication. A `norm_num` proof works.\n", "If the goal is `\u22a2 \u2203 (x : \u03b1), P x` and if `y : \u03b1`, then `use y` changes the goal to\n`\u22a2 P y`.\n\n### Example\nWith a goal `\u22a2 \u2203 (x : \u2124), x + 5 = 23`, typing `use 18` changes the goal to `\u22a2 18 + 5 = 23`.\n", "example : (5 : \u2124) \u2223 10 :=\nbegin\n  rw dvd_def,\n  use 2,\n  norm_num,\nend\n", "\nThe `norm_num` tactic proves numerical goals. For example, it will close the goal\n`\u22a2 10 * 3 + 5 = 37 - 7`\n", "If you were to write the proof 'by hand', you might write the following:\n\n> By definition, it suffices to show there exists an integer `m` such that `10 = 5 * m`.\n> Take `2` for `m`. Then we must show `10 = 5 * 2`.\n> This is true by arithmetic.\n", "### Tasks\n* By making a minor variation to the proof above, show that `6 \u2223 72`.\n\n* Write the same proof by hand.\n", "`6 divides 72`\n", "end exlean -- hide", "import tactic.linarith divisibility.dvd_definition -- hide\n", "#  Divisibility\n\n## Level 2: Reflexivity of divisibility\n", "namespace exlean --hide\n", "In this short level, your task is to prove reflexvity of the divisiblity relation.\n", "You can use `rw dvd_def` to replace `x \u2223 y` with its definition.\n", "Using the definition of divisibility", "`a \u2223 a`, for every integer `a`.\n", "end exlean -- hide", "import tactic.linarith divisibility.dvd_refl -- hide\n", "#  Divisibility\n\n## Level 3: Every number is a factor of zero\n", "namespace exlean --hide\n", "### Task\nProve that every number is a factor of zero.\n", "Let `a` be an integer. Then `a \u2223 0`.\n", "end exlean -- hide", "import tactic.linarith divisibility.dvd_zero -- hide\n", "#  Divisibility\n\n## Level 4: A multiplication lemma\n", "namespace exlean --hide\n", "In the last level, you *proved* a divisibility statement. In this level, you'll *decompose* given\ndivisibility statements.\n\nTo prove a statement of the form `x \u2223 y` is to prove an existentially-quantified statement, by\nexists introduction (the `use` tactic in Lean).\n\nOn the other hand, a given divisibility statement `h : a \u2223 b` represents the\nexistentially-quantified statement `h : \u2203 (m : \u2124), b = a * m`. We decompose this to an integer `k`\nand a hypothesis `h\u2082 : b = a * k` via `cases h with m h\u2082`. In handwritten mathematics, this\nis exists elimination.\n", "### An addition result\n\nBelow, I present a proof that given `h\u2081 : a \u2223 b` and `h\u2082 : a \u2223 c`, then `a \u2223 b + c` follows.\n", "variables {a b c d : \u2124} -- hide\n", "(h\u2081 : a \u2223 b) (h\u2082 : a \u2223 c) : a \u2223 b + c\n", "theorem dvd_add (h\u2081 : a \u2223 b) (h\u2082 : a \u2223 c) : a \u2223 b + c :=\nbegin\n  cases h\u2081 with m\u2081 h\u2083, -- We have `m\u2081 : \u2124` and `h\u2083 : b = a * m\u2081`.\n  cases h\u2082 with m\u2082 h\u2084, -- We have `m\u2082 : \u2124` and `h\u2084 : c = a * m\u2082`.\n  rw dvd_def, -- `\u22a2 \u2203 (m : \u2124), b + c = a * m`.\n  use (m\u2081 + m\u2082), -- Take `m\u2081 + m\u2082` for `m`.\n  rw [h\u2083, h\u2084], -- From `h\u2083` & `h\u2084`, `\u22a2 a * m\u2081 + a * m\u2082 = a * (m\u2081 + m\u2082)`.\n  linarith, -- This holds by algebra.\nend\n", "`cases` is a general-purpose elimination tactic. It it used to 'decompose' a hypothesis into\nits constituent parts.\n\n### Examples\n\n* Given `h : \u2203 (x : \u2124), x + 5 = y`, typing `cases h with m h\u2082` replaces `h` with `m : \u2124` and\n`h\u2082 : m + 5 = y`.\n\n* Given `h : p \u2227 q`, typing `cases h with hp hq` replaces `h` with `hp : p` and `hq : q`.\n\n* Given `h : p \u2228 q`, typing `cases h with hp hq` replaces the current goal with two goals\n(1) in which `h` is replaced with `hp : p` and (2) in which `h` is replaced with `hq : q`.\n\n* Given `x : \u2115`, typing `cases x with k` replaces the goal with two new goals: (1) a goal in which\nevery occurence of `x` is replaced with `0` and (2) a goal with a new variable `k : \u2115` and in \nwhich every occurrence of `x` is replaced with `succ k`.\n", "`linarith` proves many 'algebraic' equations and inequalities. For example, it can prove\n`(x + y) ^ 2 = x ^ 2 + 2 * x * y + y ^ 2`. It can pr\n", "Extracing the comments from the above gives a handwritten proof:\n\n> We have `m\u2081 : \u2124` and `h\u2083 : b = a * m\u2081`.\n>\n> We have `m\u2082 : \u2124` and `h\u2084 : c = a * m\u2082`.\n>\n> We must show `\u2203 (m : \u2124), b + c = a * m`.\n>\n> Take `m\u2081 + m\u2082` for `m`. We must show `b + c = a * (m\u2081 + m\u2082)`.\n>\n> From `h\u2083` and `h\u2084`, we must show `a * m\u2081 + a * m\u2082 = a * (m\u2081 + m\u2082)`.\n>\n> This holds by algebra.\n", "### Tasks\n* Adapting the Lean proof above, show that if `h : a \u2223 b`, then `a \u2223 b * c` for all integers `c`.\n\n* Write the same proof by hand.\n", "Let `a, b` be integers. Given `h : a \u2223 b`, we have `a \u2223 b * c`, for all integers `c`.\n", "end exlean -- hide", "import tactic.linarith divisibility.dvd_mul_of_dvd_left -- hide\n", "#  Divisibility\n\n## Level 5: Numbers divisible by zero\n", "namespace exlean --hide\n", "Which numbers are divisible by zero? You'll prove that a number is divisible by zero if and only \nif that number is itself zero.\n", "### Tasks\n* By applying some of the results above, prove that if `a \u2223 b` and `a \u2223 c`, then `a` divides any\nlinear combination of `b` and `c`. That is, `a \u2223 b * s + c * t`, for all integers `s` and `t`. \n\n* Write the same proof by hand.\n", "If you were writing this proof by hand, you might start by saying that it suffices (by `dvd_add`)\nto prove `a \u2223 b * s` and `a \u2223 c * t`. To do this in Lean, type `apply dvd_add`. Here's an\nexample of this kind of reasoning.\n", "variables {a : \u2124} -- hide\n", "lemma zero_dvd_iff : 0 \u2223 a \u2194 a = 0 :=\nbegin\n  split,\n  { assume h : 0 \u2223 a,\n    cases h with m h,\n    linarith, },\n  { assume h : a = 0,\n    rw h, },\nend\n", "end exlean -- hide", "import tactic.linarith divisibility.zero_dvd_iff-- hide\n", "#  Divisibility\n\n## Level 6: A second multiplication lemma\n", "namespace exlean --hide\n", "variables {a b c d : \u2124} -- hide\n", "### Tasks\n* Adapting the Lean proof of `dvd_add` from a previous level, show that if `h\u2081 : a \u2223 b` and `h\u2082 : c \u2223 d`, then\n`a * c \u2223 b * d`.\n\n* Write the same proof by hand.\n", "### Typing subscripts\n\nIn Lean, type `h\u2081` as `h\\1`.\n", "Let `a, b, c, d` be integers. Given `h\u2081 : a \u2223 b` and `h\u2082 : c \u2223 d`, we have `a * c \u2223 b * d`.\n", "end exlean -- hide", "import tactic.linarith divisibility.mul_dvd_mul -- hide\n", "#  Divisibility\n\n## Level 7: Divisibility of linear combinations\n", "namespace exlean --hide\n", "Here are some of the properties of the divisibility relation that you've seen so far:\n\n* [Definition] `a \u2223 b` means `\u2203 (m : \u2124), b = a * m`.\n\n* [Reflexivity] `dvd_refl : a \u2223 a`.\n\n* `dvd_add` given `h\u2081 : a \u2223 b` and `h\u2082 : a \u2223 c`, we have `a \u2223 b + c`.\n\n* `dvd_mul_of_dvd_left` given `h : a \u2223 b`, we have `a \u2223 b * c`, for any `c : \u2124`.\n\n", "### Tasks\n* By applying some of the results above, prove that if `a \u2223 b` and `a \u2223 c`, then `a` divides any\nlinear combination of `b` and `c`. That is, `a \u2223 b * s + c * t`, for all integers `s` and `t`. \n\n* Write the same proof by hand.\n", "If you were writing this proof by hand, you might start by saying that it suffices (by `dvd_add`)\nto prove `a \u2223 b * s` and `a \u2223 c * t`. To do this in Lean, type `apply dvd_add`. Here's an\nexample of this kind of reasoning.\n", "variables {a b c d s t : \u2124} -- hide\n", "example (h\u2081 : a \u2223 b) (h\u2082 : a \u2223 c) (h\u2083 : a \u2223 d) : a \u2223 (b + c) + d :=\nbegin\n  apply dvd_add, -- 2 goals `\u22a2 a \u2223 b + c` and `\u22a2 a \u2223 d`\n  { -- 1) `\u22a2 a \u2223 b + c` \n    apply dvd_add, -- 2 goals `\u22a2 a \u2223 b` and `\u22a2 a \u2223 c`\n    { -- 1.1) `\u22a2 a \u2223 b`\n      exact h\u2081, }, -- This follows from `h\u2081`.\n    { -- 1.2) `\u22a2 a \u2223 c`\n      exact h\u2082, }, }, -- This follows from `h\u2082`.\n  { -- 2) `\u22a2 a \u2223 d`.\n    exact h\u2083, }, -- This follows from `h\u2083`.\nend\n", "Most theorems have conditions under which they hold. For example, `dvd_add` states that\n`a \u2223 b + c` given the conditions `a \u2223 b` and `a \u2223 c`. If the target is `\u22a2 a \u2223 b + c`, then\ntyping `apply dvd_add` creates two new goals: (1) to prove `a \u2223 b` and (2) to prove `a \u2223 c`.\n\nThe use of `apply` can be shortened. If the hypotheses `h\u2081 : a \u2223 b` and `h\u2082 : a \u2223 c` are in the\ncontext, then the target `a \u2223 b + c` can be proved with `apply h\u2081 h\u2082`.\n", "Given `h\u2081 : a \u2223 b` and `h\u2082 : a \u2223 c`, we have `a \u2223 b * s + c * t`, for all integers `s` and `t`.\n", "end exlean -- hide", "import tactic.linarith divisibility.dvd_mul_add_mul-- hide\n", "#  Divisibility\n\n## Level 8: Transtivity of divisibility\n", "namespace exlean --hide\n", "variables {a b c : \u2124} -- hide\n", "Let `a, b, c, d` be integers. Given `h\u2081 : a \u2223 b` and `h\u2082 : c \u2223 d`, we have `a * c \u2223 b * d`.\n", "end exlean -- hide", "import tactic.linarith divisibility.dvd_trans  -- hide\n", "# Divisibility\n\n## Level 9: Antisymmetry\n", "namespace exlean -- hide\n", "open int -- hide\n", "The divisibility relation is antisymmetric.\nThat is, suppose `a` and `b` are non-negative integers such that `a \u2223 b`, and `b \u2223 a`, then `a = b`.\n", "variables {a b c d : \u2124} -- hide\n", "a = b\n", "theorem dvd_antisymm (H1 : 0 \u2264 a) (H2 : 0 \u2264 b) : a \u2223 b \u2192 b \u2223 a \u2192 a = b :=  -- hide\n", "dvd_antisymm H1 H2                                                        -- hide\n", "example (h\u2081 : 0 \u2264 a) (h\u2082 : 0 \u2264 b) (h\u2083 : a \u2223 b) (h\u2084 : b \u2223 a) : a = b :=\nbegin\n  exact dvd_antisymm h\u2081 h\u2082 h\u2083 h\u2084,\nend\n", "In this level, we'll prove an if and only if (`\u2194`) statement. To split an `\u2194` statement into two\nimplications, use the `split` tactic.\n\nIn the example below, the initial goal is $\\vdash a = 2b + c \\iff c = a - 2b$. After using the\n`split` tactic, we have two new goals: (1) $\\vdash a = 2b + c \\to c = a - 2b$ and \n(2) $\\vdash c = a - 2b \\to a = 2b + c$.\n", "example : a = 2 * b + c \u2194 c = a - 2 * b :=\nbegin\n  split, \n  { -- 1) `\u22a2 a = 2 * b + c \u2192 c = a - 2 * b`.\n    assume h : a = 2 * b + c, -- `\u22a2 c = 2 * b - a`\n    linarith, },\n  { -- 2) `\u22a2 c = a - 2 * b \u2192 a = 2 * b + c`.\n    assume h : c = a - 2 * b,\n    linarith, },\nend\n", "\nThe `split` tactic splits a 'compound' target into multiple goals. \n\nFor example, `split` turns the target `\u22a2 p \u2194 q` into two goals: (1) to prove\n`p \u2192 q` and (2) to prove `q \u2192 p`.\n\nEqually, if the target is `\u22a2 p \u2227 q`, then `split` creates goals (1) `\u22a2 p` and (2) `\u22a2 q`.\n", "\nSuppose `P` is a predicate. Recall that if `h : \u2200 (x : \u03b1), P(x)` and if `y : \u03b1`, then\n`specialize h y` replaces `h` with `P(y)`.\n", "Specialzing a universally-quantified statement.", "\nSuppose `h : p \u2194 q`. Then the tactic `cases h with h\u2082 h\u2083` replaces `h` with `h\u2082 : p \u2192 q` and\n`h\u2083 : q \u2192 p`.\n", "Decomposing a `\u2194` statement.", "Given `d` is a common divisor of `a` and `b` and given `c \u2223 d`, we have `c` is a common divisor of\n`a` and `b`.\n", "end exlean -- hide", "import tactic.linarith divisibility.dvd_antisymm  -- hide\n", "# Divisibility\n\n## Level 10: Common divisor basics\n", "namespace exlean -- hide\n", "Let `m, n, and d` be integers. For `d` to be a _common divisor_ of `m` and `n` means that\n`d \u2223 m` and `d \u2223 n`.\n", "def common_divisor (d m n : \u2124) := (d \u2223 m) \u2227 (d \u2223 n)\n", "Using the above definition, we'll show that `5` is a common divisor of `20` and `30`.\n", "example : common_divisor 5 20 30 :=\nbegin\n  split, -- We'll show 1) `5 \u2223 20` and 2) `5 \u2223 30`.\n  { use 4,  -- 1) `\u22a2 5 \u2223 20`, it suffices to show `20 = 5 * 4`.\n    norm_num, }, -- This holds by arithmetic.\n  { use 6,  -- 2) `\u22a2 30 = 5 * 6`, it suffices to show `\u22a2 30 = 5 * 6`.\n    norm_num, }, -- This holds by arithmetic.\nend\n", "### Tasks\n\n* Adapt the Lean proof above to show that `4` is a common divisor of `48` and `60`.\n\n* Give a handwritten proof of the same result.\n\n", "`4` is a common divisor of `48` and `60`.\n", "end exlean -- hide", "import tactic.linarith divisibility.common_divisors  -- hide\n", "# Divisibility\n\n## Level 11: Common divisor results\n", "namespace exlean -- hide\n", "### Tasks\n\nIn this level, you'll *decompose* the hypothesis that `d` is a common divisor of `a` and `b` to\nprove that `c` is a common divisor of `a` and `b`, under the hypothesis that `c \u2223 d`.\n\nAs `common_divisor d a b` is a conjunctive (an 'and') statement, it can be decomposed into\nits constituent parts using the `cases` tactic. See the example below.\n", "variables {d a b c s t : \u2124} -- hide\n", "example (h\u2081 : common_divisor d a b) : common_divisor d a (a * s + b * t) :=\nbegin\n  rw common_divisor at h\u2081, -- `h\u2081 : (d \u2223 a) \u2227 (d \u2223 b)`\n  cases h\u2081 with hda hdb, -- `hda : d \u2223 a`, `hdb : d \u2223 b`.\n  rw common_divisor, -- `\u22a2 (d \u2223 a) \u2227 (d \u2223 a * s + b * t)`\n  split, -- 2 goals: (1) `\u22a2 d \u2223 a` and (2) `\u22a2 d \u2223 a * s + b * t`.\n  { exact hda, }, -- (1) follows from `hda`\n  { apply dvd_mul_add_mul hda hdb, }, -- (2) follows from\n  -- our previous result on divisibility of linear combinations.\nend\n", "Given `d` is a common divisor of `a` and `b` and given `c \u2223 d`, we have `c` is a common divisor of\n`a` and `b`.\n", "end exlean -- hide", "import tactic.linarith divisibility.common_divisors2  -- hide\n", "# Divisibility\n\n## Level 12: Greatest common divisors\n", "namespace exlean -- hide\n", "open int -- hide\n", "Recall that for `d` to be a common divisor of `a` and `b` means that `d \u2223 a` and `d \u2223 b`.\n\nFor `d` to be a _greatest common divisor_ of `m` and `n` means that\n* `d` is a common divisor of `m` and `n` and\n* if `e` is a common divisor of `m` and `n`, then `e \u2223 d`.\n", "def greatest_common_divisor (d m n : \u2124) := (common_divisor d m n) \u2227 \n  (\u2200 (e : \u2124), common_divisor e m n \u2192 e \u2223 d)\n", "### Task\n\nShow that if the non-negative integers `d` and `e` are both greatest common divisors of `m` and `n`,\nthen `d = e`.\n", "variables {d e m n : \u2124} -- hide\n", "Recall that `apply dvd_antisymm k\u2081 k\u2082,` will reduce the goal to two goals (1) `\u22a2 d \u2223 e` and\n(2) `\u22a2 e \u2223 d`.\n", "Proving an equality", "If the non-negative integers `d` and `e` are both greatest common divisors of `m` and `n`,\nthen `d = e`.\n", "end exlean -- hide", "import tactic.linarith divisibility.gcd_uniqueness -- hide\n", "# Divisibility\n\n## Level 13: Greatest common divisor of an integer and zero\n", "namespace exlean -- hide\n", "open int -- hide\n", "Recall that `greatest_common_divisor d a b` is a conjunctive statement. Thus, you can\nsplit the goal in two using the `split` tactic.\n", "Starting the proof", "`a` is a greatest common divisor of `a` and `0`, for every integer `a`.\n", "end exlean -- hide", "import tactic.linarith divisibility.gcd_zero -- hide\n", "# Divisibility\n\n## Level 14: Commutativity of greatest common divisor\n", "namespace exlean -- hide\n", "open int -- hide\n", "variables {a b d : \u2124} -- hide\n", "If $d$ is a greatest common divisor of $a$ and $b$, then $d$ is a greatest common divisor of\n$b$ and $a$.\n", "end exlean -- hide", "import tactic.linarith divisibility.gcd_comm  -- hide\n", "# Divisibility\n\n## Level 15: Division\n", "namespace exlean -- hide\n", "open int -- hide\n", "The division lemma states that if `a` and `b` are integers with `b \u2260 0`, then there exist integers\n`q` and `r` for which `a = b * q + r` and `0 \u2264 r < |b|`.\n\nThe quantity `q` is called the quotient and `r` is called the remainder.\n", "variables (a b : \u2124) -- hide\n", "lemma division (h : b \u2260 0) : \u2203 (q r : \u2124), a = b * q + r \u2227 (0 \u2264 r \u2227 r < abs b) :=     -- hide\n", "\u27e8a/b, a % b, by rw [add_comm, mod_add_div a b], mod_nonneg a h, mod_lt a h\u27e9  -- hide\n", "example (h : b \u2260 0) : \u2203 (q r : \u2124), 700 = b * q + r \u2227 (0 \u2264 r \u2227 r < abs b) :=\nbegin\n  apply division 700 b h,\nend\n", "variables {q\u2081 r\u2081 q\u2082 r\u2082 : \u2124} -- hide\n", "In this (somewhat tricky) level, your task is to show uniquness of the quotient and remainder.\nYou may freely use the following lemma.\n", "lemma abs_sub_lt {x y c : \u2124} (h\u2081 : 0 \u2264 x \u2227 x < c) (h\u2082 : 0 \u2264 y \u2227 y < c) : abs (x - y) < c :=\nbegin\n  rw abs_sub_lt_iff,\n  split;\n  linarith,\nend\n", "Other useful results include:\n\n* `abs_mul : abs (a * b) = (abs a) * (abs b)`\n* `abs_nonneg : 0 \u2264 abs a`\n* `le_mul_of_one_le_right : 0 \u2264 b \u2192 1 \u2264 a \u2192 b \u2264 b * a`.\n", "At some point in your proof, you'll need to consider separately the cases `q\u2081 = q\u2082` and `q\u2081 \u2260 q\u2082`.\nYou can do this with `by_cases h : q\u2081 = q\u2082` (replacing `h` with whatever name you like).\n", "Proof by cases", "Let $a, b$ be integers with $b \u2260 0$. If $a = b q_1 + r_1 = b q_2  + r_2$, where\n$0 \\le r_1 < |b|$ and $0 \\le r_2 < |b|$, then $q_1 = q_2$ and $r_1 = r_2$.\n", "end exlean -- hide", "import tactic.linarith divisibility.division -- hide\n", "# Divisibility\n\n## Level 16: Non-divisibility examples\n", "namespace exlean -- hide\n", "In any particular numerical example, it's easy to show divisibility. For example, here's a proof\nthat $7 \\mid 42$.\n", "example : (7 : \u2124) \u2223  42 :=\nbegin\n  use 6,\n  norm_num,\nend\n", "But how can we prove non-divisibility? How would you prove $7 \\nmid 31$?\n\nThe idea is to use the uniqueness of division result. Suppose (for a contradiction), that\n$h: 7 \\mid 31$. Decomposing $h$ gives $m : \\mathbb Z$ and $h : 31 = 7m = 7m + 0$.\n\nBut (as you may easily verify), we have $h_2 : 31 = 7 \\times 4 + 3$.\n\nUsing $h$ and $h_2$ in the uniquness of division result, we infer $m = 4$ and $0 = 3$. This\nlatter is a contradiction.\n", "Here we use the semi-colon `;` 'tactic combinator'. This is a time-saving measure that applies\nthe following tactic to each remaining goal. In our application, the tactic `tidy` is used\nto complete each of the three goals that arise from the application of `division_unique 31 7`.\n", "example : \u00ac((7 : \u2124) \u2223 31) :=\nbegin\n  assume h : (7 : \u2124) \u2223 31,\n  cases h with m h, -- We have `m : \u2124` and `h : 31 = 7 * m`.\n  have h\u2081 : (31 : \u2124) = 7 * m + 0, linarith,\n  have h\u2082 : (31 : \u2124) = 7 * 4 + 3, norm_num,\n  have k\u2081 : m = 4 \u2227 (0 : \u2124) = 3,\n  { apply division_unique 31 7;\n    tidy, },\n  linarith, -- `k\u2081` gives a contradiction.\nend\n", "5 does not divide sixty-two.\n", "end exlean -- hide", "import tactic.linarith divisibility.basic_bezout strong_induction.well_ordering_principle -- hide\n", "# Divisibility\n\n## Level 17: B\u00e9zout's lemma (version 1)\n", "namespace exlean -- hide\n", "open int gcd_set -- hide\n", "variables {a b : \u2124} {k : \u2115} -- hide\n", "open gcd_set -- hide\n", "Let $a$ and $b$ be integers. B\u00e9zout's lemma asserts that there exists an integer $d$ such that\n$d$ is a greatest common divisor of $a$ and $b$ and such that $d = as + bt$, for some integers \n$s$ and $t$.\n\nIn this level, you'll prove B\u00e9zout's lemma via the well-ordering principle. If you haven't already\ndone so, please try the level on the well-ordering principle from the 'Strong Induction' world.\n\nThe proof contains several components. First, we need to consider the set\n$\\\\{y : \\mathbb N \\mid (0 < y) \\land (\\exists (s\\ t\\ : \\mathbb Z),\\, |a s + b t|  = y)\\\\}$.\n\nWe call this set `set_T a b`. You'll need to use the following lemmas concerning this set.\n* `lin_combo_of_min_element`\n* `dvd_of_min_element`\n* `set_T_nonempty`\n\nThe use of these lemmas is shown below.\n", "example (h : min_element k (set_T a b)) : \u2203 (x y : \u2124), a * x + b * y = k :=\nbegin\n  exact lin_combo_of_min_element h,\nend\n", "\n", "example (h : min_element k (set_T a b)) : \u2191k \u2223 a :=\nbegin\n  exact dvd_of_min_element a b k h,\nend\n", "\n", "example (h : a \u2260 0) : (set_T a b).nonempty :=\nbegin\n  exact set_T_nonempty h,\nend\n", "Over to you!\n", "B\u00e9zout's lemma (version 1). Every pair of integers $a$ and $b$ has a greatest common divisor $d$\nthat can be written as $d = as + bt$, for some integers $s$ and $t$.\n", "end exlean -- hide", "import tactic.linarith divisibility.bezout -- hide\n", "# Divisibility\n\n## Level 18: The negative of a greatest common divisor\n", "namespace exlean -- hide\n", "Suppose $d$ is a greatest common divisor of $a$ and $b$. Then $-d$ is also a greatest common\ndivisor of $a$ and $b$.\n\nThe following results on divisibility will be useful.\n", "open int -- hide\n", "variables {a b d : \u2124} -- hide\n", "(h : d \u2223 a) : -d \u2223 a\n", "lemma neg_dvd_of_dvd (h : d \u2223 a) : -d \u2223 a :=\nbegin\n  cases h with m h\u2082, -- `h\u2082 : a = d * m`\n  use -m, -- `\u22a2 a = -d * -m`,\n  rw h\u2082, -- `\u22a2 d * m = -d * -m`,\n  ring, -- This follows by algebra.\nend\n", "-d \u2223 a \u2194 d \u2223 a\n", "lemma neg_dvd : -d \u2223 a \u2194 d \u2223 a :=\nbegin\n  split,\n  { assume h : -d \u2223 a,\n    rw \u2190neg_neg d,\n    exact neg_dvd_of_dvd h, },\n  { assume h : d \u2223 a,\n    exact neg_dvd_of_dvd h, },\nend\n", "(h : d \u2223 a) : d \u2223 -a\n", "lemma dvd_neg_of_dvd (h : d \u2223 a) : d \u2223 -a :=\nbegin\n  cases h with m h\u2082, -- `h\u2082 : a = d * m`\n  use -m, -- `\u22a2 - a = d * -m`,\n  rw h\u2082, -- `\u22a2 -(d * m) = d * -m`,\n  ring, -- This follows by algebra.\nend\n", "Suppose $d$ is a greatest common divisor of $a$ and $b$. Then $-d$ is also a greatest common\ndivisor of $a$ and $b$.\n", "end exlean -- hide", "import tactic.linarith divisibility.gcd_neg -- hide\n", "# Divisibility\n\n## Level 19: B\u00e9zout's lemma (version 2)\n", "namespace exlean -- hide\n", "You'll show that for all integers $a$ and $b$, there exists a non-negative integer $d$ such that\n$d$ is a greatest common divisor of $a$ and $b$.\n", "open int -- hide\n", "variables (a b : \u2124) -- hide\n", "The lemma `nonneg_or_nonneg_neg'` will be useful.\n", "example : 0 \u2264 a \u2228 0 \u2264 -a := nonneg_or_nonneg_neg' a\n", "For all integers $a$ and $b$, there exists a non-negative integer $d$ such that\n$d$ is a greatest common divisor of $a$ and $b$.\n", "end exlean -- hide", "import tactic.linarith divisibility.bezout2  -- hide\n", "# Divisibility\n\n## Level 20: The Euclidean algorithm - basic step\n", "namespace exlean -- hide\n", "As a result of B\u00e9zout's lemma, we can define a function `gcd` such that `gcd a b` is\nthe greatest common divisor of `a` and `b`.\n", "noncomputable theory -- hide\n", "lemma gcd_exists (a b : \u2124) : \u2203 (d : \u2124), (greatest_common_divisor d a b \u2227 0 \u2264 d) :=\nbegin\n  rcases bezout a b with \u27e8d, s, t, h, h\u2082, h\u2083\u27e9,\n  exact \u27e8d, h, h\u2082\u27e9,\nend\n", "noncomputable def gcd (a b : \u2124) := classical.some (gcd_exists a b) -- hide\n", "noncomputable def egcd (a b : \u2124) := classical.some (bezout a b) -- hide\n", "(greatest_common_divisor (gcd a b) a b) \u2227 (0 \u2264 gcd a b)\n", "lemma greatest_common_divisor_gcd (a b : \u2124) : (greatest_common_divisor (gcd a b) a b) \u2227 (0 \u2264 gcd a b) := -- hide\n", "begin -- hide\n", "  apply @classical.some_spec _ (\u03bb d, (greatest_common_divisor d a b) \u2227 (0 \u2264 d)), -- hide\n", "end -- hide\n", "example (a b : \u2124) : \u2203 (s t : \u2124), (greatest_common_divisor (egcd a b) a b) \u2227 (0 \u2264 egcd a b) \u2227 (egcd a b = a * s + b * t):= -- hide\n", "begin -- hide\n", "  apply @classical.some_spec _ (\u03bb d, \u2203 s t, (greatest_common_divisor d a b) \u2227 (0 \u2264 d) \u2227 d = a * s + b * t), -- hide\n", "end -- hide\n", "The lemma `greatest_common_divisor_gcd` asserts that `gcd a b` is a greatest common divisor of `a`\nand `b` and that `0 \u2264 gcd a b`\n", "example (a b : \u2124) : (greatest_common_divisor (gcd a b) a b) \u2227 (0 \u2264 gcd a b)\n:= greatest_common_divisor_gcd a b\n", "open int -- hide\n", "variables {a : \u2124}  -- hide\n", "Suppose $a$, $b$, $q$, $r$ are integers and that $a = bq + r$.\nThen $\\gcd(a, b) = \\gcd(b, r)$.\n", "end exlean -- hide", "import tactic.linarith divisibility.euclid_basic  -- hide\n", "# Divisibility\n\n## Level 21: The Euclidean algorithm\n", "namespace exlean -- hide\n", "Using the result `euclid_basic` from our previous level, we can compute greatest common divisors.\n", "open int -- hide\n", "variables (a b d q r x y: \u2124)  -- hide\n", "As an example, we'll compute $\\gcd(100,7)$. As a first step, we'll use `euclid_basic` to justify\nthe assertion that $\\gcd(100,7) = \\gcd(7, 2)$. The reason for this is that \n$100 = 7 \\times 14 + 2$, so $\\gcd(7 \\times 14 + 2, 7) = \\gcd(7, 2)$, by `euclid_basic`.\n\nHere ia a proof in Lean.\n", "example : gcd 100 7 = gcd 7 2 := euclid_basic 7 14 2\n", "In the above proof, note that the arguments  $7$, $14$, and $2$ correspond to the calculation\n$100 = 7 \\times 14 + 2$.\n", " (h\u2081 : greatest_common_divisor d a b) (h\u2082 : 0 \u2264 d) : gcd a b = d\n", "lemma gcd_eq_greatest_common_divisor {a b d : \u2124} (h\u2081 : greatest_common_divisor d a b) (h\u2082 : 0 \u2264 d) : gcd a b = d :=\nbegin\n  rcases (greatest_common_divisor_gcd a b) with \u27e8hxgreat, hxnn\u27e9,\n  exact uniqueness_of_greatest_common_divisor hxnn h\u2082 hxgreat h\u2081,\nend\n", "In later worlds, we'll have occasion to use the lemma `gcd_eq_greatest_common_divisor`. This states\nthat if $d$ is a greatest common divisor of $a$ and $b$ and if $d$ is non-negative, then\n$\\gcd(a,b) = d$.\n", "example (h\u2081 : greatest_common_divisor d a b) (h\u2082 : 0 \u2264 d) : gcd a b = d :=\ngcd_eq_greatest_common_divisor h\u2081 h\u2082\n", "gcd a 0 = abs a\n", "lemma gcd_zero : gcd a 0 = abs (a) :=\nbegin\n  refine gcd_eq_greatest_common_divisor  _ (abs_nonneg a),\n  rcases abs_cases a with \u27e8habs, hineq\u27e9 | \u27e8habs, hineq\u27e9; rw habs,\n  { apply greatest_common_divisor_zero, },\n  { split,\n    { split,\n      { rw neg_dvd, },\n      { apply dvd_zero, }, },\n    { rintros e \u27e8ha, _\u27e9,\n      apply dvd_neg_of_dvd ha, }, },\nend\n", "We'll apply this process repeatedly until we reach $\\gcd(a, 0)$, for some integer $a$. We then\nuse the lemma `gcd_zero`.\n", "example : gcd a 0 = abs a := gcd_zero a\n", "Below is a Lean proof that 1 is a greatest common divisor of 7 and 100.\n", "example : gcd 100 7 = 1 :=\nbegin\n  calc gcd 100 7\n      = gcd 7 2 : euclid_basic 7 14 2\n  ... = gcd 2 1 : euclid_basic 2  3 1\n  ... = gcd 1 0 : euclid_basic 1  2 0\n  ... = 1       : gcd_zero 1,\nend\n", "### Task\n\nAdapt the proof above to show that $\\gcd(340, 23) = 1$.\n", "$\\gcd(340, 23) = 1$\n", "end exlean -- hide", "Congruences", "import divisibility.euclidean_algorithm -- hide\n", "#  Congruences\n\n## Level 1: The definition of congruence\n\nThe notation `a \u2261 b [MOD n]`, read '`a` is congruent to `b` modulo `n`' means `n \u2223 b - a`. \n\nType `\u2261` as `\\==`.\n", "namespace exlean -- hide\n", "def modeq (n a b : \u2124) := n \u2223 b - a  -- hide\n", "notation a ` \u2261 `:50 b ` [MOD `:50 n `]`:0 := modeq n a b -- hide\n", "If you forget this definition or ever want to replace `a \u2261 b [MOD n]` with the definition in a proof, use\nthe result `mod_def`.\n", "variables {a b n : \u2124} -- hide\n", "a \u2261 b [MOD n] \u2194 n \u2223 b - a\n", "lemma mod_def : a \u2261 b [MOD n] \u2194 n \u2223 b - a := by refl -- hide\n", "For example, we will prove that `45 \u2261 17 [MOD 7]`. The first two lines of the proof are\nunnecessary but may be helpful in understanding how to apply definitions.\n\nIn the first line, we rewrite `\u22a2 45 \u2261 17 [MOD 7]` using the definition of congruence to give\n`\u22a2 7 \u2223 45 - 17`.\n\nUsing the definition of divisibility, this becomes `\u22a2 \u2203 (m : \u2124), 45 - 17 = 7 * m`.\n\nTo prove this existentially-quantified statement, we take `m` to be `4`. The result follows by\narithmetic.\n", "example : 17 \u2261 45 [MOD 7] :=\nbegin\n  rw mod_def, -- `\u22a2 7 \u2223 45 - 17`\n  rw dvd_def, -- `\u22a2 \u2203 (m : \u2124), 45 - 17 = 7 * m`\n  use 4,      -- `\u22a2 45 - 17 = 7 * 4`\n  norm_num,   -- This holds by arithmetic.\nend\n", "If you were to write the proof 'by hand', you might write the following:\n\n> By definition, we must prove `7 \u2223 45 - 17`. That is, that `45 - 17 = 7 * m`, for some `m`.\n> This holds if one takes `m` to be `4`.\n", "### Tasks\n* By making a minor variation to the proof above, show that `60 \u2261 38 [MOD 11] `.\n\n* Write the same proof by hand.\n", "`60 \u2261 38 [MOD 11]` \n", "end exlean -- hide", "import congruences.mod_def -- hide\n", "#  Congruences\n\n## Level 2: Reduction of an integer modulo $n$\n", "namespace exlean -- hide\n", "Let $x$ and $n$ be integers with $n \\ne 0$. One can find an integer $a$ in the range $0 \\le a < |n|$\nsuch that $x \\equiv a \\pmod n$.\n\nThis is sometimes called _reduction_ of $x$ modulo $n$.\n", "variables {x a n : \u2124} -- hide\n", "We'll find a number $a$ such that $321 \\equiv a \\pmod{12}$ and such that $0 \\le a < |12|$\n\nFor $a$, I'll take the remainder on dividing $321$ by $12$. Note that\n$321 = q \\times 12 + r$, where $q = 26$ and $r = 9$.\n", "example : \u2203 (a : \u2124), 321 \u2261 a [MOD 12] \u2227 (0 \u2264 a) \u2227 (a < abs (12)) :=\nbegin\n  use 9,  -- `\u22a2 321 \u2261 9 [MOD 12] \u2227 (0 \u2264 9) \u2227 (9 < abs(12))`\n  split,\n  { rw [mod_def, dvd_def], -- `\u22a2 \u2203 m, 9 - 321 = 12 * m`\n    use -26, -- `9 - 321 = 12 * (-26)`\n    norm_num, },\n  tidy, -- `tidy` proves `(0 \u2264 9) \u2227 (9 < abs(12))`\nend\n", "There is an integer $a$ such that $500 \\equiv a \\pmod{63}$ with\n$0 \\le a < |63|$.\n", "end exlean -- hide", "import congruences.reduction1 -- hide\n", "#  Congruences\n\n## Level 3: Reflexivity and symmetry of mod\n", "namespace exlean -- hide\n", "As a first proper theorem on congruences, we'll show that `\u2261` is a reflexive relation.\n", "variables {a b n : \u2124} -- hide\n", "a \u2261 a [MOD n]\n", "lemma mod_refl : a \u2261 a [MOD n] :=\nbegin\n  rw mod_def, -- `\u22a2 n \u2223 a - a`\n  rw dvd_def, -- `\u22a2 \u2203 (m : \u2124), a - a = n * m`\n  use 0,      -- `\u22a2 a - a = n * 0`\n  linarith,   -- Follows by algebra.\nend\n", "A handwritten proof might be:\n\n> By definition of congruence, it suffices to prove $n \\mid a - a$.\n> By definition of divisibility, it suffices to prove $a - a = nm$, for some integer $m$.\n> Take $m = 0$. Then $a - a = n \\times 0$ holds by algebra.\n", "### Tasks\n* Show that `\u2261` is a symmetric relation.\n\n* Write the same proof by hand.\n", "In the problem below, you are _given_ a congruence `h : a \u2261 b [MOD n]`. To extract information\nfrom this statement, use the `cases` tactic. \n\nFor example, write `cases h with m h\u2082` to produce an integer `m` and the hypothesis\n`h\u2082 : b - a = n * m`.\n", "Decomposing a congruence", "The relation `\u2261` is symmetric.\n", "end exlean -- hide", "import congruences.mod_refl_symm -- hide\n", "#  Congruences\n\n## Level 4: Transitivity of mod\n", "namespace exlean -- hide\n", "variables {a b c d n : \u2124} -- hide\n", "Your next task is to prove that `\u2261` is transitive. That is, assuming `a \u2261 b [MOD n]` and\n`b \u2261 c [MOD n]` to prove `a \u2261 c [MOD n]`. The clever way to do this is to invoke an appropriate\nresult you've already seen concerning divisibility. \n", "As an example of the kind of technique you'll need, we'll give a proof that $a \\mid b + 2c + d$\ngiven $h_1 : a \\mid b + c$ and $h_2 : a \\mid c + d$.\n\nFirst we note $h_3 : b + 2c + d = (b + c) + (c + d)$. Rewriting with $h_3$, the goal becomes\n$\\vdash a \\mid (b + c) + (c + d)$. Applying the 'addition of divisibility' result, it suffices\nto prove two new goals (1) $a \\mid b + c$ and (2) $a \\mid c + d$. The first of these goals follows\nfrom $h_1$ and the second from $h_2$.\n\nNote the use of the `apply` tactic to construct new goals from the conditions of the `dvd_add`\ntheorem.\n", "example (h\u2081 : a \u2223 b + c) (h\u2082 : a \u2223 c + d) : a \u2223 b + 2 * c + d :=\nbegin\n  have h\u2083 : b + 2 * c + d = (b + c) + (c + d), linarith,\n  rw h\u2083,\n  apply dvd_add,\n  { exact h\u2081 },\n  { exact h\u2082 },\nend\n", "We can prove the same result more briefly by (a) dispensing with additional hypothesis `h\u2083` and\nrewriting 'in place' via 'show' and (b) giving `apply` the desired conditions without the need\nto introduce additional goals.\n", "example (h\u2081 : a \u2223 b + c) (h\u2082 : a \u2223 c + d) : a \u2223 b + 2 * c + d :=\nbegin\n  rw (show b + 2 * c + d = (b + c) + (c + d), by linarith),\n  apply dvd_add h\u2081 h\u2082,\nend\n", "### Tasks\n* Show that `\u2261` is a transitive relation.\n\n* Write the same proof by hand.\n", "Start by rewriting the target and hypotheses with the definition of congruence. Do this with\n`rw mod_def at *`.\n", "Starting the problem", "If you took the hint above, the target will be `\u22a2 n \u2223 c - a`. A clever idea is to write\n`c - a` as `(c - b) + (b - a)`.\n\nOne way to do this is via:\n```\nhave h\u2083 : c - a = (c - b) + (b - a), by linarith,\nrw h\u2083,\n```\n\nAlternatively,\n```\nrw (show c - a = (c - b) + (b - a), by linarith),\n```\nThe latter approach obviates the need for an additional hypothesis.\n\nAfter rewriting (by either method), you can use one of the divisibility lemmas (see the sidebar)\nto finish the proof.\n", "A clever rewriting", "The relation `\u2261` is transitive.\n", "end exlean -- hide", "import congruences.mod_trans -- hide\n", "#  Congruences\n\n## Level 5: A condition for an integer to be congruent to zero\n", "namespace exlean -- hide\n", "variables {a n : \u2124} -- hide\n", "### Tasks\n* Let $a$ and $n$ be integers. Prove, by hand, that $0 \\equiv a \\pmod n$ if and only if $n \\mid a$.\n\n\n* Write the same proof in Lean.\n", "Let $a$ be an integer. Then $0 \\equiv a \\pmod n \\iff n \\mid a$.\n", "end exlean -- hide", "import congruences.modeq_zero_iff   -- hide\n", "#  Congruences\n\n## Level 6: Multiplying a congruence on the right\n", "namespace exlean -- hide\n", "variables {a b c n : \u2124} -- hide\n", "### Tasks\n* Given `a \u2261 b [MOD n]`, show `a * c \u2261 b * c [MOD n]`. As in the previous level, you can prove\nthis using an appropriate divisibilty lemma.\n\n* Write the same proof by hand.\n", "Start by rewriting the target and hypotheses with the definition of congruence. Do this with\n`rw mod_def at *`.\n", "Starting the problem", "The expression `b * c - a * c` in the target can be factored to `(b - a) * c` using the technique\nshown in the previous level, namely,\n```\nrw (show b * c - a * c = (b - a) * c, by linarith),\n```\n\nIn fact, this factoring result is built in to Lean's mathematical library as the lemma `sub_mul`.\nSo you could, alternatively, use `rw \u2190sub_mul`.\n\nAfter rewriting (by either method), you can use one of the divisibility lemmas (see the sidebar)\nto finish the proof.\n", "Factoring", "Given `a \u2261 b [MOD n]`, the congruence `a * c \u2261 b * c [MOD n]` follows.\n", "end exlean -- hide", "import congruences.mod_mul_right -- hide\n", "#  Congruences\n\n## Level 7: Adding congruences\n", "namespace exlean -- hide\n", "variables {a b c d n : \u2124} -- hide\n", "### Tasks\n* Given `a \u2261 b [MOD n]` and `c \u2261 d [MOD n]`, show `a + c \u2261 b + d [MOD n]`. As before, you can prove\nthis using an appropriate divisibilty lemma.\n\n* Write the same proof by hand.\n", "Given `a \u2261 b [MOD n]` and `c \u2261 d [MOD n]`, the congruence `a + c \u2261 b + d [MOD n]` follows.\n", "end exlean -- hide", "import congruences.mod_add -- hide\n", "#  Congruences\n\n## Level 8: Multiplying congruences\n", "namespace exlean -- hide\n", "variables {a b c d n : \u2124} -- hide\n", "### Tasks\n* Given `a \u2261 b [MOD n]` and `c \u2261 d [MOD n]`, show `a * c \u2261 b * d [MOD n]`.\n\n* Write the same proof by hand.\n\nThe nicest way to do this is by using two different divisibility results.\n", "As before, start by converging the congruences to divisibility statements using `rw mod_def at *`.\n", "Starting the proof", "Your next task is to rewrite the goal from `n \u2223 b * d - a * c` to something of the form\n`n \u2223 p + q`, for appropriate `p` and `q`. You can then use `apply dvd_add`.\n\nYou should then `apply` another of the divisibility results to each of the\nresulting goals.\n", "A cunning rewrite", "Given `a \u2261 b [MOD n]` and `c \u2261 d [MOD n]`, the congruence `a * c \u2261 b * d [MOD n]` follows.\n", "end exlean -- hide", "import congruences.mod_mul  -- hide\n", "#  Congruences\n\n## Level 9: Reduction of congruences\n", "namespace exlean -- hide\n", "variables {n m a b : \u2124} -- hide\n", "We've seen the idea of reducing an integer $x$ modulo $n$. This means finding an integer $a$\nsuch that $x \\equiv a \\pmod n$ with $0 \\le a < |n|$.\n\nThe word 'reduction' has another meaning in the study of congruences.\n\nSuppose $a$, $b$, $n$ and $m$ are integers with $m \\mid n$. Suppose $a \\equiv b \\pmod n$.\nIt follows that $a \\equiv b \\pmod m$. This is called the _reduction of the congruence_\n$a \\equiv \\pmod n$, modulo $m$.\n", "### Task\nProve the reduction result mentioned above. You should be able to do this in one line by employing\nan appropriate result from Divisibility World.\n\n", "Given $m \\mid n$ and $a \\equiv b \\pmod n$, the congruence $a \\equiv b \\pmod m$ follows.\n", "end exlean -- hide", "import congruences.mod_reduction -- hide\n", "#  Congruences\n\n## Level 10: Reduction of integers in general\n", "namespace exlean -- hide\n", "We now return to the other meaning of reduction. You will show that for all integers $x$ and $n$\nwith $n \\ne 0$, there exists an integer $a$ in the range $0 \\le a < |n|$ such that\n$x \\equiv a \\pmod n$.\n\nThe statement above has some similarity with the `division` lemma, as seen in Divisibility World.\n", "variables {x a n : \u2124} -- hide\n", "For every non-zero integer $n$, there exists an integer $a$ such that $x \\equiv a \\pmod n$ with\n$0 \\le a < |n|$.\n", "end exlean -- hide", "import congruences.reduction2  -- hide\n", "#  Congruences\n\n## Level 11: A necessary condition for solving a linear congruence\n", "namespace exlean -- hide\n", "variables {n d a b x : \u2124} -- hide\n", "Suppose $d$ is a common divisor of integers $a$ and $n$. The linear congruence\n$a x \\equiv b \\pmod n$ has a solution only if $d \\mid b$.\n", "### Task\nProve the reduction result mentioned above, first by hand and then in Lean.\n", "Recall that if $d \\mid n$, and $s \\equiv t \\pmod n$, then $s \\equiv t \\pmod d$. We called this result\n`modeq_of_dvd_of_modeq`.\n", "A useful result", "Suppose $d$ is a common divisor of integers $a$ and $n$. The linear congruence\n$a x \\equiv b \\pmod n$ has a solution only if $d \\mid b$.\n", "end exlean -- hide", "import congruences.condition_for_linear_congruence -- hide\n", "#  Congruences\n\n## Level 12: A linear congruence without a solution\n", "namespace exlean -- hide\n", "variables {x : \u2124} -- hide\n", "It's easy to check that a given value $x$ _is_ a solution of a linear congruence.\n", "example (h : x = 5) : 7 * x \u2261 3 [MOD 4] :=\nbegin\n  rw h, -- `\u22a2 7 * 5 \u2261 3 [MOD 4]`\n  use -8, -- `\u22a2 3 - 7 * 5 = 4 * -8`\n  norm_num,\nend\n", "It's significantly more difficuult to show that a congruence doesn't have a solution.\n\nIn the previous level, you showed that the congruence $ax \\equiv \\pmod n$ has a solution only if\n$d \\mid b$, where $d$ is a common divisor of $a$ and $n$.\n\nIn this level, you'll use this to show that a certain linear congruence has no solutions.\nThis boils down to showing that a number doesn't divide another number, a topic we covered in\nDivision World.\n", "### Task\n\nUsing the ideas above and any other lemmas you've seen, show that\nthere is no $x$ for which  $12 x \\equiv 10 \\pmod {60}$.\n", "The congruence $12 x \\equiv 10 \\pmod {60}$ has no solution for $x$.\n", "end exlean -- hide", "import congruences.linear_congruences_no_soln-- hide\n", "#  Congruences\n\n## Level 13: Solving a linear congruence\n", "namespace exlean -- hide\n", "variables {a n x : \u2124} -- hide\n", "We've seen a necessary condition for a linear congruence to have a solution. You'll now prove a\nsufficient condition.\n\nSpecifically, you'll show that if $1$ is a greatest common divisor of $a$ and $n$, then the \ncongruence $ax \\equiv 1 \\pmod n$ has a solution for $x$.\n", "### Task\n\nProve the result above, both by hand and in Lean.\n", "If $1$ is a greatest common divisor of $a$ and $n$, then there exists an integer $x$ such that\n$a x \\equiv 1 \\pmod n$.\n", "end exlean -- hide"]]}
{"name": "Pure Mathematics with Lean", "version": "1.0.0", "languages": ["en"], "translated_name": "0", "devmode": false, "library_zip_fn": "Pure Mathematics with Lean-1.0.0-library.zip", "introData": {"name": "", "problemIndex": -1, "objects": [{"type": "text", "content": "1"}]}, "worlds": [{"name": "2", "levels": [{"name": "", "problemIndex": 8, "objects": [{"type": "lean", "content": "3", "hidden": true}, {"type": "text", "content": "4"}, {"type": "tactic", "content": "5", "name": "refl", "sideBar": true}, {"type": "text", "content": "6"}, {"type": "lean", "content": "7", "hidden": true}, {"type": "lean", "content": "8", "hidden": true}, {"type": "lean", "content": "9", "hidden": true}, {"type": "lean", "content": "10", "hidden": false}, {"type": "theorem", "text": "11", "lean": "theorem x_plus_y_eq_x_plus_y : x + y = x + y :=\n", "sideBar": false, "firstProofLineNumber": 66, "lastProofLineNumber": 66, "textBefore": "import myint.basic -- hide\n\n/-\n# Equations\n\n## Level 1: Proving equations through reflexivity\n\nIn the introduction, you read that tactics are used modify the goal, eventually proving \na theorem.\n\nThe `refl` tactic (short for `reflexivity`) can be used to prove any statement of the form\n`?X = ?X`. Here, I use `?X` to stand in for any expression of any type.\nIt could be `8 + 9` or `a * b` or `\"adele\"` or whatever.\n\nBelow, you are asked to prove `x + y = x + y`, where `x` and `y` are integers.\nThe word `sorry` between the `begin` and `end` lines below asks Lean not to give an error message if a\nproof isn't complete. You'll see a <span style=\"color:orange\">warning</span> message in the\nbottom-right hand pane. This indicates you shouldn't trust the proof just yet, as it uses `sorry`!\n\nDelete `sorry` (using the backspace key on your keyboard). In the right-hand pane you'll see:\n```\nx y : \u2124\n\u22a2 x + y = x + y\n```\n\nHere, `x y : \u2124` is the *context*, the set of things you know. In this case, you know `x` and `y`\nare integers.\n\nThe *target* is `\u22a2 x + y = x + y`. The `\u22a2` symbol can be read 'to prove'. So your target is\nto prove `x + y = x + y`.\n\nThe bottom part of the right-hand pane shows an <span style=\"color:red\">error</span>  message:\ntactic failed, there are unsolved goals. Don't panic! It's just telling you that you haven't yet\nproved the result.\n\nYour task is to replace `sorry` with `refl,`. Note the comma at the end of the line!\nIf you're successful, Lean will respond with the message `no goals` or `Proof complete!`\n-/\n\n/- Tactic : refl\nThe `refl` tactic closes any goal of the form `?X = ?X`. That is, it proves any equation where the\nleft and right sides are *definitionally equal*.\n-/\n\n/-\n## Translation to a hand-written proof\n\nIn words, the `refl` says, \"The result holds by reflexivity\". A one-line written proof of\nthe theorem below would be, \"The result hold by reflexivity\".\n\n-/\n\nnamespace exlean -- hide\n\nopen myint -- hide\n\nopen_locale mynum -- hide\n\nvariables (x y : \u2124) -- Declare `x` and `y` to be integers.\n\n/- Theorem : no-side-bar\n`x + y = x + y`, for all integers `x` and `y`.\n-/\ntheorem x_plus_y_eq_x_plus_y : x + y = x + y :=\nbegin\n", "proof": "  refl,", "textAfter": "\nend\n\nend exlean -- hide\n", "height": 1, "editorText": "sorry", "lineOffset": 65, "name": "x_plus_y_eq_x_plus_y", "statement": "x + y = x + y"}, {"type": "lean", "content": "12", "hidden": true}]}, {"name": "", "problemIndex": 9, "objects": [{"type": "lean", "content": "13", "hidden": true}, {"type": "text", "content": "14"}, {"type": "lean", "content": "15", "hidden": true}, {"type": "lean", "content": "16", "hidden": true}, {"type": "lean", "content": "17", "hidden": true}, {"type": "lean", "content": "18", "hidden": true}, {"type": "axiom", "content": "19", "name": "add_comm (a b : \u2124) :", "sideBar": true}, {"type": "lean", "content": "20", "hidden": true}, {"type": "hint", "content": "21", "title": "22"}, {"type": "theorem", "text": "23", "lean": "theorem x_plus_y_eq_y_plus_x : x + y = y + x :=\n", "sideBar": false, "firstProofLineNumber": 71, "lastProofLineNumber": 72, "textBefore": "import myint.basic -- hide\n\n/-\n# Equations\n\n## Level 2: Commutativity of addition via `rw`\n\nNow we'll prove something (slighlty) more interesting, that `x + y = y + x` for all integers `x`\nand `y`. Try the `refl` tactic below (remember to put a comma after `refl`) and see what happens.\n\nYou'll get an error message:\n```\ninvalid apply tactic, failed to unify\n  x + y = y + x\nwith\n  ?m_2 = ?m_2\n```\n\nLean tells you that you're trying to use `refl` to prove `x + y = y + x`, but it expects a target\nof the form `?m_2 = ?m_2`. There's no special meaning to the underscores here. It's the same as\nwriting `?X = ?X` as in the previous level.\n\nThe problem: even though we 'know' the left and right sides are equal, they are not\n*identically equal*.\nFortunately, Lean comes with a *theorem* of just the right kind. It's called `add_comm`, which is\nshort for additive commutativity.\nThe result `add_comm a b` states that `a + b = b + a`, where `a` and `b` are integers.\n\nTo apply this theorem, we'll use the `rw` (short for `rewrite`) tactic.\n\nReplace the `sorry` below with `rw add_comm` (followed by a comma\u2014I won't mention this from now\non).\n\nLean will look for the first expression in the target that matches the pattern `a + b` and\nreplace every instance of that expression with `b + a`. Here, Lean finds `x + y` and replaces\nit with `y + x`.\n\nEqually, if `h` is an equation of the form `p = q` (where `p` and `q` are expressions),\n`rw h` will cause Lean to look for `p` in the target and replace it with `q`.\n\nHaving issued `rw add_comm`, the goal is to prove `y + x = y + x`.\nYou know how to prove a goal of this kind from the previous level.\nWrite the proof on the line after the `rw add_comm`.\n-/\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\nvariables (x y : \u2124) -- hide\n\nnamespace pre_group -- hide\n\n/- Axiom : add_comm (a b : \u2124) :\na + b = b + a\n-/\ntheorem add_comm (a b : \u2124) : a + b = b + a := myint.add_comm' a b -- hide\n\n/- Hint : Moving through a proof\n\nYour proof of the theorem below will use two lines of code. If you move your cursor to a previous\nline, Lean will show you the tactic state at any point in the proof. If you click on the name of\na theorem, you'll get some brief documentation.\n-/\n\n/- Theorem : no-side-bar\n`x + y = y + x`, for all integers `x` and `y`.\n-/\ntheorem x_plus_y_eq_y_plus_x : x + y = y + x :=\nbegin [pure_maths]\n", "proof": "  rw add_comm,\n  refl,", "textAfter": "\nend\n\nend pre_group -- hide\n\nend exlean -- hide\n\n/-\n## Translation to a hand-written proof\n\nIn words, the `rw add_comm` says, \"Rewrite using commuativity of addition\".\nAs hand-written proofs aren't interactive, it's helpful to mention explicitly any changes to the\ncontext. Here's a hand-written proof of the above result.\n\n> Rewriting using commutativity of addition, the goal is to prove `y + x = y + x`.\n> This follows by reflexivity.\n-/\n\n/- Tactic : rw\nIf `h` is an equation of the form `p = q`, `rw h` rewrites replaces `p` in the target with `q`.\n\nIf `k` is in the context, `rw h at k` performs the rewrite at `k` instead of at the target.\n\n`rw \u2190h` will rewrite backward: every occurrence of `q` is replaced with `p`. Type `\\l` to produce `\u2190`.\n\n`rw [h1, h2, h3]` rewrites with multiple hypotheses (you aren't limited to three)!\n-/\n\n/-\n## Anatomy of a level\n\nEach level contains three vertial panes. The left-hand pane contains a list of the tactics and\ntheorem statements you've seen so far. Click on the arrows to dig deeper.\n\nThe middle pane is the one you're reading now! It contains text and interactive exercises.\nThe right-hand pane contains the Lean Infoview window, showing the 'tactic state' and error messages.\n\nYou can navigate through the book using the buttons in the top horizonal pane. The circular arrow\nresets your progress.\n-/\n\n/-\n## How `rw` here differs from that in standard Lean\n\nThe `rw` tactic used in this book is slightly different the standard `rw`. In particular, if\nthe result of a rewrite is an equation of the form `X = X`, then the standard `rw` tactic will\nautomatically close the goal via reflexivity.\n\nThis automation has been disabled here to help you think more carefully about proof construction.\n-/\n\n", "height": 2, "editorText": "sorry", "lineOffset": 70, "name": "x_plus_y_eq_y_plus_x", "statement": "x + y = y + x"}, {"type": "lean", "content": "24", "hidden": true}, {"type": "lean", "content": "25", "hidden": true}, {"type": "text", "content": "26"}, {"type": "tactic", "content": "27", "name": "rw", "sideBar": true}, {"type": "text", "content": "28"}, {"type": "text", "content": "29"}]}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "30", "hidden": true}, {"type": "text", "content": "31"}, {"type": "lean", "content": "32", "hidden": true}, {"type": "lean", "content": "33", "hidden": true}, {"type": "lean", "content": "34", "hidden": true}, {"type": "lean", "content": "35", "hidden": true}, {"type": "theorem", "text": "36", "lean": "theorem add_eq_add_two_mul_self_of_eq_two_mul (h : y = 2 * x)\n  : x + y = x + 2 * x :=\n", "sideBar": false, "firstProofLineNumber": 46, "lastProofLineNumber": 47, "textBefore": "import myint.basic equations.commutativity_rw -- hide\n\n/-\n# Equations\n\n## Level 3: Rewriting with hypotheses\n\nLook at the theorem below. It seems that you're being asked to prove `x + y = x + 2 * x`.\nSurely that isn't true in general! What's\ngoing on? If you look carefully, you'll see an additional hypothesis, `h : y = 2 * x`.\n\nThe `:` is just notation for naming a hypothesis (also called an assumption).\nSo the statement of the theorem can be read:\n\n> Let `x` and `y` be integers. Let `h` be the hypothesis `y = 2 * x`.\n> Then `x + y = x + 2 * x`.\n\nWhen you start the proof, you'll note in the top-right pane that `h : y = 2 * x` has been\nadded to the context.\n\nYou can use the hypothesis to rewrite the goal by typing `rw h` much as you used `rw add_comm`\nto rewrite via the theorem `add_comm`.\n\n### Tasks\n\n* Before doing the problem in Lean, think about what effect `rw h` will have on the goal.\n\n* Predict what error message Lean will produce if you replace `sorry` with `refl`. Test your\nprediction.\n-/\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\nnamespace pre_group -- hide\n\nvariables (x y : \u2124) -- hide\n\n/- Theorem : no-side-bar\nLet `x` and `y` be integers. Let `h` be the hypothesis `y = 2 * x`. Then `x + y = x + 2 * x`.\n-/\ntheorem add_eq_add_two_mul_self_of_eq_two_mul (h : y = 2 * x)\n  : x + y = x + 2 * x :=\nbegin [pure_maths]\n", "proof": "  rw h,\n  refl,", "textAfter": "\nend\n\nend pre_group -- hide\n\nend exlean -- hide\n\n/-\n## Translation to a hand-written proof\n\n> Rewriting using `h`, the goal is to prove `x + 2 * x = x + 2 * x`.\n> This follows by reflexivity.\n-/\n\n", "height": 2, "editorText": "sorry", "lineOffset": 45, "name": "add_eq_add_two_mul_self_of_eq_two_mul", "statement": "(h : y = 2 * x)\n  : x + y = x + 2 * x"}, {"type": "lean", "content": "37", "hidden": true}, {"type": "lean", "content": "38", "hidden": true}, {"type": "text", "content": "39"}]}, {"name": "", "problemIndex": 7, "objects": [{"type": "lean", "content": "40", "hidden": true}, {"type": "text", "content": "41"}, {"type": "lean", "content": "42", "hidden": true}, {"type": "lean", "content": "43", "hidden": true}, {"type": "lean", "content": "44", "hidden": true}, {"type": "lean", "content": "45", "hidden": false}, {"type": "hint", "content": "46", "title": "47"}, {"type": "theorem", "text": "48", "lean": "theorem add_comm_left_right : (x + y) + z = z + (y + x) :=\n", "sideBar": false, "firstProofLineNumber": 66, "lastProofLineNumber": 68, "textBefore": "import myint.basic equations.commutativity_rw-- hide\n\n/-\n# Equations\n\n## Level 4: Focussed rewriting\n\nHere, you're asked to prove `(x + y) + z = z + (y + x)`. Clearly a case for rewriting with the\n`add_comm` theorem.\n\nThink about what `rw add_comm` will do. What will happen if you do `rw add_comm` twice? Try this\nbelow and test your conjecture.\n\nWhat happens is that `rw add_comm` looks for an expression of the form `a + b`. It finds one in\n`(x + y) + z`, matching `a` with `x + y` and `b` with `z`. It replaces this with `b + a`. That is,\nwith `z + (x + y)`.\n\nYou might wonder why this is the first match. Why doesn't Lean work on `x + y` first, matching\n`a` with `x` and `b` with `y`? It's because Lean works outside-in, then left-to-right. The second\n`+` operator in `(x + y) + z` is the outermost operator, so is read first by Lean.\n\nThe problem: applying `rw add_comm` to the new goal `\u22a2 z + (x + y) = z + (y + x)` will match `a`\nwith `z` and `b` with `x + y`, rewriting the goal to `\u22a2 (x + y) + z = z + (y + x)`, taking us back\nto where we started!\n\n### Focussing a rewrite with arguments\n\nRecall that `add_comm a b` is the theorem that `a + b = b + a`. The quantities `a` and `b` are\n*arguments* to the theorem `add_comm`.\nEqually, `add_comm x (y + z)` is the theorem that `x + (y + z) = (y + z) + x`. This theorem has\narguments `x` and `y + x`. Note than arguments can be expressions, not just variables.\n\nApplying `rw add_comm x (y + z)` transforms `\u22a2 z + (x + (y + z)) = z` to\n`\u22a2 z + ((y + z) + x) = z`.\n\n### Tasks\n* Think about what would happen if you replaced `sorry` with `rw z y`. Try it out. Explain the\nresulting error message.\n\n* Use arguments, where necessary, to prove the theorem below.\n\n\n-/\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\nnamespace pre_group -- hide\n\nvariables (x y z : \u2124) -- Declare `x`, `y`, and `z` to be integers.\n\n/- Hint : Missing parentheses?\n\nWhen you start the proof below, Lean displays the target as `\u22a2 x + y + z = z + (y + x)`.\nWhat happened to the parentheses on the left-hand side? Lean treats addition as\n'left associative'. This is a fancy way of saying that `x + y + z` should always be\ninterpreted as `(x + y) + z`.\n-/\n\n/- Theorem : no-side-bar\nLet `x`, `y`, and `z` be integers. Then `(x + y) + z = z + (y + x)`.\n-/\ntheorem add_comm_left_right : (x + y) + z = z + (y + x) :=\nbegin [pure_maths]\n", "proof": "  rw add_comm,\n  rw add_comm x y,\n  refl,", "textAfter": "\nend\n\nend pre_group -- hide\n\nend exlean -- hide\n\n/-\n## Translation to a hand-written proof\n\nHere's a suggestion. When writing a proof by hand, you need not (and should not) aim at a direct\ntranslation of a Lean proof. Here, I've kept the main idea of each line of my Lean proof while\ntranslating for ease of human understanding.\n\n> Rewriting by additive commutativity, the goal is to prove `z + (x + y) = z + (y + x)`.\n> Rewriting with additive commutativity on `x + y`, the goal is to prove `z + (y + x) = z + (y + x)`.\n> This follows by reflexivity.\n-/\n\n", "height": 3, "editorText": "sorry", "lineOffset": 65, "name": "add_comm_left_right", "statement": "(x + y) + z = z + (y + x)"}, {"type": "lean", "content": "49", "hidden": true}, {"type": "lean", "content": "50", "hidden": true}, {"type": "text", "content": "51"}]}, {"name": "", "problemIndex": 10, "objects": [{"type": "lean", "content": "52", "hidden": true}, {"type": "text", "content": "53"}, {"type": "lean", "content": "54", "hidden": true}, {"type": "lean", "content": "55", "hidden": true}, {"type": "lean", "content": "56", "hidden": true}, {"type": "axiom", "content": "57", "name": "add_assoc (a b c : \u2124) :", "sideBar": true}, {"type": "lean", "content": "58", "hidden": true}, {"type": "lean", "content": "59", "hidden": false}, {"type": "text", "content": "60"}, {"type": "hint", "content": "61", "title": "62"}, {"type": "theorem", "text": "63", "lean": "theorem add_right_comm (x y z : \u2124) : (x + y) + z = (x + z) + y :=\n", "sideBar": true, "firstProofLineNumber": 56, "lastProofLineNumber": 59, "textBefore": "import myint.basic equations.commutativity_rw -- hide\n\n/-\n# Equations\n\n## Level 5: Associativity\n\nTime for a new theorem. This one is called `add_assoc`, which is short for additive associativity.\n\nThe result `add_assoc a b c` states that `(a + b) + c = a + (b + c)`, for all integers `a`, `b`,\nand `c`. You can see the statement in the sidebar on the left by unfolding 'Theorem statements'.\n\nAs with `add_comm`, you can use `add_assoc` to rewrite the goal using `rw add_assoc`.\n\nBelow, your task is to prove `(x + y) + z = x + (z + y)`. In future levels, this theorem will\nbe available as `add_right_comm`.\n\n**Before writing a Lean proof**, construct a hand-written proof.\n-/\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\nnamespace pre_group -- hide\n\n/- Axiom : add_assoc (a b c : \u2124) :\n(a + b) + c = a + (b + c)\n-/\ntheorem myint.add_assoc (a b c : \u2124) : a + b + c = a + (b + c) := myint.add_assoc' a b c -- hide\n\nopen myint\n\n/-\n### Tasks\n\n* Think about what would happen if you performed `rw add_assoc` once, twice, and thrice.\n  Try it out and compare with your predication.\n\n* Prove the theorem below.\n\n-/\n\n\n/- Hint : Hint\n\nYou'll need to rewrite with both `add_comm` and `add_assoc`. You may need to give arguments to one\nof your rewrites, as described in the previous level.\n-/\n\n/- Theorem : \nLet `x`, `y`, and `z` be integers. Then `(x + y) + z = x + (z + y)`.\n-/\ntheorem add_right_comm (x y z : \u2124) : (x + y) + z = (x + z) + y :=\nbegin [pure_maths]\n", "proof": "  rw add_assoc,\n  rw add_comm y z,\n  rw add_assoc,\n  refl,", "textAfter": "\nend\n\n/-\n## Translation to a hand-written proof\n\nIn the following hand-written proof, I omit the word 'rewriting'.\n\n> By associativity, the goal is to prove `x + (y + z) = x + (z + y)`.\n> By commutativity, the goal is to prove `x + (z + y) = x + (z + y)`.\n> This follows by reflexivity.\n-/\n\nend pre_group -- hide\n\nend exlean -- hide", "height": 4, "editorText": "sorry", "lineOffset": 55, "name": "add_right_comm", "statement": "(x y z : \u2124) : (x + y) + z = (x + z) + y"}, {"type": "text", "content": "64"}, {"type": "lean", "content": "65", "hidden": true}, {"type": "lean", "content": "66", "hidden": true}]}, {"name": "", "problemIndex": 9, "objects": [{"type": "lean", "content": "67", "hidden": true}, {"type": "text", "content": "68"}, {"type": "hint", "content": "69", "title": "70"}, {"type": "tactic", "content": "71", "name": "have", "sideBar": true}, {"type": "lean", "content": "72", "hidden": true}, {"type": "lean", "content": "73", "hidden": true}, {"type": "lean", "content": "74", "hidden": true}, {"type": "lean", "content": "75", "hidden": true}, {"type": "lean", "content": "76", "hidden": true}, {"type": "theorem", "text": "77", "lean": "theorem add_left_comm_comm : x + ((x + y) + z) = x + (z + (x + y)) :=\n", "sideBar": false, "firstProofLineNumber": 60, "lastProofLineNumber": 62, "textBefore": "import myint.basic equations.associativity -- hide\n\n/-\n# Equations\n\n## Level 6: Structuring proofs with `have`\n\nThe `have` tactic introduces a hypothesis into the context. It's a way to add structure to your\nproofs, stating and proving intermediate results before using them.\n\nConsider the goal `\u22a2 x + ((x + y) + z) = x + (z + (x + y))`.\n\nOne way to close this goal is to rewrite, giving specific arguments to `add_comm`.\nAnother option is to introduce an intermediate goal of proving `(x + y) + z = z + (x + y)`.\n\nThis is accomplished using `have h : (x + y) + z = z + (x + y)` (followed by a comma). \nThere's nothing special about `h` as the name of the hypothesis. Change it to whatever you wish.\n\nThis opens up a new goal: you'll see 2 goals in right-hand pane. The top goal is the new goal,\nnamely `\u22a2 (x + y) + z = z + (x + y)`. The bottom goal is the old goal, only with a new hypothesis,\n`h : (x + y) + z = z + (x + y)`.\n\nYou first work on closing the new goal, then close the original goal using hypothesis `h`.\n-/\n\n/- Hint : Focussing on one goal at a time\n\nIf you want to work only on goal, put braces after the `have`. When you're cursor is in the\ninner brace, you'll only be working on the first goal.\n```\nhave h : (x + y) + z = z + (x + y),\n{ sorry },\nsorry\n``` \n-/\n\n/- Tactic : have\n`have` is used to introduce a new hypothesis into the context. It opens a new goal for the proof\nof the hypothesis.\n\nFor example, `have h2 : x + y = y + x` introduces a new goal, to prove\n`x + y = y + x` while adding the hypothesis `h2 : x + y = y + x` to the context of the old goal.\n-/\n\nnamespace exlean -- hide\n\nnamespace pre_group -- hide\n\nopen_locale mynum -- hide\n\nopen myint -- hide\n\nvariables (x y z : \u2124) -- hide\n\n/- Theorem : no-side-bar\nLet `x`, `y`, and `z` be integers. Then `x + ((x + y) + z) = x + (z + (x + y)))`.\n-/\ntheorem add_left_comm_comm : x + ((x + y) + z) = x + (z + (x + y)) :=\nbegin [pure_maths]\n", "proof": "  have h : (x + y) + z = z + (x + y),\n  rw add_comm, refl,\n  rw h, refl,", "textAfter": "\nend\n\n/-\n## Translation to a hand-written proof\n\nIn my hand-written proof below, I omit references to reflexivity.\n\n> I claim `h : (x + y) + z = z + (x + y)`.\n> To prove this, use commutativity of addition.\n> Rewrite the original goal using `h`.\n-/\n\nend pre_group -- hide\n\nend exlean -- hide", "height": 3, "editorText": "sorry", "lineOffset": 59, "name": "add_left_comm_comm", "statement": "x + ((x + y) + z) = x + (z + (x + y))"}, {"type": "text", "content": "78"}, {"type": "lean", "content": "79", "hidden": true}, {"type": "lean", "content": "80", "hidden": true}]}, {"name": "", "problemIndex": 7, "objects": [{"type": "lean", "content": "81", "hidden": true}, {"type": "text", "content": "82"}, {"type": "lean", "content": "83", "hidden": true}, {"type": "lean", "content": "84", "hidden": true}, {"type": "lean", "content": "85", "hidden": true}, {"type": "lean", "content": "86", "hidden": true}, {"type": "lean", "content": "87", "hidden": true}, {"type": "theorem", "text": "88", "lean": "theorem add_comm_adele : x + (y + (x + z)) = (z + (x + y)) + x :=\n", "sideBar": false, "firstProofLineNumber": 33, "lastProofLineNumber": 35, "textBefore": "import myint.basic equations.associativity -- hide\n\n/-\n# Equations\n\n## Level 7: Multiple rewrites\n\nRather than writing, for example `rw add_assoc x y z, rw add_comm`, you can write\n`rw [add_assoc x y z, add_comm]`.\n\n### Tasks\n\n* Use this technique, together with `have`, to write a structured proof below.\n\n* Now write a proof using a long chain of rewrites followed by `refl`. Which proof do you prefer? Why?\n-/\n\nnamespace exlean -- hide\n\nnamespace pre_group -- hide\n\nopen_locale mynum -- hide\n\nopen myint -- hide\n\nvariables (x y z : \u2124) -- hide\n\n/- Theorem : no-side-bar\nLet `x`, `y`, and `z` be integers. Then `x + (y + (x + z)) = (z + (x + y)) + x`.\n-/\ntheorem add_comm_adele : x + (y + (x + z)) = (z + (x + y)) + x :=\nbegin [pure_maths]\n", "proof": "  have h : y + (x + z) = z + (x + y),\n    rw add_comm, rw add_comm x, rw add_assoc, refl,\n  rw h, rw add_comm, refl,", "textAfter": "\nend\n\nend pre_group -- hide\n\nend exlean -- hide", "height": 3, "editorText": "sorry", "lineOffset": 32, "name": "add_comm_adele", "statement": "x + (y + (x + z)) = (z + (x + y)) + x"}, {"type": "lean", "content": "89", "hidden": true}, {"type": "lean", "content": "90", "hidden": true}]}, {"name": "", "problemIndex": 15, "objects": [{"type": "lean", "content": "91", "hidden": true}, {"type": "text", "content": "92"}, {"type": "lean", "content": "93", "hidden": true}, {"type": "lean", "content": "94", "hidden": true}, {"type": "lean", "content": "95", "hidden": true}, {"type": "lean", "content": "96", "hidden": true}, {"type": "lean", "content": "97", "hidden": true}, {"type": "text", "content": "98"}, {"type": "lean", "content": "99", "hidden": false}, {"type": "lean", "content": "100", "hidden": true}, {"type": "lean", "content": "101", "hidden": false}, {"type": "lean", "content": "102", "hidden": true}, {"type": "lean", "content": "103", "hidden": false}, {"type": "text", "content": "104"}, {"type": "hint", "content": "105", "title": "106"}, {"type": "theorem", "text": "107", "lean": "theorem funky_town\n(h : (z + x) + y = y + z * x) : y + z * x = y + (z + x) :=\n", "sideBar": false, "firstProofLineNumber": 61, "lastProofLineNumber": 67, "textBefore": "import myint.basic equations.multiple_rewrites -- hide\n\n/-\n# Equations\n\n## Level 8: Backward rewrites\n\nSuppose you wanted to prove `y + x = 0` on the assumptions `h1 : x + 0 = 0` and `h2 : y = 0`.\nOne option would be to rewrite with `h2` to give `\u22a2 0 + x = 0`. You could then finish by\nrewriting with `add_comm` and `h1`.\n\nAnother option is to start by rewriting with `h1` *backward*. This would replace `0`\nin the target with `x + 0`. To do this in Lean, type `rw \u2190h1`.\n\nTo get the left arrow, type `\\l` followed by space or tab. Alternatively, just type `<-`\n-/\n\nnamespace exlean -- hide\n\nnamespace pre_group -- hide\n\nopen_locale mynum -- hide\n\nopen myint -- hide\n\nvariables (x y z : \u2124) -- hide\n\n/-\nHere is a proof of this result, using three rewrites, one backward.\n-/\n\nexample (h1 : x + 0 = 0) (h2 : y = 0) : y + x = 0 :=\nbegin\n  [pure_maths] -- hide\n  rw [\u2190h1, add_comm, h2],\n  refl,\n\n-- hide  \nend\n\n/-\n### Tasks\n* Prove the following using two rewrites, one backward.\n\n* Once you've done that, write a structured proof of the same result.\n-/\n\n/- Hint: Hint for structured proof\n\nIntroduce and prove the hypotheses `h2 : y + z * x = (z + x) + y` and\n`h3 : (z + x) + y = y + (z + x)` using the `have` tactic. Finish by rewriting with these\nhypotheses.\n-/\n\n/- Theorem : no-side-bar\nLet `x`, `y`, and `z` be integers. If `(z + x) + y = y + z * x`, then `y + z * x = y + (z + x)`\n-/\ntheorem funky_town\n(h : (z + x) + y = y + z * x) : y + z * x = y + (z + x) :=\nbegin [pure_maths]\n", "proof": "  rw [\u2190h, add_comm],\n  refl,\n/-   have h2 : y + z * x = (z + x) + y,\n  { rw h, refl },\n  have h3 : (z + x) + y = y + (z + x),\n  { rw add_comm, refl },\n  rw [h2, h3], refl,  -/", "textAfter": "\nend\n\nend pre_group -- hide\n\nend exlean -- hide", "height": 7, "editorText": "sorry", "lineOffset": 60, "name": "funky_town", "statement": "(h : (z + x) + y = y + z * x) : y + z * x = y + (z + x)"}, {"type": "lean", "content": "108", "hidden": true}, {"type": "lean", "content": "109", "hidden": true}]}, {"name": "", "problemIndex": 11, "objects": [{"type": "lean", "content": "110", "hidden": true}, {"type": "text", "content": "111"}, {"type": "lean", "content": "112", "hidden": true}, {"type": "lean", "content": "113", "hidden": true}, {"type": "lean", "content": "114", "hidden": true}, {"type": "lean", "content": "115", "hidden": true}, {"type": "axiom", "content": "116", "name": "add_zero (a : \u2124) :", "sideBar": true}, {"type": "lean", "content": "117", "hidden": true}, {"type": "text", "content": "118"}, {"type": "tactic", "content": "119", "name": "exact", "sideBar": true}, {"type": "hint", "content": "120", "title": "121"}, {"type": "theorem", "text": "122", "lean": "theorem zero_add (a : \u2124) : 0 + a = a :=\n", "sideBar": true, "firstProofLineNumber": 55, "lastProofLineNumber": 58, "textBefore": "import myint.basic equations.backward_rewrite -- hide\n\n/-\n# Equations\n\n## Level 9: Additive identity\n\nThe Lean theorem `add_zero` states that `x + 0 = x` for every integer `x`. In mathematics, this\nproperty is called (right) additive identity. Note `add_zero` should appear as a 'Theorem statement'\nin the left-hand pane. \n-/\n\nnamespace exlean -- hide\n\nnamespace pre_group -- hide\n\nopen_locale mynum -- hide\n\nopen myint -- hide\n\n/- Axiom : add_zero (a : \u2124) :\na + 0 = a\n-/\ntheorem add_zero (a : \u2124) : a + 0 = a := myint.add_zero' a -- hide\n\n/- \nYour goal is to prove `zero_add`, the right additive identity property, using `add_zero`.\nOnce you've done this, `zero_add` will be available to you in future levels.\n\nYou can use a series of rewrites and a `refl` or you can use a `rw` and the `exact` tactic, as\ndescrbed in the drop-down box below.\n\nAs always, construct a hand-written proof **before** writing your Lean proof.\n-/\n\n/- Tactic : exact\nIf `h` an expression (or the name of a hypothesis or theorem) that exactly matches the target,\nthen `exact h` will close the current goal.\n-/\n\n/- Hint : The `exact` tactic.\nThe `exact` tactic can be used in place of `rw` where a hypothesis or theorem *exactly*\nmatches the target.\n\nThus, the goal `\u22a2 (x + y) + z = x + (y + z)` is closed with `exact add_assoc x y z`.\n\nLikewise, if `h : x + y + 5 = 10`, then `\u22a2 x + y + 5 = 10` is closed with `exact h`.\n-/\n\n/- Theorem :\n`0 + a = a` for every integer `a`.\n-/\ntheorem zero_add (a : \u2124) : 0 + a = a :=\nbegin [pure_maths]\n", "proof": "  rw add_comm,\n  exact add_zero a,\n\n  ", "textAfter": "\nend\n\nend pre_group -- hide\n\nend exlean -- hide", "height": 4, "editorText": "sorry", "lineOffset": 54, "name": "zero_add", "statement": "(a : \u2124) : 0 + a = a"}, {"type": "lean", "content": "123", "hidden": true}, {"type": "lean", "content": "124", "hidden": true}]}, {"name": "", "problemIndex": 9, "objects": [{"type": "lean", "content": "125", "hidden": true}, {"type": "text", "content": "126"}, {"type": "lean", "content": "127", "hidden": true}, {"type": "lean", "content": "128", "hidden": true}, {"type": "lean", "content": "129", "hidden": true}, {"type": "lean", "content": "130", "hidden": true}, {"type": "lean", "content": "131", "hidden": true}, {"type": "text", "content": "132"}, {"type": "tactic", "content": "133", "name": "specialize", "sideBar": true}, {"type": "theorem", "text": "134", "lean": "theorem two_add_five_eq_eight_add_five_of (h : \u2200 x, x + 5 = 10)\n  : 2 + 5 = 8 + 5 :=\n", "sideBar": false, "firstProofLineNumber": 72, "lastProofLineNumber": 75, "textBefore": "import myint.basic equations.additive_identity -- hide\n\n/-\n# Equations\n\n## Level 10: Universal statements\n\nSo far, our hypotheses have made reference to specific variables. The hypothesis `h : x + 3 = 5`\nstates `x + 3 = 5` for the particular variable `x`.\n\nIf we want a statement that holds *for every* value of a variable, we use the *universal quantifier*\n`\u2200`. This is read, \"for all\" or \"for every\" and is typed `\\all`.\n\nFor example, `\u2200 (x : \u2124), x + 5 = 10` states that `x + 5 = 10` *for every* integer `x`. Of course,\nthis is a false statement! A statement that begins with `\u2200` is called a\n*universally quantified statement*.\n\nHere's how to *use* a universally quantified statement. Given the hypothesis\n`h : \u2200 (x : \u2124), x + 5 = 10`, the expression `h 3` corresponds to `3 + 5 = 10`.\nIt's what we get by replacing `x` with `3` in the body of the statement.\n\nIf `3 + 5` appears in the target, then `rw h 3` replaces `3 + 5` with `10`.\n\n### The specialize tactic\n\nThe `specialize` tactic specializes a universally quantified statement. For example if\n`h : \u2200 (x : \u2124), x + 5 = 10`, then `specialize h 20` *replaces* `h` with\n`h : 20 + 5 = 10`. However, after using `specialize`, you can't go back to the more general\nversion of `h`.\n-/\n\nnamespace exlean -- hide\n\nnamespace pre_group -- hide\n\nopen_locale mynum -- hide\n\nopen myint -- hide\n\nvariable (x : \u2124) -- hide\n\n/-\n\n### Tasks\n\nHere, you'll prove the unusual result `2 + 5 = 8 + 5` on the assumption `\u2200 x, x + 5 = 10`.\n\n\n* Write a proof using `rw`.\n\n* Write another proof where you use one `rw` and one application of `specialize`.\n\n* Think about how you'd write this proof by hand. Compare with my suggested translation at the bottom\nof the page.\n-/\n\n/- Tactic : specialize\nLet the hypothesis `h` be a universally-quantified statement. For example,\n`h : \u2200 (x : \u2124), x + 5 = 10`.\nThen `specialize h 8` replaces `x` with `8` in the body of `h`. Thus `h` becomes `8 + 5 = 10`.\n\nYou can specialize on more than one variable at a time. If `k : \u2200 (x y : \u2124), x + y = y * x`, then\n`specialize k 2 3` replaces `h` with `h : 2 + 3 = 3 * 2`.\n-/\n\n/- Theorem : no-side-bar\n`2 + 5 = 8 + 5` on the assumption `\u2200 x, x + 5 = 10`.\n-/\ntheorem two_add_five_eq_eight_add_five_of (h : \u2200 x, x + 5 = 10)\n  : 2 + 5 = 8 + 5 :=\nbegin [pure_maths]\n", "proof": "  rw [h 2, h 8],\n  refl,\n\n  ", "textAfter": "\nend\n\n/-\n## Translation to a hand-written proof\n\n> Using `h` with `2` in space of `x`, we must show `10 = 8 + 5`.\n> But this follows on taking `x` to be `8` in `h`.\n-/\n\nend pre_group -- hide\n\nend exlean -- hide", "height": 4, "editorText": "sorry", "lineOffset": 71, "name": "two_add_five_eq_eight_add_five_of", "statement": "(h : \u2200 x, x + 5 = 10)\n  : 2 + 5 = 8 + 5"}, {"type": "text", "content": "135"}, {"type": "lean", "content": "136", "hidden": true}, {"type": "lean", "content": "137", "hidden": true}]}, {"name": "", "problemIndex": 9, "objects": [{"type": "lean", "content": "138", "hidden": true}, {"type": "text", "content": "139"}, {"type": "lean", "content": "140", "hidden": true}, {"type": "lean", "content": "141", "hidden": true}, {"type": "lean", "content": "142", "hidden": true}, {"type": "lean", "content": "143", "hidden": true}, {"type": "text", "content": "144"}, {"type": "lean", "content": "145", "hidden": false}, {"type": "hint", "content": "146", "title": "147"}, {"type": "theorem", "text": "148", "lean": "theorem right_additive_identity_unique (e : \u2124)\n  (h : \u2200 (x : \u2124), x + e = x) : e = 0 :=\n", "sideBar": false, "firstProofLineNumber": 48, "lastProofLineNumber": 50, "textBefore": "import myint.basic equations.additive_identity -- hide\n\n/-\n# Equations\n\n## Level 11: Uniqueness of additive identity\n\nIn a previous level, we saw that there's an integer `0` with the property that\n`x + 0 = x` for every `x`.\n\nIn this level, you'll show that `0` is the *only* integer that satisfies this property.\n-/\n\nnamespace exlean -- hide\n\nnamespace pre_group -- hide\n\nopen_locale mynum -- hide\n\nopen myint -- hide\n\n/-\n### Rewriting at a hypothesis\n\nBy default, `rw add_assoc` (say) applies `add_assoc` to the target. If `h` is a hypothesis in the\nlocal context, `rw add_assoc at h` will rewrite `h` using `add_assoc`.\n\nIn the example below, we rewrite at `h` and finish with `exact`. Alternatively, we could have\nperformed a backward `rw` at the target using `rw \u2190add_assoc`.\n-/\n\nexample (x y z : \u2124) (h : (x + y) + z = 20) : x + (y + z) = 20 :=\nbegin\n  rw add_assoc at h,\n  exact h,\nend\n\n/- Hint : Hint\nUse the `specialize` tactic.\n-/\n\n/- Theorem : no-side-bar\nLet `e` be an integer satsifying the property `\u2200 (x : \u2124), x + e = x`. Then `e` must be `0`.\n-/\ntheorem right_additive_identity_unique (e : \u2124)\n  (h : \u2200 (x : \u2124), x + e = x) : e = 0 :=\nbegin [pure_maths]\n", "proof": "  specialize h 0,\n  rw zero_add at h,\n  exact h,", "textAfter": "\nend\n\nend pre_group -- hide\n\nend exlean -- hide", "height": 3, "editorText": "sorry", "lineOffset": 47, "name": "right_additive_identity_unique", "statement": "(e : \u2124)\n  (h : \u2200 (x : \u2124), x + e = x) : e = 0"}, {"type": "lean", "content": "149", "hidden": true}, {"type": "lean", "content": "150", "hidden": true}]}, {"name": "", "problemIndex": 11, "objects": [{"type": "lean", "content": "151", "hidden": true}, {"type": "text", "content": "152"}, {"type": "lean", "content": "153", "hidden": true}, {"type": "lean", "content": "154", "hidden": true}, {"type": "lean", "content": "155", "hidden": true}, {"type": "lean", "content": "156", "hidden": true}, {"type": "axiom", "content": "157", "name": "add_left_neg (a : \u2124) :", "sideBar": true}, {"type": "lean", "content": "158", "hidden": true}, {"type": "axiom", "content": "159", "name": "add_right_neg (a : \u2124) :", "sideBar": true}, {"type": "lean", "content": "160", "hidden": true}, {"type": "hint", "content": "161", "title": "162"}, {"type": "theorem", "text": "163", "lean": "theorem add_add_neg (x y : \u2124) : (x + y) + (-x) = y :=\n", "sideBar": true, "firstProofLineNumber": 43, "lastProofLineNumber": 46, "textBefore": "import myint.basic equations.unique_additive_identity -- hide\n\n/-\n# Equations\n\n## Level 12: Additive inverse\n\nThe Lean theorem `add_left_neg` states that `(-a) + a = 0` for every integer `a`. In mathematics,\nthis property is called (left) additive inverse.\n\nLikewise `add_right_neg (a : \u2124) : a + (-a) = 0`.\n\nYou'll use one of these properties in proving the next result.\n-/\n\nnamespace exlean -- hide\n\nnamespace pre_group -- hide\n\nopen_locale mynum -- hide\n\nopen myint -- hide\n\n/- Axiom : add_left_neg (a : \u2124) :\n(-a) + a = 0\n-/\ntheorem add_left_neg (a : \u2124) : (-a) + a = 0  := myint.add_left_neg a -- hide\n\n/- Axiom : add_right_neg (a : \u2124) :\na + (-a) = 0\n-/\ntheorem add_right_neg (a : \u2124) : a + (-a) = 0  := myint.add_right_neg a -- hide\n\n/- Hint : Hint\nYou might find it useful to use the previously-proved theorem `add_right_comm`.\n-/\n\n/- Theorem :\nFor all integers `x` and `y`, we have `(x + y) + -x = y`.\n-/\ntheorem add_add_neg (x y : \u2124) : (x + y) + (-x) = y :=\nbegin [pure_maths]\n", "proof": "  rw add_right_comm,\n  rw add_right_neg,\n  rw zero_add,\n  refl,", "textAfter": "\nend\n\nend pre_group -- hide\n\nexport pre_group (add_add_neg) -- hide\n\nend exlean -- hide", "height": 4, "editorText": "sorry", "lineOffset": 42, "name": "add_add_neg", "statement": "(x y : \u2124) : (x + y) + (-x) = y"}, {"type": "lean", "content": "164", "hidden": true}, {"type": "lean", "content": "165", "hidden": true}, {"type": "lean", "content": "166", "hidden": true}]}, {"name": "", "problemIndex": 7, "objects": [{"type": "lean", "content": "167", "hidden": true}, {"type": "text", "content": "168"}, {"type": "lean", "content": "169", "hidden": true}, {"type": "lean", "content": "170", "hidden": true}, {"type": "lean", "content": "171", "hidden": true}, {"type": "lean", "content": "172", "hidden": true}, {"type": "hint", "content": "173", "title": "174"}, {"type": "theorem", "text": "175", "lean": "theorem eq_zero_of_add_right_eq_self (a b : \u2124) (h : a + b = a)\n  : b = 0 :=\n", "sideBar": false, "firstProofLineNumber": 40, "lastProofLineNumber": 45, "textBefore": "import myint.basic equations.additive_inverse -- hide\n\n/-\n# Equations\n\n## Level 13: Cancellation I\n\nRecall the (right) uniqueness of additive identity. Let `y` be an integer. If for every integer `x`,\nwe have `x + y = x`, then `y = 0`.\n\nIn this level, we'll prove a theorem that is subtly different. Let `y` and `x` be integers. If\n`x + y = x`, then `y = 0`.\n\n**Question**: how does this new statement differ from from the uniqueness of additive identity?\n\nThe new result cannot be proved using only additive identity. You'll need to use the\nadditive inverse property.\n\nThis may be the most challenging level so far.\n-/\n\nnamespace exlean -- hide\n\nnamespace pre_group -- hide\n\nopen_locale mynum -- hide\n\nopen myint -- hide\n\n/- Hint : Hint\nUse `add_add_neg`.\n-/\n\n/- Theorem : no-side-bar\nIf `a + b = a`, then `b = 0`.\n-/\ntheorem eq_zero_of_add_right_eq_self (a b : \u2124) (h : a + b = a)\n  : b = 0 :=\nbegin [pure_maths]\n", "proof": "  have h2 : (a + b) + (-a) = b,\n  { rw add_add_neg, refl,  },\n  rw \u2190 h2,\n  rw h,\n  exact add_right_neg a,\n  ", "textAfter": "\nend\n\nend pre_group -- hide\n\nend exlean -- hide", "height": 6, "editorText": "sorry", "lineOffset": 39, "name": "eq_zero_of_add_right_eq_self", "statement": "(a b : \u2124) (h : a + b = a)\n  : b = 0"}, {"type": "lean", "content": "176", "hidden": true}, {"type": "lean", "content": "177", "hidden": true}]}, {"name": "", "problemIndex": 7, "objects": [{"type": "lean", "content": "178", "hidden": true}, {"type": "text", "content": "179"}, {"type": "lean", "content": "180", "hidden": true}, {"type": "lean", "content": "181", "hidden": true}, {"type": "lean", "content": "182", "hidden": true}, {"type": "lean", "content": "183", "hidden": true}, {"type": "hint", "content": "184", "title": "185"}, {"type": "theorem", "text": "186", "lean": "theorem right_additive_inverse_unique (x y : \u2124) (h : x + y = 0)\n  : y = -x :=\n", "sideBar": false, "firstProofLineNumber": 30, "lastProofLineNumber": 33, "textBefore": "import myint.basic equations.cancellation_i -- hide\n\n/-\n# Equations\n\n## Level 14: Uniqueness of additive inverse\n\nWe've seen the uniqueness of (right) additive identity. Now we'll show the uniqueness of (right)\nadditive inverse.\n-/\n\nnamespace exlean -- hide\n\nnamespace pre_group -- hide\n\nopen_locale mynum -- hide\n\nopen myint -- hide\n\n/- Hint : Hint\nUse `add_add_neg`.\n-/\n\n/- Theorem : no-side-bar\nLet `x` and `y` be integers. If `x + y = 0`, then `y = -x`. \n-/\ntheorem right_additive_inverse_unique (x y : \u2124) (h : x + y = 0)\n  : y = -x :=\nbegin [pure_maths]\n", "proof": "  rw \u2190add_add_neg x y,\n  rw h,\n  rw zero_add,\n  refl,", "textAfter": "\nend\n\nend pre_group -- hide\n\nend exlean -- hide", "height": 4, "editorText": "sorry", "lineOffset": 29, "name": "right_additive_inverse_unique", "statement": "(x y : \u2124) (h : x + y = 0)\n  : y = -x"}, {"type": "lean", "content": "187", "hidden": true}, {"type": "lean", "content": "188", "hidden": true}]}, {"name": "", "problemIndex": 8, "objects": [{"type": "lean", "content": "189", "hidden": true}, {"type": "text", "content": "190"}, {"type": "lean", "content": "191", "hidden": true}, {"type": "lean", "content": "192", "hidden": true}, {"type": "lean", "content": "193", "hidden": true}, {"type": "lean", "content": "194", "hidden": true}, {"type": "lean", "content": "195", "hidden": false}, {"type": "text", "content": "196"}, {"type": "theorem", "text": "197", "lean": "theorem ymca (x y z : \u2124)\n  : (y + x) + (0 + z + 0) + (0 + x + 0) = y + (z + (x + x)) :=\n", "sideBar": false, "firstProofLineNumber": 45, "lastProofLineNumber": 45, "textBefore": "import myint.basic equations.unique_additive_inverse -- hide\n\n/-\n# Equations\n\n## Level 15: The simplifier\n\nThis level introduces a powerful new tactic, `simp`, Lean's simplifier. It rewrites \nrepeatedly using either supplied theorems & hypotheses or theorems that it 'knows'.\n\nTo suggest theorems and hypotheses for use with `simp`, provide them as a comma-separated list.\nIn the example below, we supply `simp` with `add_assoc` and `add_comm y x`.\n\nWithout `simp`, you'd need several applications of `rw add_assoc`. \n-/\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\nnamespace pre_group -- hide\n\nopen myint -- hide\n\nexample (x y z : \u2124) : x + ((y + z) + x) = (y + x) + (z + x) :=\nbegin\n  simp [add_assoc, add_comm y x],\nend\n\n/-\n### Tasks\n\n* Prove the result below using only `simp` with supplied theorems, as in the example above. You should\nonly need to supply four theorems.\n\n* For fun (!) try proving this result using `rw`. Which proof do you prefer?\n-/\n\n/- Theorem : no-side-bar\nLet `x`, `y`, and `z` be integers. Then `(y + x) + (0 + z + 0) + (0 + x + 0) = y + (z + (x + x))`\n-/\ntheorem ymca (x y z : \u2124)\n  : (y + x) + (0 + z + 0) + (0 + x + 0) = y + (z + (x + x)) :=\nbegin\n", "proof": "  simp [add_assoc, add_comm x z, add_zero, zero_add],", "textAfter": "\nend\n\n/- Tactic : simp\nThe `simp` tactic rewrites repeatedly using either supplied theorems & hypotheses or theorems\nthat it 'knows'.\n\nTo suggest theorems and hypotheses for use with `simp`, provide them as a comma-separated list.\nFor example `simp [h, add_comm]` rewrites repeatedly with hypotheses `h` and theorem `add_comm`.\n-/\n\nend pre_group -- hide\n\nend exlean -- hide", "height": 1, "editorText": "sorry", "lineOffset": 44, "name": "ymca", "statement": "(x y z : \u2124)\n  : (y + x) + (0 + z + 0) + (0 + x + 0) = y + (z + (x + x))"}, {"type": "tactic", "content": "198", "name": "simp", "sideBar": true}, {"type": "lean", "content": "199", "hidden": true}, {"type": "lean", "content": "200", "hidden": true}]}, {"name": "", "problemIndex": 26, "objects": [{"type": "lean", "content": "201", "hidden": true}, {"type": "lean", "content": "202", "hidden": false}, {"type": "text", "content": "203"}, {"type": "lean", "content": "204", "hidden": true}, {"type": "lean", "content": "205", "hidden": true}, {"type": "lean", "content": "206", "hidden": true}, {"type": "lean", "content": "207", "hidden": true}, {"type": "text", "content": "208"}, {"type": "lean", "content": "209", "hidden": false}, {"type": "text", "content": "210"}, {"type": "lean", "content": "211", "hidden": false}, {"type": "text", "content": "212"}, {"type": "lean", "content": "213", "hidden": false}, {"type": "text", "content": "214"}, {"type": "lean", "content": "215", "hidden": false}, {"type": "lean", "content": "216", "hidden": true}, {"type": "text", "content": "217"}, {"type": "lean", "content": "218", "hidden": false}, {"type": "text", "content": "219"}, {"type": "lean", "content": "220", "hidden": false}, {"type": "text", "content": "221"}, {"type": "lean", "content": "222", "hidden": false}, {"type": "text", "content": "223"}, {"type": "lean", "content": "224", "hidden": false}, {"type": "tactic", "content": "225", "name": "cc", "sideBar": true}, {"type": "text", "content": "226"}, {"type": "theorem", "text": "227", "lean": "theorem eq_zero_of_add_left_eq_self (x y z : \u2124) (h : y + x = x)\n  : y = 0 :=\n", "sideBar": false, "firstProofLineNumber": 163, "lastProofLineNumber": 165, "textBefore": "import myint.basic equations.simplifier -- hide\n\n-- This import contains the definitions of the algebraic structures `add_monoid`, `add_comm_group`, etc.\nimport algebra.group.basic\n\n/-\n# Equations\n\n## Level 16: Algebraic structures and advanced tactics\n\nIn this level, we'll show how to unleash `simp`'s power using 'type classes'. We'll introduce\nalgebraic structures (such as additive monoid and additive commutative group) that you'll explore\nin greater detail later.\n\nIn the last level, I mentioned that `simp` can use theorems that it knows, but we still had to\nsupply every theorem explicitly.\n\nThe reason is that `simp` doesn't (yet) know anything about\nthe integer type we've been using. That's because we aren't actually using Lean's built-in integer\ntype, but our own copy, called `myint`.\n\nThe result I've called `zero_add` is short for `exlean.pre_group.zero_add`.\nHere `exlean` and `pre_group` are\n<a href=\"https://leanprover.github.io/theorem_proving_in_lean/dependent_type_theory.html#namespaces\",\ntarget = \"blank\">namespaces</a> I've created to hide the messy details. You don't need to\nunderstand namespaces at the moment, beyond the fact that they permit the same name to be used\nfor different functions.\n\n### Monoids and groups\n\nThe simplifier does know a *different* theorem called `zero_add`, outside of any namespace.\nThis theorem isn't restricted to a particular type (such as integers, natural numbers, vectors of\nlength 2, etc.). Rather, it holds for any type belong to the `add_monoid` *type class*.\n\nA type class is merely a mechanism for dealing coherently with a collection of types that satsify\ncertain properties. To be an *instance* of the `add_monoid` type class, a type `G` must have a 'zero'\nelement and an operation called addition and denoted `+` which satisfiy the properties\nof additive associativity and additive identity (both left and right).\n-/\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\nnamespace pre_group -- hide\n\nopen myint -- hide\n\n/-\nHere, we show that `myint` is an intance of the `add_monoid` (short for 'additive monoid' type class.\nTo do this, we merely need to provide the apprioate 'fields' of the `add_monoid` structure.\n\nFor example, the line `zero_add := exlean.pre_group.zero_add,` fulfills the `zero_add`\nconstraint of the `add_monoid` type class by supplying our theorem `exlean.pre_group.zero_add`.\n\nIn fact, there are fields other than those shown, but Lean can generate these automatically from\nthe specified fields. This is what the `..` notation asks Lean to do.\n-/\n\ninstance : add_monoid myint :=\n{ add_assoc := exlean.pre_group.myint.add_assoc,\n  zero_add := exlean.pre_group.zero_add,\n  add_zero := exlean.pre_group.add_zero,\n  .. }\n\n/-\nAn instance of `add_comm_monoid` is an `add_monoid` for which the `+` operation is commutative.\nWe only need supply the `add_comm` field and let Lean generate the other fields by providing the\ninstance `myint.add_monoid`. Again, we use the `..` notation to do this.\n-/\n\ninstance : add_comm_monoid myint :=\n{ add_comm := exlean.myint.add_comm,\n  .. myint.add_monoid }\n\n/-\nAn `add_group` (addtive group) is an `add_monoid` that has an additive negation operator which\nsatisfies the `add_left_neg` property, namely that `(-a) + a = 0` for every `a`.\n-/\n\ninstance : add_group myint :=\n{ neg := exlean.myint.neg,\n  add_left_neg := exlean.pre_group.add_left_neg,\n  .. myint.add_monoid }\n\n\n/-\nFinally an `add_comm_group` (additive commutative group) is an additive group that is also\nan additive commutative monoid. All we need do is provide the required instances.\n-/\n\ninstance : add_comm_group myint :=\n{ .. myint.add_group, .. myint.add_comm_monoid }\n\nend pre_group -- hide\n\n/-\n### Levelled-up `simp`\n\nNow `simp` will automatically use `zero_add`, `add_zero`, `add_left_neg`, `add_right_comm`, etc.\nHere's an example.\n-/\n\nexample (x y : \u2124) : x + (-y) + y = x + 0 :=\nbegin\n  simp\nend\n\n/-\nNote that `add_assoc` and `add_comm` are *not* automatically applied by `simp`. Can you think why?\n-/\n\nexample (x y z : \u2124) : (y + x) + (0 + z + 0) + (0 + x + 0) = y + (z + (x + x)) :=\nbegin\n  simp [add_assoc, add_comm x z],\nend\n\n\n/-\nIn the example below, an ordinary `simp` would be useless as the target `\u22a2 x = y` cannot be\nsimplified further. However, using `simp at h` will simplify the hypothesis `h` using the \n`sub_right_inj` theorem. You haven't seen this theorem yet: suffice it to say that it does the \nobvious thing and `simp` finds it for you.\n\n-/\nexample (x y z : \u2124) (h : z - x = z - y) : x = y :=\nbegin\n  simp at h,\n  exact h,\nend\n\n/-\n### Congruence closure\n\nCongruence closure, or `cc`, is another powerful tactic. Don't worry about what the words\n'congruence' and 'closure' mean here\u2014they refer to concepts in computer science.\n\nRoughly speaking, `cc` can be used to prove equations where the proof depends on associativity,\ncommutativity, and (optionally) the use of hypotheses in the local context. Here's an example.\n-/\n\nexample (x y z : \u2124) (h : (z + x) + y = y + z * x) : y + z * x = y + (z + x) :=\nbegin\n  cc,\nend\n\n/- Tactic : cc\n`cc` can be used to prove equations where the proof depends on associativity,\ncommutativity, and (optionally) the use of hypotheses in the local context.\n-/\n\n/-\nUse `simp` (and whatever else you need) to prove the following result.\nThis is similar to a hard result you proved in a previous level.\n-/\n\n/- Theorem : no-side-bar\nIf `y + x = x`, then `y = 0`.\n-/\ntheorem eq_zero_of_add_left_eq_self (x y z : \u2124) (h : y + x = x)\n  : y = 0 :=\nbegin [pure_maths]\n", "proof": "  simp at h,\n  exact h,\n", "textAfter": "\nend\n\nend exlean -- hide\n", "height": 3, "editorText": "sorry", "lineOffset": 162, "name": "eq_zero_of_add_left_eq_self", "statement": "(x y z : \u2124) (h : y + x = x)\n  : y = 0"}, {"type": "lean", "content": "228", "hidden": true}]}]}, {"name": "229", "levels": [{"name": "", "problemIndex": 7, "objects": [{"type": "lean", "content": "230", "hidden": true}, {"type": "text", "content": "231"}, {"type": "lean", "content": "232", "hidden": true}, {"type": "lean", "content": "233", "hidden": true}, {"type": "axiom", "content": "234", "name": "`my_f`", "sideBar": true}, {"type": "lean", "content": "235", "hidden": false}, {"type": "text", "content": "236"}, {"type": "theorem", "text": "237", "lean": "theorem my_fun : my_f 10 = 35 :=\n", "sideBar": false, "firstProofLineNumber": 51, "lastProofLineNumber": 51, "textBefore": "import mynat.basic -- hide\n\n/-\n# Functions\n\n## Level 1: Defining functions\n\nA function is a map from one set, called the domain, to another set, called the codomain.\n\nThe notation `f : S \u2192 T` is read, \"`f` is a function with domain `S` and codomain `T`\" or \"`f` is a\nfunction from `S` to `T`\".\n\nTo specify that `f` maps each `x` to some expression `y`, we write `f : x \u21a6 y` or\n`f(x) = y`, when doing mathematics by hand.\n\nIn Lean, we combine all the above information into:\n```\ndef f : S \u2192 T := \u03bb x, y\n```\nwhere `y` is an expression that depends on `x`. Here `\u03bb` is a Greek letter called lambda.\nIts only significance is to indicate that the following quantity `x` is a variable.\n\nBelow is the definition of a function `my_f` from the set `\u2115` of natural numbers (the non-negative)\nintegers to itself. It takes each `x` to `3 * x + 5`.\n-/\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\n/- Axiom : `my_f`\nThe function `my_f` is defined so that `my_f (x) = 3 * x + 5` for every \nnatural number `x`.\n-/\ndef my_f : \u2115 \u2192 \u2115 := \u03bb x, 3 * x + 5\n\n/-\nYour task is to prove `my_f 10 = 35`. By definition of `my_f`, you must prove `3 * 10 + 5 = 35`.\nIt may come as a surprise to learn that Lean can prove this using `refl`.\nThe reason is that when Lean uses `refl`, it applies definitions until no further simplification is\npossible. For reasons that will become apparent later, the definitions of addition and\nmultiplication can be applied to reduce any 'sum' into a natural number.\n-/\n\n\n/- Theorem : no-side-bar\nThe function `my_f` takes `10` to `35`.\n-/\ntheorem my_fun : my_f 10 = 35 :=\nbegin\n", "proof": "  refl,", "textAfter": "\nend\n\nend exlean -- hide\n", "height": 1, "editorText": "sorry", "lineOffset": 50, "name": "my_fun", "statement": "my_f 10 = 35"}, {"type": "lean", "content": "238", "hidden": true}]}], "parents": [0]}], "texts": [["Pure Mathematics with Lean", "# Pure mathematics with Lean, version 1.0.0\n\n## By Gihan Marasingha\n\nThis is an interactive book aimed at beginning mathematics undergraduates. You'll learn to prove\ntheorems online using a computer tool called Lean.\n\nEach chapter is represented by a coloured circular button in the right-hand pane. Blue indicates your\ncurrent position, green is for completed chapters, and grey is for unread or incomplete chapters.\n\nAt every stage in a theorem, there is a *target*, the thing you want to prove, and a *context*, the\nset of things you have already proved or assumed at the beginning of your argument.\nThe target and context change through the proof.\n\nThe word *goal* is used to refer variously to the target or to the combination of target and context.\n\nYou'll use *tactics* to modify the goal until you have proved the target (called 'closing the goal').\nEach tactic may invoke one or more *theorems*.\n\nNote: the book is roughly 30Mb in size. It must be downloaded before you can begin to work on the\nproblems. Once you open the book, wait for the text 'Lean is busy...' to disappear from the\ntop-right-hand pane before using Lean.\n\n*Pure mathematics with Lean* is part of the \n<a href=\"https://exlean.org\" target=\"blank\">exlean</a> project.\n\n**This book is under construction.** At the time of writing, only the first chapter is available.\nIt's on the additive commutativity, associativity, identity, and inverse properties of the integers.\n\n## Credits\n\nThis game was made using the code base of the\n<a href=\"https://www.ma.imperial.ac.uk/~buzzard/xena/natural_number_game/\">Natural Number Game</a>\nby Kevin Buzzard and Mohammad Pedramfar.\n\n<a href=\"https://leanprover.github.io/\" target=\"blank\">Lean</a> is an interactive theorem prover developed at Microsoft Research under the direction of\nLeonardo de Moura.\n\nMathlib, Lean's mathematical library, is developed by the <a href=\"https://leanprover-community.github.io/\" target=\"blank\">Lean community</a>.\n\nHere's some mathematics in MathJax, just to remind me that it's possible.\nFirst inline: \\\\(a^2 + b^2 = c^2\\\\). Now displayed:\n\n\\\\[ \\int_{-\\infty}^\\infty  e^{-x^2} dx = \\sqrt \\pi. \\\\]\n\n", "Equations", "import myint.basic -- hide\n", "# Equations\n\n## Level 1: Proving equations through reflexivity\n\nIn the introduction, you read that tactics are used modify the goal, eventually proving \na theorem.\n\nThe `refl` tactic (short for `reflexivity`) can be used to prove any statement of the form\n`?X = ?X`. Here, I use `?X` to stand in for any expression of any type.\nIt could be `8 + 9` or `a * b` or `\"adele\"` or whatever.\n\nBelow, you are asked to prove `x + y = x + y`, where `x` and `y` are integers.\nThe word `sorry` between the `begin` and `end` lines below asks Lean not to give an error message if a\nproof isn't complete. You'll see a <span style=\"color:orange\">warning</span> message in the\nbottom-right hand pane. This indicates you shouldn't trust the proof just yet, as it uses `sorry`!\n\nDelete `sorry` (using the backspace key on your keyboard). In the right-hand pane you'll see:\n```\nx y : \u2124\n\u22a2 x + y = x + y\n```\n\nHere, `x y : \u2124` is the *context*, the set of things you know. In this case, you know `x` and `y`\nare integers.\n\nThe *target* is `\u22a2 x + y = x + y`. The `\u22a2` symbol can be read 'to prove'. So your target is\nto prove `x + y = x + y`.\n\nThe bottom part of the right-hand pane shows an <span style=\"color:red\">error</span>  message:\ntactic failed, there are unsolved goals. Don't panic! It's just telling you that you haven't yet\nproved the result.\n\nYour task is to replace `sorry` with `refl,`. Note the comma at the end of the line!\nIf you're successful, Lean will respond with the message `no goals` or `Proof complete!`\n", "The `refl` tactic closes any goal of the form `?X = ?X`. That is, it proves any equation where the\nleft and right sides are *definitionally equal*.\n", "## Translation to a hand-written proof\n\nIn words, the `refl` says, \"The result holds by reflexivity\". A one-line written proof of\nthe theorem below would be, \"The result hold by reflexivity\".\n\n", "namespace exlean -- hide\n", "open myint -- hide\n", "open_locale mynum -- hide\n", "variables (x y : \u2124) -- Declare `x` and `y` to be integers.\n", "`x + y = x + y`, for all integers `x` and `y`.\n", "end exlean -- hide\n", "import myint.basic -- hide\n", "# Equations\n\n## Level 2: Commutativity of addition via `rw`\n\nNow we'll prove something (slighlty) more interesting, that `x + y = y + x` for all integers `x`\nand `y`. Try the `refl` tactic below (remember to put a comma after `refl`) and see what happens.\n\nYou'll get an error message:\n```\ninvalid apply tactic, failed to unify\n  x + y = y + x\nwith\n  ?m_2 = ?m_2\n```\n\nLean tells you that you're trying to use `refl` to prove `x + y = y + x`, but it expects a target\nof the form `?m_2 = ?m_2`. There's no special meaning to the underscores here. It's the same as\nwriting `?X = ?X` as in the previous level.\n\nThe problem: even though we 'know' the left and right sides are equal, they are not\n*identically equal*.\nFortunately, Lean comes with a *theorem* of just the right kind. It's called `add_comm`, which is\nshort for additive commutativity.\nThe result `add_comm a b` states that `a + b = b + a`, where `a` and `b` are integers.\n\nTo apply this theorem, we'll use the `rw` (short for `rewrite`) tactic.\n\nReplace the `sorry` below with `rw add_comm` (followed by a comma\u2014I won't mention this from now\non).\n\nLean will look for the first expression in the target that matches the pattern `a + b` and\nreplace every instance of that expression with `b + a`. Here, Lean finds `x + y` and replaces\nit with `y + x`.\n\nEqually, if `h` is an equation of the form `p = q` (where `p` and `q` are expressions),\n`rw h` will cause Lean to look for `p` in the target and replace it with `q`.\n\nHaving issued `rw add_comm`, the goal is to prove `y + x = y + x`.\nYou know how to prove a goal of this kind from the previous level.\nWrite the proof on the line after the `rw add_comm`.\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "variables (x y : \u2124) -- hide\n", "namespace pre_group -- hide\n", "a + b = b + a\n", "theorem add_comm (a b : \u2124) : a + b = b + a := myint.add_comm' a b -- hide\n", "\nYour proof of the theorem below will use two lines of code. If you move your cursor to a previous\nline, Lean will show you the tactic state at any point in the proof. If you click on the name of\na theorem, you'll get some brief documentation.\n", "Moving through a proof", "`x + y = y + x`, for all integers `x` and `y`.\n", "end pre_group -- hide\n", "end exlean -- hide\n", "## Translation to a hand-written proof\n\nIn words, the `rw add_comm` says, \"Rewrite using commuativity of addition\".\nAs hand-written proofs aren't interactive, it's helpful to mention explicitly any changes to the\ncontext. Here's a hand-written proof of the above result.\n\n> Rewriting using commutativity of addition, the goal is to prove `y + x = y + x`.\n> This follows by reflexivity.\n", "If `h` is an equation of the form `p = q`, `rw h` rewrites replaces `p` in the target with `q`.\n\nIf `k` is in the context, `rw h at k` performs the rewrite at `k` instead of at the target.\n\n`rw \u2190h` will rewrite backward: every occurrence of `q` is replaced with `p`. Type `\\l` to produce `\u2190`.\n\n`rw [h1, h2, h3]` rewrites with multiple hypotheses (you aren't limited to three)!\n", "## Anatomy of a level\n\nEach level contains three vertial panes. The left-hand pane contains a list of the tactics and\ntheorem statements you've seen so far. Click on the arrows to dig deeper.\n\nThe middle pane is the one you're reading now! It contains text and interactive exercises.\nThe right-hand pane contains the Lean Infoview window, showing the 'tactic state' and error messages.\n\nYou can navigate through the book using the buttons in the top horizonal pane. The circular arrow\nresets your progress.\n", "## How `rw` here differs from that in standard Lean\n\nThe `rw` tactic used in this book is slightly different the standard `rw`. In particular, if\nthe result of a rewrite is an equation of the form `X = X`, then the standard `rw` tactic will\nautomatically close the goal via reflexivity.\n\nThis automation has been disabled here to help you think more carefully about proof construction.\n", "import myint.basic equations.commutativity_rw -- hide\n", "# Equations\n\n## Level 3: Rewriting with hypotheses\n\nLook at the theorem below. It seems that you're being asked to prove `x + y = x + 2 * x`.\nSurely that isn't true in general! What's\ngoing on? If you look carefully, you'll see an additional hypothesis, `h : y = 2 * x`.\n\nThe `:` is just notation for naming a hypothesis (also called an assumption).\nSo the statement of the theorem can be read:\n\n> Let `x` and `y` be integers. Let `h` be the hypothesis `y = 2 * x`.\n> Then `x + y = x + 2 * x`.\n\nWhen you start the proof, you'll note in the top-right pane that `h : y = 2 * x` has been\nadded to the context.\n\nYou can use the hypothesis to rewrite the goal by typing `rw h` much as you used `rw add_comm`\nto rewrite via the theorem `add_comm`.\n\n### Tasks\n\n* Before doing the problem in Lean, think about what effect `rw h` will have on the goal.\n\n* Predict what error message Lean will produce if you replace `sorry` with `refl`. Test your\nprediction.\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "namespace pre_group -- hide\n", "variables (x y : \u2124) -- hide\n", "Let `x` and `y` be integers. Let `h` be the hypothesis `y = 2 * x`. Then `x + y = x + 2 * x`.\n", "end pre_group -- hide\n", "end exlean -- hide\n", "## Translation to a hand-written proof\n\n> Rewriting using `h`, the goal is to prove `x + 2 * x = x + 2 * x`.\n> This follows by reflexivity.\n", "import myint.basic equations.commutativity_rw-- hide\n", "# Equations\n\n## Level 4: Focussed rewriting\n\nHere, you're asked to prove `(x + y) + z = z + (y + x)`. Clearly a case for rewriting with the\n`add_comm` theorem.\n\nThink about what `rw add_comm` will do. What will happen if you do `rw add_comm` twice? Try this\nbelow and test your conjecture.\n\nWhat happens is that `rw add_comm` looks for an expression of the form `a + b`. It finds one in\n`(x + y) + z`, matching `a` with `x + y` and `b` with `z`. It replaces this with `b + a`. That is,\nwith `z + (x + y)`.\n\nYou might wonder why this is the first match. Why doesn't Lean work on `x + y` first, matching\n`a` with `x` and `b` with `y`? It's because Lean works outside-in, then left-to-right. The second\n`+` operator in `(x + y) + z` is the outermost operator, so is read first by Lean.\n\nThe problem: applying `rw add_comm` to the new goal `\u22a2 z + (x + y) = z + (y + x)` will match `a`\nwith `z` and `b` with `x + y`, rewriting the goal to `\u22a2 (x + y) + z = z + (y + x)`, taking us back\nto where we started!\n\n### Focussing a rewrite with arguments\n\nRecall that `add_comm a b` is the theorem that `a + b = b + a`. The quantities `a` and `b` are\n*arguments* to the theorem `add_comm`.\nEqually, `add_comm x (y + z)` is the theorem that `x + (y + z) = (y + z) + x`. This theorem has\narguments `x` and `y + x`. Note than arguments can be expressions, not just variables.\n\nApplying `rw add_comm x (y + z)` transforms `\u22a2 z + (x + (y + z)) = z` to\n`\u22a2 z + ((y + z) + x) = z`.\n\n### Tasks\n* Think about what would happen if you replaced `sorry` with `rw z y`. Try it out. Explain the\nresulting error message.\n\n* Use arguments, where necessary, to prove the theorem below.\n\n\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "namespace pre_group -- hide\n", "variables (x y z : \u2124) -- Declare `x`, `y`, and `z` to be integers.\n", "\nWhen you start the proof below, Lean displays the target as `\u22a2 x + y + z = z + (y + x)`.\nWhat happened to the parentheses on the left-hand side? Lean treats addition as\n'left associative'. This is a fancy way of saying that `x + y + z` should always be\ninterpreted as `(x + y) + z`.\n", "Missing parentheses?", "Let `x`, `y`, and `z` be integers. Then `(x + y) + z = z + (y + x)`.\n", "end pre_group -- hide\n", "end exlean -- hide\n", "## Translation to a hand-written proof\n\nHere's a suggestion. When writing a proof by hand, you need not (and should not) aim at a direct\ntranslation of a Lean proof. Here, I've kept the main idea of each line of my Lean proof while\ntranslating for ease of human understanding.\n\n> Rewriting by additive commutativity, the goal is to prove `z + (x + y) = z + (y + x)`.\n> Rewriting with additive commutativity on `x + y`, the goal is to prove `z + (y + x) = z + (y + x)`.\n> This follows by reflexivity.\n", "import myint.basic equations.commutativity_rw -- hide\n", "# Equations\n\n## Level 5: Associativity\n\nTime for a new theorem. This one is called `add_assoc`, which is short for additive associativity.\n\nThe result `add_assoc a b c` states that `(a + b) + c = a + (b + c)`, for all integers `a`, `b`,\nand `c`. You can see the statement in the sidebar on the left by unfolding 'Theorem statements'.\n\nAs with `add_comm`, you can use `add_assoc` to rewrite the goal using `rw add_assoc`.\n\nBelow, your task is to prove `(x + y) + z = x + (z + y)`. In future levels, this theorem will\nbe available as `add_right_comm`.\n\n**Before writing a Lean proof**, construct a hand-written proof.\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "namespace pre_group -- hide\n", "(a + b) + c = a + (b + c)\n", "theorem myint.add_assoc (a b c : \u2124) : a + b + c = a + (b + c) := myint.add_assoc' a b c -- hide\n", "open myint\n", "### Tasks\n\n* Think about what would happen if you performed `rw add_assoc` once, twice, and thrice.\n  Try it out and compare with your predication.\n\n* Prove the theorem below.\n\n", "\nYou'll need to rewrite with both `add_comm` and `add_assoc`. You may need to give arguments to one\nof your rewrites, as described in the previous level.\n", "Hint", "Let `x`, `y`, and `z` be integers. Then `(x + y) + z = x + (z + y)`.\n", "## Translation to a hand-written proof\n\nIn the following hand-written proof, I omit the word 'rewriting'.\n\n> By associativity, the goal is to prove `x + (y + z) = x + (z + y)`.\n> By commutativity, the goal is to prove `x + (z + y) = x + (z + y)`.\n> This follows by reflexivity.\n", "end pre_group -- hide\n", "end exlean -- hide", "import myint.basic equations.associativity -- hide\n", "# Equations\n\n## Level 6: Structuring proofs with `have`\n\nThe `have` tactic introduces a hypothesis into the context. It's a way to add structure to your\nproofs, stating and proving intermediate results before using them.\n\nConsider the goal `\u22a2 x + ((x + y) + z) = x + (z + (x + y))`.\n\nOne way to close this goal is to rewrite, giving specific arguments to `add_comm`.\nAnother option is to introduce an intermediate goal of proving `(x + y) + z = z + (x + y)`.\n\nThis is accomplished using `have h : (x + y) + z = z + (x + y)` (followed by a comma). \nThere's nothing special about `h` as the name of the hypothesis. Change it to whatever you wish.\n\nThis opens up a new goal: you'll see 2 goals in right-hand pane. The top goal is the new goal,\nnamely `\u22a2 (x + y) + z = z + (x + y)`. The bottom goal is the old goal, only with a new hypothesis,\n`h : (x + y) + z = z + (x + y)`.\n\nYou first work on closing the new goal, then close the original goal using hypothesis `h`.\n", "\nIf you want to work only on goal, put braces after the `have`. When you're cursor is in the\ninner brace, you'll only be working on the first goal.\n```\nhave h : (x + y) + z = z + (x + y),\n{ sorry },\nsorry\n``` \n", "Focussing on one goal at a time", "`have` is used to introduce a new hypothesis into the context. It opens a new goal for the proof\nof the hypothesis.\n\nFor example, `have h2 : x + y = y + x` introduces a new goal, to prove\n`x + y = y + x` while adding the hypothesis `h2 : x + y = y + x` to the context of the old goal.\n", "namespace exlean -- hide\n", "namespace pre_group -- hide\n", "open_locale mynum -- hide\n", "open myint -- hide\n", "variables (x y z : \u2124) -- hide\n", "Let `x`, `y`, and `z` be integers. Then `x + ((x + y) + z) = x + (z + (x + y)))`.\n", "## Translation to a hand-written proof\n\nIn my hand-written proof below, I omit references to reflexivity.\n\n> I claim `h : (x + y) + z = z + (x + y)`.\n> To prove this, use commutativity of addition.\n> Rewrite the original goal using `h`.\n", "end pre_group -- hide\n", "end exlean -- hide", "import myint.basic equations.associativity -- hide\n", "# Equations\n\n## Level 7: Multiple rewrites\n\nRather than writing, for example `rw add_assoc x y z, rw add_comm`, you can write\n`rw [add_assoc x y z, add_comm]`.\n\n### Tasks\n\n* Use this technique, together with `have`, to write a structured proof below.\n\n* Now write a proof using a long chain of rewrites followed by `refl`. Which proof do you prefer? Why?\n", "namespace exlean -- hide\n", "namespace pre_group -- hide\n", "open_locale mynum -- hide\n", "open myint -- hide\n", "variables (x y z : \u2124) -- hide\n", "Let `x`, `y`, and `z` be integers. Then `x + (y + (x + z)) = (z + (x + y)) + x`.\n", "end pre_group -- hide\n", "end exlean -- hide", "import myint.basic equations.multiple_rewrites -- hide\n", "# Equations\n\n## Level 8: Backward rewrites\n\nSuppose you wanted to prove `y + x = 0` on the assumptions `h1 : x + 0 = 0` and `h2 : y = 0`.\nOne option would be to rewrite with `h2` to give `\u22a2 0 + x = 0`. You could then finish by\nrewriting with `add_comm` and `h1`.\n\nAnother option is to start by rewriting with `h1` *backward*. This would replace `0`\nin the target with `x + 0`. To do this in Lean, type `rw \u2190h1`.\n\nTo get the left arrow, type `\\l` followed by space or tab. Alternatively, just type `<-`\n", "namespace exlean -- hide\n", "namespace pre_group -- hide\n", "open_locale mynum -- hide\n", "open myint -- hide\n", "variables (x y z : \u2124) -- hide\n", "Here is a proof of this result, using three rewrites, one backward.\n", "example (h1 : x + 0 = 0) (h2 : y = 0) : y + x = 0 :=\nbegin\n", "  [pure_maths] -- hide\n", "  rw [\u2190h1, add_comm, h2],\n  refl,\n", "-- hide  \n", "end\n", "### Tasks\n* Prove the following using two rewrites, one backward.\n\n* Once you've done that, write a structured proof of the same result.\n", "\nIntroduce and prove the hypotheses `h2 : y + z * x = (z + x) + y` and\n`h3 : (z + x) + y = y + (z + x)` using the `have` tactic. Finish by rewriting with these\nhypotheses.\n", "Hint for structured proof", "Let `x`, `y`, and `z` be integers. If `(z + x) + y = y + z * x`, then `y + z * x = y + (z + x)`\n", "end pre_group -- hide\n", "end exlean -- hide", "import myint.basic equations.backward_rewrite -- hide\n", "# Equations\n\n## Level 9: Additive identity\n\nThe Lean theorem `add_zero` states that `x + 0 = x` for every integer `x`. In mathematics, this\nproperty is called (right) additive identity. Note `add_zero` should appear as a 'Theorem statement'\nin the left-hand pane. \n", "namespace exlean -- hide\n", "namespace pre_group -- hide\n", "open_locale mynum -- hide\n", "open myint -- hide\n", "a + 0 = a\n", "theorem add_zero (a : \u2124) : a + 0 = a := myint.add_zero' a -- hide\n", "Your goal is to prove `zero_add`, the right additive identity property, using `add_zero`.\nOnce you've done this, `zero_add` will be available to you in future levels.\n\nYou can use a series of rewrites and a `refl` or you can use a `rw` and the `exact` tactic, as\ndescrbed in the drop-down box below.\n\nAs always, construct a hand-written proof **before** writing your Lean proof.\n", "If `h` an expression (or the name of a hypothesis or theorem) that exactly matches the target,\nthen `exact h` will close the current goal.\n", "The `exact` tactic can be used in place of `rw` where a hypothesis or theorem *exactly*\nmatches the target.\n\nThus, the goal `\u22a2 (x + y) + z = x + (y + z)` is closed with `exact add_assoc x y z`.\n\nLikewise, if `h : x + y + 5 = 10`, then `\u22a2 x + y + 5 = 10` is closed with `exact h`.\n", "The `exact` tactic.", "`0 + a = a` for every integer `a`.\n", "end pre_group -- hide\n", "end exlean -- hide", "import myint.basic equations.additive_identity -- hide\n", "# Equations\n\n## Level 10: Universal statements\n\nSo far, our hypotheses have made reference to specific variables. The hypothesis `h : x + 3 = 5`\nstates `x + 3 = 5` for the particular variable `x`.\n\nIf we want a statement that holds *for every* value of a variable, we use the *universal quantifier*\n`\u2200`. This is read, \"for all\" or \"for every\" and is typed `\\all`.\n\nFor example, `\u2200 (x : \u2124), x + 5 = 10` states that `x + 5 = 10` *for every* integer `x`. Of course,\nthis is a false statement! A statement that begins with `\u2200` is called a\n*universally quantified statement*.\n\nHere's how to *use* a universally quantified statement. Given the hypothesis\n`h : \u2200 (x : \u2124), x + 5 = 10`, the expression `h 3` corresponds to `3 + 5 = 10`.\nIt's what we get by replacing `x` with `3` in the body of the statement.\n\nIf `3 + 5` appears in the target, then `rw h 3` replaces `3 + 5` with `10`.\n\n### The specialize tactic\n\nThe `specialize` tactic specializes a universally quantified statement. For example if\n`h : \u2200 (x : \u2124), x + 5 = 10`, then `specialize h 20` *replaces* `h` with\n`h : 20 + 5 = 10`. However, after using `specialize`, you can't go back to the more general\nversion of `h`.\n", "namespace exlean -- hide\n", "namespace pre_group -- hide\n", "open_locale mynum -- hide\n", "open myint -- hide\n", "variable (x : \u2124) -- hide\n", "\n### Tasks\n\nHere, you'll prove the unusual result `2 + 5 = 8 + 5` on the assumption `\u2200 x, x + 5 = 10`.\n\n\n* Write a proof using `rw`.\n\n* Write another proof where you use one `rw` and one application of `specialize`.\n\n* Think about how you'd write this proof by hand. Compare with my suggested translation at the bottom\nof the page.\n", "Let the hypothesis `h` be a universally-quantified statement. For example,\n`h : \u2200 (x : \u2124), x + 5 = 10`.\nThen `specialize h 8` replaces `x` with `8` in the body of `h`. Thus `h` becomes `8 + 5 = 10`.\n\nYou can specialize on more than one variable at a time. If `k : \u2200 (x y : \u2124), x + y = y * x`, then\n`specialize k 2 3` replaces `h` with `h : 2 + 3 = 3 * 2`.\n", "`2 + 5 = 8 + 5` on the assumption `\u2200 x, x + 5 = 10`.\n", "## Translation to a hand-written proof\n\n> Using `h` with `2` in space of `x`, we must show `10 = 8 + 5`.\n> But this follows on taking `x` to be `8` in `h`.\n", "end pre_group -- hide\n", "end exlean -- hide", "import myint.basic equations.additive_identity -- hide\n", "# Equations\n\n## Level 11: Uniqueness of additive identity\n\nIn a previous level, we saw that there's an integer `0` with the property that\n`x + 0 = x` for every `x`.\n\nIn this level, you'll show that `0` is the *only* integer that satisfies this property.\n", "namespace exlean -- hide\n", "namespace pre_group -- hide\n", "open_locale mynum -- hide\n", "open myint -- hide\n", "### Rewriting at a hypothesis\n\nBy default, `rw add_assoc` (say) applies `add_assoc` to the target. If `h` is a hypothesis in the\nlocal context, `rw add_assoc at h` will rewrite `h` using `add_assoc`.\n\nIn the example below, we rewrite at `h` and finish with `exact`. Alternatively, we could have\nperformed a backward `rw` at the target using `rw \u2190add_assoc`.\n", "example (x y z : \u2124) (h : (x + y) + z = 20) : x + (y + z) = 20 :=\nbegin\n  rw add_assoc at h,\n  exact h,\nend\n", "Use the `specialize` tactic.\n", "Hint", "Let `e` be an integer satsifying the property `\u2200 (x : \u2124), x + e = x`. Then `e` must be `0`.\n", "end pre_group -- hide\n", "end exlean -- hide", "import myint.basic equations.unique_additive_identity -- hide\n", "# Equations\n\n## Level 12: Additive inverse\n\nThe Lean theorem `add_left_neg` states that `(-a) + a = 0` for every integer `a`. In mathematics,\nthis property is called (left) additive inverse.\n\nLikewise `add_right_neg (a : \u2124) : a + (-a) = 0`.\n\nYou'll use one of these properties in proving the next result.\n", "namespace exlean -- hide\n", "namespace pre_group -- hide\n", "open_locale mynum -- hide\n", "open myint -- hide\n", "(-a) + a = 0\n", "theorem add_left_neg (a : \u2124) : (-a) + a = 0  := myint.add_left_neg a -- hide\n", "a + (-a) = 0\n", "theorem add_right_neg (a : \u2124) : a + (-a) = 0  := myint.add_right_neg a -- hide\n", "You might find it useful to use the previously-proved theorem `add_right_comm`.\n", "Hint", "For all integers `x` and `y`, we have `(x + y) + -x = y`.\n", "end pre_group -- hide\n", "export pre_group (add_add_neg) -- hide\n", "end exlean -- hide", "import myint.basic equations.additive_inverse -- hide\n", "# Equations\n\n## Level 13: Cancellation I\n\nRecall the (right) uniqueness of additive identity. Let `y` be an integer. If for every integer `x`,\nwe have `x + y = x`, then `y = 0`.\n\nIn this level, we'll prove a theorem that is subtly different. Let `y` and `x` be integers. If\n`x + y = x`, then `y = 0`.\n\n**Question**: how does this new statement differ from from the uniqueness of additive identity?\n\nThe new result cannot be proved using only additive identity. You'll need to use the\nadditive inverse property.\n\nThis may be the most challenging level so far.\n", "namespace exlean -- hide\n", "namespace pre_group -- hide\n", "open_locale mynum -- hide\n", "open myint -- hide\n", "Use `add_add_neg`.\n", "Hint", "If `a + b = a`, then `b = 0`.\n", "end pre_group -- hide\n", "end exlean -- hide", "import myint.basic equations.cancellation_i -- hide\n", "# Equations\n\n## Level 14: Uniqueness of additive inverse\n\nWe've seen the uniqueness of (right) additive identity. Now we'll show the uniqueness of (right)\nadditive inverse.\n", "namespace exlean -- hide\n", "namespace pre_group -- hide\n", "open_locale mynum -- hide\n", "open myint -- hide\n", "Use `add_add_neg`.\n", "Hint", "Let `x` and `y` be integers. If `x + y = 0`, then `y = -x`. \n", "end pre_group -- hide\n", "end exlean -- hide", "import myint.basic equations.unique_additive_inverse -- hide\n", "# Equations\n\n## Level 15: The simplifier\n\nThis level introduces a powerful new tactic, `simp`, Lean's simplifier. It rewrites \nrepeatedly using either supplied theorems & hypotheses or theorems that it 'knows'.\n\nTo suggest theorems and hypotheses for use with `simp`, provide them as a comma-separated list.\nIn the example below, we supply `simp` with `add_assoc` and `add_comm y x`.\n\nWithout `simp`, you'd need several applications of `rw add_assoc`. \n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "namespace pre_group -- hide\n", "open myint -- hide\n", "example (x y z : \u2124) : x + ((y + z) + x) = (y + x) + (z + x) :=\nbegin\n  simp [add_assoc, add_comm y x],\nend\n", "### Tasks\n\n* Prove the result below using only `simp` with supplied theorems, as in the example above. You should\nonly need to supply four theorems.\n\n* For fun (!) try proving this result using `rw`. Which proof do you prefer?\n", "Let `x`, `y`, and `z` be integers. Then `(y + x) + (0 + z + 0) + (0 + x + 0) = y + (z + (x + x))`\n", "The `simp` tactic rewrites repeatedly using either supplied theorems & hypotheses or theorems\nthat it 'knows'.\n\nTo suggest theorems and hypotheses for use with `simp`, provide them as a comma-separated list.\nFor example `simp [h, add_comm]` rewrites repeatedly with hypotheses `h` and theorem `add_comm`.\n", "end pre_group -- hide\n", "end exlean -- hide", "import myint.basic equations.simplifier -- hide\n", "-- This import contains the definitions of the algebraic structures `add_monoid`, `add_comm_group`, etc.\nimport algebra.group.basic\n", "# Equations\n\n## Level 16: Algebraic structures and advanced tactics\n\nIn this level, we'll show how to unleash `simp`'s power using 'type classes'. We'll introduce\nalgebraic structures (such as additive monoid and additive commutative group) that you'll explore\nin greater detail later.\n\nIn the last level, I mentioned that `simp` can use theorems that it knows, but we still had to\nsupply every theorem explicitly.\n\nThe reason is that `simp` doesn't (yet) know anything about\nthe integer type we've been using. That's because we aren't actually using Lean's built-in integer\ntype, but our own copy, called `myint`.\n\nThe result I've called `zero_add` is short for `exlean.pre_group.zero_add`.\nHere `exlean` and `pre_group` are\n<a href=\"https://leanprover.github.io/theorem_proving_in_lean/dependent_type_theory.html#namespaces\",\ntarget = \"blank\">namespaces</a> I've created to hide the messy details. You don't need to\nunderstand namespaces at the moment, beyond the fact that they permit the same name to be used\nfor different functions.\n\n### Monoids and groups\n\nThe simplifier does know a *different* theorem called `zero_add`, outside of any namespace.\nThis theorem isn't restricted to a particular type (such as integers, natural numbers, vectors of\nlength 2, etc.). Rather, it holds for any type belong to the `add_monoid` *type class*.\n\nA type class is merely a mechanism for dealing coherently with a collection of types that satsify\ncertain properties. To be an *instance* of the `add_monoid` type class, a type `G` must have a 'zero'\nelement and an operation called addition and denoted `+` which satisfiy the properties\nof additive associativity and additive identity (both left and right).\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "namespace pre_group -- hide\n", "open myint -- hide\n", "Here, we show that `myint` is an intance of the `add_monoid` (short for 'additive monoid' type class.\nTo do this, we merely need to provide the apprioate 'fields' of the `add_monoid` structure.\n\nFor example, the line `zero_add := exlean.pre_group.zero_add,` fulfills the `zero_add`\nconstraint of the `add_monoid` type class by supplying our theorem `exlean.pre_group.zero_add`.\n\nIn fact, there are fields other than those shown, but Lean can generate these automatically from\nthe specified fields. This is what the `..` notation asks Lean to do.\n", "instance : add_monoid myint :=\n{ add_assoc := exlean.pre_group.myint.add_assoc,\n  zero_add := exlean.pre_group.zero_add,\n  add_zero := exlean.pre_group.add_zero,\n  .. }\n", "An instance of `add_comm_monoid` is an `add_monoid` for which the `+` operation is commutative.\nWe only need supply the `add_comm` field and let Lean generate the other fields by providing the\ninstance `myint.add_monoid`. Again, we use the `..` notation to do this.\n", "instance : add_comm_monoid myint :=\n{ add_comm := exlean.myint.add_comm,\n  .. myint.add_monoid }\n", "An `add_group` (addtive group) is an `add_monoid` that has an additive negation operator which\nsatisfies the `add_left_neg` property, namely that `(-a) + a = 0` for every `a`.\n", "instance : add_group myint :=\n{ neg := exlean.myint.neg,\n  add_left_neg := exlean.pre_group.add_left_neg,\n  .. myint.add_monoid }\n", "Finally an `add_comm_group` (additive commutative group) is an additive group that is also\nan additive commutative monoid. All we need do is provide the required instances.\n", "instance : add_comm_group myint :=\n{ .. myint.add_group, .. myint.add_comm_monoid }\n", "end pre_group -- hide\n", "### Levelled-up `simp`\n\nNow `simp` will automatically use `zero_add`, `add_zero`, `add_left_neg`, `add_right_comm`, etc.\nHere's an example.\n", "example (x y : \u2124) : x + (-y) + y = x + 0 :=\nbegin\n  simp\nend\n", "Note that `add_assoc` and `add_comm` are *not* automatically applied by `simp`. Can you think why?\n", "example (x y z : \u2124) : (y + x) + (0 + z + 0) + (0 + x + 0) = y + (z + (x + x)) :=\nbegin\n  simp [add_assoc, add_comm x z],\nend\n", "In the example below, an ordinary `simp` would be useless as the target `\u22a2 x = y` cannot be\nsimplified further. However, using `simp at h` will simplify the hypothesis `h` using the \n`sub_right_inj` theorem. You haven't seen this theorem yet: suffice it to say that it does the \nobvious thing and `simp` finds it for you.\n\n", "example (x y z : \u2124) (h : z - x = z - y) : x = y :=\nbegin\n  simp at h,\n  exact h,\nend\n", "### Congruence closure\n\nCongruence closure, or `cc`, is another powerful tactic. Don't worry about what the words\n'congruence' and 'closure' mean here\u2014they refer to concepts in computer science.\n\nRoughly speaking, `cc` can be used to prove equations where the proof depends on associativity,\ncommutativity, and (optionally) the use of hypotheses in the local context. Here's an example.\n", "example (x y z : \u2124) (h : (z + x) + y = y + z * x) : y + z * x = y + (z + x) :=\nbegin\n  cc,\nend\n", "`cc` can be used to prove equations where the proof depends on associativity,\ncommutativity, and (optionally) the use of hypotheses in the local context.\n", "Use `simp` (and whatever else you need) to prove the following result.\nThis is similar to a hard result you proved in a previous level.\n", "If `y + x = x`, then `y = 0`.\n", "end exlean -- hide\n", "Functions", "import mynat.basic -- hide\n", "# Functions\n\n## Level 1: Defining functions\n\nA function is a map from one set, called the domain, to another set, called the codomain.\n\nThe notation `f : S \u2192 T` is read, \"`f` is a function with domain `S` and codomain `T`\" or \"`f` is a\nfunction from `S` to `T`\".\n\nTo specify that `f` maps each `x` to some expression `y`, we write `f : x \u21a6 y` or\n`f(x) = y`, when doing mathematics by hand.\n\nIn Lean, we combine all the above information into:\n```\ndef f : S \u2192 T := \u03bb x, y\n```\nwhere `y` is an expression that depends on `x`. Here `\u03bb` is a Greek letter called lambda.\nIts only significance is to indicate that the following quantity `x` is a variable.\n\nBelow is the definition of a function `my_f` from the set `\u2115` of natural numbers (the non-negative)\nintegers to itself. It takes each `x` to `3 * x + 5`.\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "The function `my_f` is defined so that `my_f (x) = 3 * x + 5` for every \nnatural number `x`.\n", "def my_f : \u2115 \u2192 \u2115 := \u03bb x, 3 * x + 5\n", "Your task is to prove `my_f 10 = 35`. By definition of `my_f`, you must prove `3 * 10 + 5 = 35`.\nIt may come as a surprise to learn that Lean can prove this using `refl`.\nThe reason is that when Lean uses `refl`, it applies definitions until no further simplification is\npossible. For reasons that will become apparent later, the definitions of addition and\nmultiplication can be applied to reduce any 'sum' into a natural number.\n", "The function `my_f` takes `10` to `35`.\n", "end exlean -- hide\n"]]}